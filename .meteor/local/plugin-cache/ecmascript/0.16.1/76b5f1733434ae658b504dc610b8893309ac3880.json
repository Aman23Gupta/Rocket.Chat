{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/models/server/models/FederationEvents.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/models/server/models/FederationEvents.js","filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/models/server/models/FederationEvents.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","root":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/models/server/models/FederationEvents.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/models/server/models/FederationEvents.js"}},"code":"module.export({\n  eventTypes: () => eventTypes,\n  contextDefinitions: () => contextDefinitions,\n  FederationEventsModel: () => FederationEventsModel\n});\nlet SHA256;\nmodule.link(\"meteor/sha\", {\n  SHA256(v) {\n    SHA256 = v;\n  }\n\n}, 0);\nlet Base;\nmodule.link(\"./_Base\", {\n  Base(v) {\n    Base = v;\n  }\n\n}, 1);\nconst eventTypes = {\n  // Global\n  GENESIS: 'genesis',\n  PING: 'ping',\n  // Room\n  ROOM_DELETE: 'room_delete',\n  ROOM_ADD_USER: 'room_add_user',\n  ROOM_REMOVE_USER: 'room_remove_user',\n  ROOM_USER_LEFT: 'room_user_left',\n  ROOM_MESSAGE: 'room_message',\n  ROOM_EDIT_MESSAGE: 'room_edit_message',\n  ROOM_DELETE_MESSAGE: 'room_delete_message',\n  ROOM_SET_MESSAGE_REACTION: 'room_set_message_reaction',\n  ROOM_UNSET_MESSAGE_REACTION: 'room_unset_message_reaction',\n  ROOM_MUTE_USER: 'room_mute_user',\n  ROOM_UNMUTE_USER: 'room_unmute_user'\n};\nconst contextDefinitions = {\n  ROOM: {\n    type: 'room',\n\n    isRoom(event) {\n      return !!event.context.roomId;\n    },\n\n    contextQuery(roomId) {\n      return {\n        roomId\n      };\n    }\n\n  },\n\n  defineType(event) {\n    if (this.ROOM.isRoom(event)) {\n      return this.ROOM.type;\n    }\n\n    return 'undefined';\n  }\n\n};\n\nclass FederationEventsModel extends Base {\n  constructor(nameOrModel) {\n    super(nameOrModel);\n    this.tryEnsureIndex({\n      hasChildren: 1\n    }, {\n      sparse: true\n    });\n    this.tryEnsureIndex({\n      timestamp: 1\n    });\n  }\n\n  getEventHash(contextQuery, event) {\n    return SHA256(\"\".concat(event.origin).concat(JSON.stringify(contextQuery)).concat(event.parentIds.join(',')).concat(event.type).concat(event.timestamp).concat(JSON.stringify(event.data)));\n  }\n\n  createEvent(origin, contextQuery, type, data) {\n    return Promise.asyncApply(() => {\n      let previousEventsIds = []; // If it is not a GENESIS event, we need to get the previous events\n\n      if (type !== eventTypes.GENESIS) {\n        const previousEvents = Promise.await(this.model.rawCollection().find({\n          context: contextQuery,\n          hasChildren: false\n        }).toArray()); // if (!previousEvents.length) {\n        // \tthrow new Error('Could not create event, the context does not exist');\n        // }\n\n        previousEventsIds = previousEvents.map(e => e._id);\n      }\n\n      const event = {\n        origin,\n        context: contextQuery,\n        parentIds: previousEventsIds || [],\n        type,\n        timestamp: new Date(),\n        data,\n        hasChildren: false\n      };\n      event._id = this.getEventHash(contextQuery, event); // this.insert(event);\n      // Clear the \"hasChildren\" of those events\n\n      Promise.await(this.update({\n        _id: {\n          $in: previousEventsIds\n        }\n      }, {\n        $unset: {\n          hasChildren: ''\n        }\n      }, {\n        multi: 1\n      }));\n      return event;\n    });\n  }\n\n  createGenesisEvent(origin, contextQuery, data) {\n    return Promise.asyncApply(() => {\n      // Check if genesis event already exists, if so, do not create\n      const genesisEvent = Promise.await(this.model.rawCollection().findOne({\n        context: contextQuery,\n        type: eventTypes.GENESIS\n      }));\n\n      if (genesisEvent) {\n        throw new Error(\"A GENESIS event for this context query already exists: \".concat(JSON.stringify(contextQuery, null, 2)));\n      }\n\n      return this.createEvent(origin, contextQuery, eventTypes.GENESIS, data);\n    });\n  }\n\n  addEvent(contextQuery, event) {\n    return Promise.asyncApply(() => {\n      // Check if the event does not exit\n      const existingEvent = this.findOne({\n        _id: event._id\n      }); // If it does not, we insert it, checking for the parents\n\n      if (!existingEvent) {\n        // Check if we have the parents\n        const parents = Promise.await(this.model.rawCollection().find({\n          context: contextQuery,\n          _id: {\n            $in: event.parentIds\n          }\n        }, {\n          _id: 1\n        }).toArray());\n        const parentIds = parents.map(_ref => {\n          let {\n            _id\n          } = _ref;\n          return _id;\n        }); // This means that we do not have the parents of the event we are adding\n\n        if (parentIds.length !== event.parentIds.length) {\n          const {\n            origin\n          } = event; // Get the latest events for that context and origin\n\n          const latestEvents = Promise.await(this.model.rawCollection().find({\n            context: contextQuery,\n            origin\n          }, {\n            _id: 1\n          }).toArray());\n          const latestEventIds = latestEvents.map(_ref2 => {\n            let {\n              _id\n            } = _ref2;\n            return _id;\n          });\n          return {\n            success: false,\n            reason: 'missingParents',\n            missingParentIds: event.parentIds.filter(_ref3 => {\n              let {\n                _id\n              } = _ref3;\n              return parentIds.indexOf(_id) === -1;\n            }),\n            latestEventIds\n          };\n        } // Clear the \"hasChildren\" of the parent events\n\n\n        Promise.await(this.update({\n          _id: {\n            $in: parentIds\n          }\n        }, {\n          $unset: {\n            hasChildren: ''\n          }\n        }, {\n          multi: 1\n        }));\n        this.insert(event);\n      }\n\n      return {\n        success: true\n      };\n    });\n  }\n\n  getEventById(contextQuery, eventId) {\n    return Promise.asyncApply(() => {\n      const event = Promise.await(this.model.rawCollection().findOne({\n        context: contextQuery,\n        _id: eventId\n      }));\n      return {\n        success: !!event,\n        event\n      };\n    });\n  }\n\n  getLatestEvents(contextQuery, fromTimestamp) {\n    return Promise.asyncApply(() => {\n      return this.model.rawCollection().find({\n        context: contextQuery,\n        timestamp: {\n          $gt: new Date(fromTimestamp)\n        }\n      }).toArray();\n    });\n  }\n\n  removeContextEvents(contextQuery) {\n    return Promise.asyncApply(() => {\n      return this.model.rawCollection().remove({\n        context: contextQuery\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["app/models/server/models/FederationEvents.js"],"names":["module","export","eventTypes","contextDefinitions","FederationEventsModel","SHA256","link","v","Base","GENESIS","PING","ROOM_DELETE","ROOM_ADD_USER","ROOM_REMOVE_USER","ROOM_USER_LEFT","ROOM_MESSAGE","ROOM_EDIT_MESSAGE","ROOM_DELETE_MESSAGE","ROOM_SET_MESSAGE_REACTION","ROOM_UNSET_MESSAGE_REACTION","ROOM_MUTE_USER","ROOM_UNMUTE_USER","ROOM","type","isRoom","event","context","roomId","contextQuery","defineType","constructor","nameOrModel","tryEnsureIndex","hasChildren","sparse","timestamp","getEventHash","origin","JSON","stringify","parentIds","join","data","createEvent","previousEventsIds","previousEvents","model","rawCollection","find","toArray","map","e","_id","Date","update","$in","$unset","multi","createGenesisEvent","genesisEvent","findOne","Error","addEvent","existingEvent","parents","length","latestEvents","latestEventIds","success","reason","missingParentIds","filter","indexOf","insert","getEventById","eventId","getLatestEvents","fromTimestamp","$gt","removeContextEvents","remove"],"mappings":"AAAAA,MAAM,CAACC,MAAP,CAAc;AAACC,EAAAA,UAAU,EAAC,MAAIA,UAAhB;AAA2BC,EAAAA,kBAAkB,EAAC,MAAIA,kBAAlD;AAAqEC,EAAAA,qBAAqB,EAAC,MAAIA;AAA/F,CAAd;AAAqI,IAAIC,MAAJ;AAAWL,MAAM,CAACM,IAAP,CAAY,YAAZ,EAAyB;AAACD,EAAAA,MAAM,CAACE,CAAD,EAAG;AAACF,IAAAA,MAAM,GAACE,CAAP;AAAS;;AAApB,CAAzB,EAA+C,CAA/C;AAAkD,IAAIC,IAAJ;AAASR,MAAM,CAACM,IAAP,CAAY,SAAZ,EAAsB;AAACE,EAAAA,IAAI,CAACD,CAAD,EAAG;AAACC,IAAAA,IAAI,GAACD,CAAL;AAAO;;AAAhB,CAAtB,EAAwC,CAAxC;AAIpM,MAAML,UAAU,GAAG;AACzB;AACAO,EAAAA,OAAO,EAAE,SAFgB;AAGzBC,EAAAA,IAAI,EAAE,MAHmB;AAKzB;AACAC,EAAAA,WAAW,EAAE,aANY;AAOzBC,EAAAA,aAAa,EAAE,eAPU;AAQzBC,EAAAA,gBAAgB,EAAE,kBARO;AASzBC,EAAAA,cAAc,EAAE,gBATS;AAUzBC,EAAAA,YAAY,EAAE,cAVW;AAWzBC,EAAAA,iBAAiB,EAAE,mBAXM;AAYzBC,EAAAA,mBAAmB,EAAE,qBAZI;AAazBC,EAAAA,yBAAyB,EAAE,2BAbF;AAczBC,EAAAA,2BAA2B,EAAE,6BAdJ;AAezBC,EAAAA,cAAc,EAAE,gBAfS;AAgBzBC,EAAAA,gBAAgB,EAAE;AAhBO,CAAnB;AAmBA,MAAMlB,kBAAkB,GAAG;AACjCmB,EAAAA,IAAI,EAAE;AACLC,IAAAA,IAAI,EAAE,MADD;;AAELC,IAAAA,MAAM,CAACC,KAAD,EAAQ;AACb,aAAO,CAAC,CAACA,KAAK,CAACC,OAAN,CAAcC,MAAvB;AACA,KAJI;;AAKLC,IAAAA,YAAY,CAACD,MAAD,EAAS;AACpB,aAAO;AAAEA,QAAAA;AAAF,OAAP;AACA;;AAPI,GAD2B;;AAWjCE,EAAAA,UAAU,CAACJ,KAAD,EAAQ;AACjB,QAAI,KAAKH,IAAL,CAAUE,MAAV,CAAiBC,KAAjB,CAAJ,EAA6B;AAC5B,aAAO,KAAKH,IAAL,CAAUC,IAAjB;AACA;;AAED,WAAO,WAAP;AACA;;AAjBgC,CAA3B;;AAoBA,MAAMnB,qBAAN,SAAoCI,IAApC,CAAyC;AAC/CsB,EAAAA,WAAW,CAACC,WAAD,EAAc;AACxB,UAAMA,WAAN;AAEA,SAAKC,cAAL,CAAoB;AAAEC,MAAAA,WAAW,EAAE;AAAf,KAApB,EAAwC;AAAEC,MAAAA,MAAM,EAAE;AAAV,KAAxC;AACA,SAAKF,cAAL,CAAoB;AAAEG,MAAAA,SAAS,EAAE;AAAb,KAApB;AACA;;AAEDC,EAAAA,YAAY,CAACR,YAAD,EAAeH,KAAf,EAAsB;AACjC,WAAOpB,MAAM,WACToB,KAAK,CAACY,MADG,SACMC,IAAI,CAACC,SAAL,CAAeX,YAAf,CADN,SACqCH,KAAK,CAACe,SAAN,CAAgBC,IAAhB,CAAqB,GAArB,CADrC,SACiEhB,KAAK,CAACF,IADvE,SAC8EE,KAAK,CAACU,SADpF,SACgGG,IAAI,CAACC,SAAL,CAC3Gd,KAAK,CAACiB,IADqG,CADhG,EAAb;AAKA;;AAEKC,EAAAA,WAAW,CAACN,MAAD,EAAST,YAAT,EAAuBL,IAAvB,EAA6BmB,IAA7B;AAAA,oCAAmC;AACnD,UAAIE,iBAAiB,GAAG,EAAxB,CADmD,CAGnD;;AACA,UAAIrB,IAAI,KAAKrB,UAAU,CAACO,OAAxB,EAAiC;AAChC,cAAMoC,cAAc,iBAAS,KAAKC,KAAL,CAAWC,aAAX,GAA2BC,IAA3B,CAAgC;AAAEtB,UAAAA,OAAO,EAAEE,YAAX;AAAyBK,UAAAA,WAAW,EAAE;AAAtC,SAAhC,EAA+EgB,OAA/E,EAAT,CAApB,CADgC,CAGhC;AACA;AACA;;AAEAL,QAAAA,iBAAiB,GAAGC,cAAc,CAACK,GAAf,CAAoBC,CAAD,IAAOA,CAAC,CAACC,GAA5B,CAApB;AACA;;AAED,YAAM3B,KAAK,GAAG;AACbY,QAAAA,MADa;AAEbX,QAAAA,OAAO,EAAEE,YAFI;AAGbY,QAAAA,SAAS,EAAEI,iBAAiB,IAAI,EAHnB;AAIbrB,QAAAA,IAJa;AAKbY,QAAAA,SAAS,EAAE,IAAIkB,IAAJ,EALE;AAMbX,QAAAA,IANa;AAObT,QAAAA,WAAW,EAAE;AAPA,OAAd;AAUAR,MAAAA,KAAK,CAAC2B,GAAN,GAAY,KAAKhB,YAAL,CAAkBR,YAAlB,EAAgCH,KAAhC,CAAZ,CAxBmD,CA0BnD;AAEA;;AACA,oBAAM,KAAK6B,MAAL,CAAY;AAAEF,QAAAA,GAAG,EAAE;AAAEG,UAAAA,GAAG,EAAEX;AAAP;AAAP,OAAZ,EAAiD;AAAEY,QAAAA,MAAM,EAAE;AAAEvB,UAAAA,WAAW,EAAE;AAAf;AAAV,OAAjD,EAAkF;AAAEwB,QAAAA,KAAK,EAAE;AAAT,OAAlF,CAAN;AAEA,aAAOhC,KAAP;AACA,KAhCgB;AAAA;;AAkCXiC,EAAAA,kBAAkB,CAACrB,MAAD,EAAST,YAAT,EAAuBc,IAAvB;AAAA,oCAA6B;AACpD;AACA,YAAMiB,YAAY,iBAAS,KAAKb,KAAL,CAAWC,aAAX,GAA2Ba,OAA3B,CAAmC;AAAElC,QAAAA,OAAO,EAAEE,YAAX;AAAyBL,QAAAA,IAAI,EAAErB,UAAU,CAACO;AAA1C,OAAnC,CAAT,CAAlB;;AAEA,UAAIkD,YAAJ,EAAkB;AACjB,cAAM,IAAIE,KAAJ,kEAAoEvB,IAAI,CAACC,SAAL,CAAeX,YAAf,EAA6B,IAA7B,EAAmC,CAAnC,CAApE,EAAN;AACA;;AAED,aAAO,KAAKe,WAAL,CAAiBN,MAAjB,EAAyBT,YAAzB,EAAuC1B,UAAU,CAACO,OAAlD,EAA2DiC,IAA3D,CAAP;AACA,KATuB;AAAA;;AAWlBoB,EAAAA,QAAQ,CAAClC,YAAD,EAAeH,KAAf;AAAA,oCAAsB;AACnC;AACA,YAAMsC,aAAa,GAAG,KAAKH,OAAL,CAAa;AAAER,QAAAA,GAAG,EAAE3B,KAAK,CAAC2B;AAAb,OAAb,CAAtB,CAFmC,CAInC;;AACA,UAAI,CAACW,aAAL,EAAoB;AACnB;AACA,cAAMC,OAAO,iBAAS,KAAKlB,KAAL,CACpBC,aADoB,GAEpBC,IAFoB,CAEf;AAAEtB,UAAAA,OAAO,EAAEE,YAAX;AAAyBwB,UAAAA,GAAG,EAAE;AAAEG,YAAAA,GAAG,EAAE9B,KAAK,CAACe;AAAb;AAA9B,SAFe,EAE2C;AAAEY,UAAAA,GAAG,EAAE;AAAP,SAF3C,EAGpBH,OAHoB,EAAT,CAAb;AAIA,cAAMT,SAAS,GAAGwB,OAAO,CAACd,GAAR,CAAY;AAAA,cAAC;AAAEE,YAAAA;AAAF,WAAD;AAAA,iBAAaA,GAAb;AAAA,SAAZ,CAAlB,CANmB,CAQnB;;AACA,YAAIZ,SAAS,CAACyB,MAAV,KAAqBxC,KAAK,CAACe,SAAN,CAAgByB,MAAzC,EAAiD;AAChD,gBAAM;AAAE5B,YAAAA;AAAF,cAAaZ,KAAnB,CADgD,CAGhD;;AACA,gBAAMyC,YAAY,iBAAS,KAAKpB,KAAL,CAAWC,aAAX,GAA2BC,IAA3B,CAAgC;AAAEtB,YAAAA,OAAO,EAAEE,YAAX;AAAyBS,YAAAA;AAAzB,WAAhC,EAAmE;AAAEe,YAAAA,GAAG,EAAE;AAAP,WAAnE,EAA+EH,OAA/E,EAAT,CAAlB;AACA,gBAAMkB,cAAc,GAAGD,YAAY,CAAChB,GAAb,CAAiB;AAAA,gBAAC;AAAEE,cAAAA;AAAF,aAAD;AAAA,mBAAaA,GAAb;AAAA,WAAjB,CAAvB;AAEA,iBAAO;AACNgB,YAAAA,OAAO,EAAE,KADH;AAENC,YAAAA,MAAM,EAAE,gBAFF;AAGNC,YAAAA,gBAAgB,EAAE7C,KAAK,CAACe,SAAN,CAAgB+B,MAAhB,CAAuB;AAAA,kBAAC;AAAEnB,gBAAAA;AAAF,eAAD;AAAA,qBAAaZ,SAAS,CAACgC,OAAV,CAAkBpB,GAAlB,MAA2B,CAAC,CAAzC;AAAA,aAAvB,CAHZ;AAINe,YAAAA;AAJM,WAAP;AAMA,SAtBkB,CAwBnB;;;AACA,sBAAM,KAAKb,MAAL,CAAY;AAAEF,UAAAA,GAAG,EAAE;AAAEG,YAAAA,GAAG,EAAEf;AAAP;AAAP,SAAZ,EAAyC;AAAEgB,UAAAA,MAAM,EAAE;AAAEvB,YAAAA,WAAW,EAAE;AAAf;AAAV,SAAzC,EAA0E;AAAEwB,UAAAA,KAAK,EAAE;AAAT,SAA1E,CAAN;AAEA,aAAKgB,MAAL,CAAYhD,KAAZ;AACA;;AAED,aAAO;AACN2C,QAAAA,OAAO,EAAE;AADH,OAAP;AAGA,KAtCa;AAAA;;AAwCRM,EAAAA,YAAY,CAAC9C,YAAD,EAAe+C,OAAf;AAAA,oCAAwB;AACzC,YAAMlD,KAAK,iBAAS,KAAKqB,KAAL,CAAWC,aAAX,GAA2Ba,OAA3B,CAAmC;AAAElC,QAAAA,OAAO,EAAEE,YAAX;AAAyBwB,QAAAA,GAAG,EAAEuB;AAA9B,OAAnC,CAAT,CAAX;AAEA,aAAO;AACNP,QAAAA,OAAO,EAAE,CAAC,CAAC3C,KADL;AAENA,QAAAA;AAFM,OAAP;AAIA,KAPiB;AAAA;;AASZmD,EAAAA,eAAe,CAAChD,YAAD,EAAeiD,aAAf;AAAA,oCAA8B;AAClD,aAAO,KAAK/B,KAAL,CACLC,aADK,GAELC,IAFK,CAEA;AAAEtB,QAAAA,OAAO,EAAEE,YAAX;AAAyBO,QAAAA,SAAS,EAAE;AAAE2C,UAAAA,GAAG,EAAE,IAAIzB,IAAJ,CAASwB,aAAT;AAAP;AAApC,OAFA,EAGL5B,OAHK,EAAP;AAIA,KALoB;AAAA;;AAOf8B,EAAAA,mBAAmB,CAACnD,YAAD;AAAA,oCAAe;AACvC,aAAO,KAAKkB,KAAL,CAAWC,aAAX,GAA2BiC,MAA3B,CAAkC;AAAEtD,QAAAA,OAAO,EAAEE;AAAX,OAAlC,CAAP;AACA,KAFwB;AAAA;;AArHsB","sourcesContent":["import { SHA256 } from 'meteor/sha';\n\nimport { Base } from './_Base';\n\nexport const eventTypes = {\n\t// Global\n\tGENESIS: 'genesis',\n\tPING: 'ping',\n\n\t// Room\n\tROOM_DELETE: 'room_delete',\n\tROOM_ADD_USER: 'room_add_user',\n\tROOM_REMOVE_USER: 'room_remove_user',\n\tROOM_USER_LEFT: 'room_user_left',\n\tROOM_MESSAGE: 'room_message',\n\tROOM_EDIT_MESSAGE: 'room_edit_message',\n\tROOM_DELETE_MESSAGE: 'room_delete_message',\n\tROOM_SET_MESSAGE_REACTION: 'room_set_message_reaction',\n\tROOM_UNSET_MESSAGE_REACTION: 'room_unset_message_reaction',\n\tROOM_MUTE_USER: 'room_mute_user',\n\tROOM_UNMUTE_USER: 'room_unmute_user',\n};\n\nexport const contextDefinitions = {\n\tROOM: {\n\t\ttype: 'room',\n\t\tisRoom(event) {\n\t\t\treturn !!event.context.roomId;\n\t\t},\n\t\tcontextQuery(roomId) {\n\t\t\treturn { roomId };\n\t\t},\n\t},\n\n\tdefineType(event) {\n\t\tif (this.ROOM.isRoom(event)) {\n\t\t\treturn this.ROOM.type;\n\t\t}\n\n\t\treturn 'undefined';\n\t},\n};\n\nexport class FederationEventsModel extends Base {\n\tconstructor(nameOrModel) {\n\t\tsuper(nameOrModel);\n\n\t\tthis.tryEnsureIndex({ hasChildren: 1 }, { sparse: true });\n\t\tthis.tryEnsureIndex({ timestamp: 1 });\n\t}\n\n\tgetEventHash(contextQuery, event) {\n\t\treturn SHA256(\n\t\t\t`${event.origin}${JSON.stringify(contextQuery)}${event.parentIds.join(',')}${event.type}${event.timestamp}${JSON.stringify(\n\t\t\t\tevent.data,\n\t\t\t)}`,\n\t\t);\n\t}\n\n\tasync createEvent(origin, contextQuery, type, data) {\n\t\tlet previousEventsIds = [];\n\n\t\t// If it is not a GENESIS event, we need to get the previous events\n\t\tif (type !== eventTypes.GENESIS) {\n\t\t\tconst previousEvents = await this.model.rawCollection().find({ context: contextQuery, hasChildren: false }).toArray();\n\n\t\t\t// if (!previousEvents.length) {\n\t\t\t// \tthrow new Error('Could not create event, the context does not exist');\n\t\t\t// }\n\n\t\t\tpreviousEventsIds = previousEvents.map((e) => e._id);\n\t\t}\n\n\t\tconst event = {\n\t\t\torigin,\n\t\t\tcontext: contextQuery,\n\t\t\tparentIds: previousEventsIds || [],\n\t\t\ttype,\n\t\t\ttimestamp: new Date(),\n\t\t\tdata,\n\t\t\thasChildren: false,\n\t\t};\n\n\t\tevent._id = this.getEventHash(contextQuery, event);\n\n\t\t// this.insert(event);\n\n\t\t// Clear the \"hasChildren\" of those events\n\t\tawait this.update({ _id: { $in: previousEventsIds } }, { $unset: { hasChildren: '' } }, { multi: 1 });\n\n\t\treturn event;\n\t}\n\n\tasync createGenesisEvent(origin, contextQuery, data) {\n\t\t// Check if genesis event already exists, if so, do not create\n\t\tconst genesisEvent = await this.model.rawCollection().findOne({ context: contextQuery, type: eventTypes.GENESIS });\n\n\t\tif (genesisEvent) {\n\t\t\tthrow new Error(`A GENESIS event for this context query already exists: ${JSON.stringify(contextQuery, null, 2)}`);\n\t\t}\n\n\t\treturn this.createEvent(origin, contextQuery, eventTypes.GENESIS, data);\n\t}\n\n\tasync addEvent(contextQuery, event) {\n\t\t// Check if the event does not exit\n\t\tconst existingEvent = this.findOne({ _id: event._id });\n\n\t\t// If it does not, we insert it, checking for the parents\n\t\tif (!existingEvent) {\n\t\t\t// Check if we have the parents\n\t\t\tconst parents = await this.model\n\t\t\t\t.rawCollection()\n\t\t\t\t.find({ context: contextQuery, _id: { $in: event.parentIds } }, { _id: 1 })\n\t\t\t\t.toArray();\n\t\t\tconst parentIds = parents.map(({ _id }) => _id);\n\n\t\t\t// This means that we do not have the parents of the event we are adding\n\t\t\tif (parentIds.length !== event.parentIds.length) {\n\t\t\t\tconst { origin } = event;\n\n\t\t\t\t// Get the latest events for that context and origin\n\t\t\t\tconst latestEvents = await this.model.rawCollection().find({ context: contextQuery, origin }, { _id: 1 }).toArray();\n\t\t\t\tconst latestEventIds = latestEvents.map(({ _id }) => _id);\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\treason: 'missingParents',\n\t\t\t\t\tmissingParentIds: event.parentIds.filter(({ _id }) => parentIds.indexOf(_id) === -1),\n\t\t\t\t\tlatestEventIds,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Clear the \"hasChildren\" of the parent events\n\t\t\tawait this.update({ _id: { $in: parentIds } }, { $unset: { hasChildren: '' } }, { multi: 1 });\n\n\t\t\tthis.insert(event);\n\t\t}\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t}\n\n\tasync getEventById(contextQuery, eventId) {\n\t\tconst event = await this.model.rawCollection().findOne({ context: contextQuery, _id: eventId });\n\n\t\treturn {\n\t\t\tsuccess: !!event,\n\t\t\tevent,\n\t\t};\n\t}\n\n\tasync getLatestEvents(contextQuery, fromTimestamp) {\n\t\treturn this.model\n\t\t\t.rawCollection()\n\t\t\t.find({ context: contextQuery, timestamp: { $gt: new Date(fromTimestamp) } })\n\t\t\t.toArray();\n\t}\n\n\tasync removeContextEvents(contextQuery) {\n\t\treturn this.model.rawCollection().remove({ context: contextQuery });\n\t}\n}\n"]},"sourceType":"module","hash":"76b5f1733434ae658b504dc610b8893309ac3880"}
