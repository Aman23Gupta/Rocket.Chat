{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/federation/server/endpoints/dispatch.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/federation/server/endpoints/dispatch.js","filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/federation/server/endpoints/dispatch.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","root":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/federation/server/endpoints/dispatch.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/federation/server/endpoints/dispatch.js"}},"code":"let EJSON;\nmodule.link(\"meteor/ejson\", {\n  EJSON(v) {\n    EJSON = v;\n  }\n\n}, 0);\nlet API;\nmodule.link(\"../../../api/server\", {\n  API(v) {\n    API = v;\n  }\n\n}, 1);\nlet serverLogger;\nmodule.link(\"../lib/logger\", {\n  serverLogger(v) {\n    serverLogger = v;\n  }\n\n}, 2);\nlet contextDefinitions, eventTypes;\nmodule.link(\"../../../models/server/models/FederationEvents\", {\n  contextDefinitions(v) {\n    contextDefinitions = v;\n  },\n\n  eventTypes(v) {\n    eventTypes = v;\n  }\n\n}, 3);\nlet FederationRoomEvents, Messages, Rooms, Subscriptions, Users;\nmodule.link(\"../../../models/server\", {\n  FederationRoomEvents(v) {\n    FederationRoomEvents = v;\n  },\n\n  Messages(v) {\n    Messages = v;\n  },\n\n  Rooms(v) {\n    Rooms = v;\n  },\n\n  Subscriptions(v) {\n    Subscriptions = v;\n  },\n\n  Users(v) {\n    Users = v;\n  }\n\n}, 4);\nlet FederationServers;\nmodule.link(\"../../../models/server/raw\", {\n  FederationServers(v) {\n    FederationServers = v;\n  }\n\n}, 5);\nlet normalizers;\nmodule.link(\"../normalizers\", {\n  normalizers(v) {\n    normalizers = v;\n  }\n\n}, 6);\nlet deleteRoom;\nmodule.link(\"../../../lib/server/functions\", {\n  deleteRoom(v) {\n    deleteRoom = v;\n  }\n\n}, 7);\nlet Notifications;\nmodule.link(\"../../../notifications/server\", {\n  Notifications(v) {\n    Notifications = v;\n  }\n\n}, 8);\nlet FileUpload;\nmodule.link(\"../../../file-upload\", {\n  FileUpload(v) {\n    FileUpload = v;\n  }\n\n}, 9);\nlet getFederationDomain;\nmodule.link(\"../lib/getFederationDomain\", {\n  getFederationDomain(v) {\n    getFederationDomain = v;\n  }\n\n}, 10);\nlet decryptIfNeeded;\nmodule.link(\"../lib/crypt\", {\n  decryptIfNeeded(v) {\n    decryptIfNeeded = v;\n  }\n\n}, 11);\nlet isFederationEnabled;\nmodule.link(\"../lib/isFederationEnabled\", {\n  isFederationEnabled(v) {\n    isFederationEnabled = v;\n  }\n\n}, 12);\nlet getUpload, requestEventsFromLatest;\nmodule.link(\"../handler\", {\n  getUpload(v) {\n    getUpload = v;\n  },\n\n  requestEventsFromLatest(v) {\n    requestEventsFromLatest = v;\n  }\n\n}, 13);\nlet notifyUsersOnMessage;\nmodule.link(\"../../../lib/server/lib/notifyUsersOnMessage\", {\n  notifyUsersOnMessage(v) {\n    notifyUsersOnMessage = v;\n  }\n\n}, 14);\nlet sendAllNotifications;\nmodule.link(\"../../../lib/server/lib/sendNotificationsOnMessage\", {\n  sendAllNotifications(v) {\n    sendAllNotifications = v;\n  }\n\n}, 15);\nlet processThreads;\nmodule.link(\"../../../threads/server/hooks/aftersavemessage\", {\n  processThreads(v) {\n    processThreads = v;\n  }\n\n}, 16);\nconst eventHandlers = {\n  //\n  // PING\n  //\n  [eventTypes.PING]() {\n    return Promise.asyncApply(() => {\n      return {\n        success: true\n      };\n    });\n  },\n\n  //\n  // GENESIS\n  //\n  [eventTypes.GENESIS](event) {\n    return Promise.asyncApply(() => {\n      switch (event.data.contextType) {\n        case contextDefinitions.ROOM.type:\n          const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n          if (eventResult.success) {\n            const {\n              data: {\n                room\n              }\n            } = event; // Check if room exists\n\n            const persistedRoom = Rooms.findOne({\n              _id: room._id\n            });\n\n            if (persistedRoom) {\n              // Update the federation\n              Rooms.update({\n                _id: persistedRoom._id\n              }, {\n                $set: {\n                  federation: room.federation\n                }\n              });\n            } else {\n              // Denormalize room\n              const denormalizedRoom = normalizers.denormalizeRoom(room); // Create the room\n\n              Rooms.insert(denormalizedRoom);\n            }\n          }\n\n          return eventResult;\n      }\n    });\n  },\n\n  //\n  // ROOM_DELETE\n  //\n  [eventTypes.ROOM_DELETE](event) {\n    return Promise.asyncApply(() => {\n      const {\n        data: {\n          roomId\n        }\n      } = event; // Check if room exists\n\n      const persistedRoom = Rooms.findOne({\n        _id: roomId\n      });\n\n      if (persistedRoom) {\n        // Delete the room\n        deleteRoom(roomId);\n      } // Remove all room events\n\n\n      Promise.await(FederationRoomEvents.removeRoomEvents(roomId));\n      return {\n        success: true\n      };\n    });\n  },\n\n  //\n  // ROOM_ADD_USER\n  //\n  [eventTypes.ROOM_ADD_USER](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // We only want to refresh the server list and update the room federation array if something changed\n\n      let federationAltered = false; // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            roomId,\n            user,\n            subscription,\n            domainsAfterAdd\n          }\n        } = event; // Check if user exists\n\n        const persistedUser = Users.findOne({\n          _id: user._id\n        });\n\n        if (persistedUser) {\n          // Update the federation, if its not already set (if it's set, this is likely an event being reprocessed)\n          if (!persistedUser.federation) {\n            Users.update({\n              _id: persistedUser._id\n            }, {\n              $set: {\n                federation: user.federation\n              }\n            });\n            federationAltered = true;\n          }\n        } else {\n          // Denormalize user\n          const denormalizedUser = normalizers.denormalizeUser(user); // Create the user\n\n          Users.insert(denormalizedUser);\n          federationAltered = true;\n        } // Check if subscription exists\n\n\n        const persistedSubscription = Subscriptions.findOne({\n          _id: subscription._id\n        });\n\n        try {\n          if (persistedSubscription) {\n            // Update the federation, if its not already set (if it's set, this is likely an event being reprocessed\n            if (!persistedSubscription.federation) {\n              Subscriptions.update({\n                _id: persistedSubscription._id\n              }, {\n                $set: {\n                  federation: subscription.federation\n                }\n              });\n              federationAltered = true;\n            }\n          } else {\n            // Denormalize subscription\n            const denormalizedSubscription = normalizers.denormalizeSubscription(subscription); // Create the subscription\n\n            Subscriptions.insert(denormalizedSubscription);\n            federationAltered = true;\n          }\n        } catch (ex) {\n          serverLogger.debug(\"unable to create subscription for user ( \".concat(user._id, \" ) in room (\").concat(roomId, \")\"));\n        } // Refresh the servers list\n\n\n        if (federationAltered) {\n          Promise.await(FederationServers.refreshServers()); // Update the room's federation property\n\n          Rooms.update({\n            _id: roomId\n          }, {\n            $set: {\n              'federation.domains': domainsAfterAdd\n            }\n          });\n        }\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_REMOVE_USER\n  //\n  [eventTypes.ROOM_REMOVE_USER](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            roomId,\n            user,\n            domainsAfterRemoval\n          }\n        } = event; // Remove the user's subscription\n\n        Subscriptions.removeByRoomIdAndUserId(roomId, user._id); // Refresh the servers list\n\n        Promise.await(FederationServers.refreshServers()); // Update the room's federation property\n\n        Rooms.update({\n          _id: roomId\n        }, {\n          $set: {\n            'federation.domains': domainsAfterRemoval\n          }\n        });\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_USER_LEFT\n  //\n  [eventTypes.ROOM_USER_LEFT](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            roomId,\n            user,\n            domainsAfterRemoval\n          }\n        } = event; // Remove the user's subscription\n\n        Subscriptions.removeByRoomIdAndUserId(roomId, user._id); // Refresh the servers list\n\n        Promise.await(FederationServers.refreshServers()); // Update the room's federation property\n\n        Rooms.update({\n          _id: roomId\n        }, {\n          $set: {\n            'federation.domains': domainsAfterRemoval\n          }\n        });\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_MESSAGE\n  //\n  [eventTypes.ROOM_MESSAGE](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            message\n          }\n        } = event; // Check if message exists\n\n        const persistedMessage = Messages.findOne({\n          _id: message._id\n        });\n\n        if (persistedMessage) {\n          // Update the federation\n          if (!persistedMessage.federation) {\n            Messages.update({\n              _id: persistedMessage._id\n            }, {\n              $set: {\n                federation: message.federation\n              }\n            });\n          }\n        } else {\n          // Load the room\n          const room = Rooms.findOneById(message.rid); // Denormalize message\n\n          const denormalizedMessage = normalizers.denormalizeMessage(message); // Is there a file?\n\n          if (denormalizedMessage.file) {\n            const fileStore = FileUpload.getStore('Uploads');\n            const {\n              federation: {\n                origin\n              }\n            } = denormalizedMessage;\n            const {\n              upload,\n              buffer\n            } = Promise.await(getUpload(origin, denormalizedMessage.file._id));\n            const oldUploadId = upload._id; // Normalize upload\n\n            delete upload._id;\n            upload.rid = denormalizedMessage.rid;\n            upload.userId = denormalizedMessage.u._id;\n            upload.federation = {\n              _id: denormalizedMessage.file._id,\n              origin\n            };\n            fileStore.insertSync(upload, buffer); // Update the message's file\n\n            denormalizedMessage.file._id = upload._id; // Update the message's attachments dependent on type\n\n            for (const attachment of denormalizedMessage.attachments) {\n              attachment.title_link = attachment.title_link.replace(oldUploadId, upload._id);\n\n              if (/^image\\/.+/.test(denormalizedMessage.file.type)) {\n                attachment.image_url = attachment.image_url.replace(oldUploadId, upload._id);\n              } else if (/^audio\\/.+/.test(denormalizedMessage.file.type)) {\n                attachment.audio_url = attachment.audio_url.replace(oldUploadId, upload._id);\n              } else if (/^video\\/.+/.test(denormalizedMessage.file.type)) {\n                attachment.video_url = attachment.video_url.replace(oldUploadId, upload._id);\n              }\n            }\n          } // Create the message\n\n\n          try {\n            Messages.insert(denormalizedMessage);\n            processThreads(denormalizedMessage, room); // Notify users\n\n            notifyUsersOnMessage(denormalizedMessage, room);\n            sendAllNotifications(denormalizedMessage, room);\n          } catch (err) {\n            serverLogger.debug(\"Error on creating message: \".concat(message._id));\n          }\n        }\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_EDIT_MESSAGE\n  //\n  [eventTypes.ROOM_EDIT_MESSAGE](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            message\n          }\n        } = event; // Check if message exists\n\n        const persistedMessage = Messages.findOne({\n          _id: message._id\n        });\n\n        if (!persistedMessage) {\n          eventResult.success = false;\n          eventResult.reason = 'missingMessageToEdit';\n        } else {\n          // Update the message\n          Messages.update({\n            _id: persistedMessage._id\n          }, {\n            $set: {\n              msg: message.msg,\n              federation: message.federation\n            }\n          });\n        }\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_DELETE_MESSAGE\n  //\n  [eventTypes.ROOM_DELETE_MESSAGE](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            roomId,\n            messageId\n          }\n        } = event; // Remove the message\n\n        Messages.removeById(messageId); // Notify the room\n\n        Notifications.notifyRoom(roomId, 'deleteMessage', {\n          _id: messageId\n        });\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_SET_MESSAGE_REACTION\n  //\n  [eventTypes.ROOM_SET_MESSAGE_REACTION](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            messageId,\n            username,\n            reaction\n          }\n        } = event; // Get persisted message\n\n        const persistedMessage = Messages.findOne({\n          _id: messageId\n        }); // Make sure reactions exist\n\n        persistedMessage.reactions = persistedMessage.reactions || {};\n        let reactionObj = persistedMessage.reactions[reaction]; // If there are no reactions of that type, add it\n\n        if (!reactionObj) {\n          reactionObj = {\n            usernames: [username]\n          };\n        } else {\n          // Otherwise, add the username\n          reactionObj.usernames.push(username);\n          reactionObj.usernames = [...new Set(reactionObj.usernames)];\n        } // Update the property\n\n\n        Messages.update({\n          _id: messageId\n        }, {\n          $set: {\n            [\"reactions.\".concat(reaction)]: reactionObj\n          }\n        });\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_UNSET_MESSAGE_REACTION\n  //\n  [eventTypes.ROOM_UNSET_MESSAGE_REACTION](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            messageId,\n            username,\n            reaction\n          }\n        } = event; // Get persisted message\n\n        const persistedMessage = Messages.findOne({\n          _id: messageId\n        }); // Make sure reactions exist\n\n        persistedMessage.reactions = persistedMessage.reactions || {}; // If there are no reactions of that type, ignore\n\n        if (!persistedMessage.reactions[reaction]) {\n          return eventResult;\n        }\n\n        const reactionObj = persistedMessage.reactions[reaction]; // Get the username index on the list\n\n        const usernameIdx = reactionObj.usernames.indexOf(username); // If the index is not found, ignore\n\n        if (usernameIdx === -1) {\n          return eventResult;\n        } // Remove the username from the given reaction\n\n\n        reactionObj.usernames.splice(usernameIdx, 1); // If there are no more users for that reaction, remove the property\n\n        if (reactionObj.usernames.length === 0) {\n          Messages.update({\n            _id: messageId\n          }, {\n            $unset: {\n              [\"reactions.\".concat(reaction)]: 1\n            }\n          });\n        } else {\n          // Otherwise, update the property\n          Messages.update({\n            _id: messageId\n          }, {\n            $set: {\n              [\"reactions.\".concat(reaction)]: reactionObj\n            }\n          });\n        }\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_MUTE_USER\n  //\n  [eventTypes.ROOM_MUTE_USER](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            roomId,\n            user\n          }\n        } = event; // Denormalize user\n\n        const denormalizedUser = normalizers.denormalizeUser(user); // Mute user\n\n        Rooms.muteUsernameByRoomId(roomId, denormalizedUser.username);\n      }\n\n      return eventResult;\n    });\n  },\n\n  //\n  // ROOM_UNMUTE_USER\n  //\n  [eventTypes.ROOM_UNMUTE_USER](event) {\n    return Promise.asyncApply(() => {\n      const eventResult = Promise.await(FederationRoomEvents.addEvent(event.context, event)); // If the event was successfully added, handle the event locally\n\n      if (eventResult.success) {\n        const {\n          data: {\n            roomId,\n            user\n          }\n        } = event; // Denormalize user\n\n        const denormalizedUser = normalizers.denormalizeUser(user); // Mute user\n\n        Rooms.unmuteUsernameByRoomId(roomId, denormalizedUser.username);\n      }\n\n      return eventResult;\n    });\n  }\n\n};\nAPI.v1.addRoute('federation.events.dispatch', {\n  authRequired: false,\n  rateLimiterOptions: {\n    numRequestsAllowed: 30,\n    intervalTimeInMS: 1000\n  }\n}, {\n  post() {\n    if (!isFederationEnabled()) {\n      return API.v1.failure('Federation not enabled');\n    } //\n    // Decrypt the payload if needed\n\n\n    let payload;\n\n    try {\n      payload = Promise.await(decryptIfNeeded(this.request, this.bodyParams));\n    } catch (err) {\n      return API.v1.failure('Could not decrypt payload');\n    } //\n    // Convert from EJSON\n\n\n    const {\n      events\n    } = EJSON.fromJSONValue(payload);\n    serverLogger.debug({\n      msg: 'federation.events.dispatch',\n      events\n    }); // Loop over received events\n\n    for (const event of events) {\n      /* eslint-disable no-await-in-loop */\n      let eventResult;\n\n      if (eventHandlers[event.type]) {\n        eventResult = Promise.await(eventHandlers[event.type](event));\n      } // If there was an error handling the event, take action\n\n\n      if (!eventResult || !eventResult.success) {\n        try {\n          serverLogger.debug({\n            msg: 'federation.events.dispatch => Event has missing parents',\n            event\n          });\n          Promise.await(requestEventsFromLatest(event.origin, getFederationDomain(), contextDefinitions.defineType(event), event.context, eventResult.latestEventIds)); // And stop handling the events\n\n          break;\n        } catch (err) {\n          serverLogger.error({\n            msg: 'dispatch',\n            event,\n            eventResult,\n            err\n          });\n          throw err;\n        }\n      }\n      /* eslint-enable no-await-in-loop */\n\n    } // Respond\n\n\n    return API.v1.success();\n  }\n\n});","map":{"version":3,"sources":["app/federation/server/endpoints/dispatch.js"],"names":["EJSON","module","link","v","API","serverLogger","contextDefinitions","eventTypes","FederationRoomEvents","Messages","Rooms","Subscriptions","Users","FederationServers","normalizers","deleteRoom","Notifications","FileUpload","getFederationDomain","decryptIfNeeded","isFederationEnabled","getUpload","requestEventsFromLatest","notifyUsersOnMessage","sendAllNotifications","processThreads","eventHandlers","PING","success","GENESIS","event","data","contextType","ROOM","type","eventResult","addEvent","context","room","persistedRoom","findOne","_id","update","$set","federation","denormalizedRoom","denormalizeRoom","insert","ROOM_DELETE","roomId","removeRoomEvents","ROOM_ADD_USER","federationAltered","user","subscription","domainsAfterAdd","persistedUser","denormalizedUser","denormalizeUser","persistedSubscription","denormalizedSubscription","denormalizeSubscription","ex","debug","refreshServers","ROOM_REMOVE_USER","domainsAfterRemoval","removeByRoomIdAndUserId","ROOM_USER_LEFT","ROOM_MESSAGE","message","persistedMessage","findOneById","rid","denormalizedMessage","denormalizeMessage","file","fileStore","getStore","origin","upload","buffer","oldUploadId","userId","u","insertSync","attachment","attachments","title_link","replace","test","image_url","audio_url","video_url","err","ROOM_EDIT_MESSAGE","reason","msg","ROOM_DELETE_MESSAGE","messageId","removeById","notifyRoom","ROOM_SET_MESSAGE_REACTION","username","reaction","reactions","reactionObj","usernames","push","Set","ROOM_UNSET_MESSAGE_REACTION","usernameIdx","indexOf","splice","length","$unset","ROOM_MUTE_USER","muteUsernameByRoomId","ROOM_UNMUTE_USER","unmuteUsernameByRoomId","v1","addRoute","authRequired","rateLimiterOptions","numRequestsAllowed","intervalTimeInMS","post","failure","payload","Promise","await","request","bodyParams","events","fromJSONValue","defineType","latestEventIds","error"],"mappings":"AAAA,IAAIA,KAAJ;AAAUC,MAAM,CAACC,IAAP,CAAY,cAAZ,EAA2B;AAACF,EAAAA,KAAK,CAACG,CAAD,EAAG;AAACH,IAAAA,KAAK,GAACG,CAAN;AAAQ;;AAAlB,CAA3B,EAA+C,CAA/C;AAAkD,IAAIC,GAAJ;AAAQH,MAAM,CAACC,IAAP,CAAY,qBAAZ,EAAkC;AAACE,EAAAA,GAAG,CAACD,CAAD,EAAG;AAACC,IAAAA,GAAG,GAACD,CAAJ;AAAM;;AAAd,CAAlC,EAAkD,CAAlD;AAAqD,IAAIE,YAAJ;AAAiBJ,MAAM,CAACC,IAAP,CAAY,eAAZ,EAA4B;AAACG,EAAAA,YAAY,CAACF,CAAD,EAAG;AAACE,IAAAA,YAAY,GAACF,CAAb;AAAe;;AAAhC,CAA5B,EAA8D,CAA9D;AAAiE,IAAIG,kBAAJ,EAAuBC,UAAvB;AAAkCN,MAAM,CAACC,IAAP,CAAY,gDAAZ,EAA6D;AAACI,EAAAA,kBAAkB,CAACH,CAAD,EAAG;AAACG,IAAAA,kBAAkB,GAACH,CAAnB;AAAqB,GAA5C;;AAA6CI,EAAAA,UAAU,CAACJ,CAAD,EAAG;AAACI,IAAAA,UAAU,GAACJ,CAAX;AAAa;;AAAxE,CAA7D,EAAuI,CAAvI;AAA0I,IAAIK,oBAAJ,EAAyBC,QAAzB,EAAkCC,KAAlC,EAAwCC,aAAxC,EAAsDC,KAAtD;AAA4DX,MAAM,CAACC,IAAP,CAAY,wBAAZ,EAAqC;AAACM,EAAAA,oBAAoB,CAACL,CAAD,EAAG;AAACK,IAAAA,oBAAoB,GAACL,CAArB;AAAuB,GAAhD;;AAAiDM,EAAAA,QAAQ,CAACN,CAAD,EAAG;AAACM,IAAAA,QAAQ,GAACN,CAAT;AAAW,GAAxE;;AAAyEO,EAAAA,KAAK,CAACP,CAAD,EAAG;AAACO,IAAAA,KAAK,GAACP,CAAN;AAAQ,GAA1F;;AAA2FQ,EAAAA,aAAa,CAACR,CAAD,EAAG;AAACQ,IAAAA,aAAa,GAACR,CAAd;AAAgB,GAA5H;;AAA6HS,EAAAA,KAAK,CAACT,CAAD,EAAG;AAACS,IAAAA,KAAK,GAACT,CAAN;AAAQ;;AAA9I,CAArC,EAAqL,CAArL;AAAwL,IAAIU,iBAAJ;AAAsBZ,MAAM,CAACC,IAAP,CAAY,4BAAZ,EAAyC;AAACW,EAAAA,iBAAiB,CAACV,CAAD,EAAG;AAACU,IAAAA,iBAAiB,GAACV,CAAlB;AAAoB;;AAA1C,CAAzC,EAAqF,CAArF;AAAwF,IAAIW,WAAJ;AAAgBb,MAAM,CAACC,IAAP,CAAY,gBAAZ,EAA6B;AAACY,EAAAA,WAAW,CAACX,CAAD,EAAG;AAACW,IAAAA,WAAW,GAACX,CAAZ;AAAc;;AAA9B,CAA7B,EAA6D,CAA7D;AAAgE,IAAIY,UAAJ;AAAed,MAAM,CAACC,IAAP,CAAY,+BAAZ,EAA4C;AAACa,EAAAA,UAAU,CAACZ,CAAD,EAAG;AAACY,IAAAA,UAAU,GAACZ,CAAX;AAAa;;AAA5B,CAA5C,EAA0E,CAA1E;AAA6E,IAAIa,aAAJ;AAAkBf,MAAM,CAACC,IAAP,CAAY,+BAAZ,EAA4C;AAACc,EAAAA,aAAa,CAACb,CAAD,EAAG;AAACa,IAAAA,aAAa,GAACb,CAAd;AAAgB;;AAAlC,CAA5C,EAAgF,CAAhF;AAAmF,IAAIc,UAAJ;AAAehB,MAAM,CAACC,IAAP,CAAY,sBAAZ,EAAmC;AAACe,EAAAA,UAAU,CAACd,CAAD,EAAG;AAACc,IAAAA,UAAU,GAACd,CAAX;AAAa;;AAA5B,CAAnC,EAAiE,CAAjE;AAAoE,IAAIe,mBAAJ;AAAwBjB,MAAM,CAACC,IAAP,CAAY,4BAAZ,EAAyC;AAACgB,EAAAA,mBAAmB,CAACf,CAAD,EAAG;AAACe,IAAAA,mBAAmB,GAACf,CAApB;AAAsB;;AAA9C,CAAzC,EAAyF,EAAzF;AAA6F,IAAIgB,eAAJ;AAAoBlB,MAAM,CAACC,IAAP,CAAY,cAAZ,EAA2B;AAACiB,EAAAA,eAAe,CAAChB,CAAD,EAAG;AAACgB,IAAAA,eAAe,GAAChB,CAAhB;AAAkB;;AAAtC,CAA3B,EAAmE,EAAnE;AAAuE,IAAIiB,mBAAJ;AAAwBnB,MAAM,CAACC,IAAP,CAAY,4BAAZ,EAAyC;AAACkB,EAAAA,mBAAmB,CAACjB,CAAD,EAAG;AAACiB,IAAAA,mBAAmB,GAACjB,CAApB;AAAsB;;AAA9C,CAAzC,EAAyF,EAAzF;AAA6F,IAAIkB,SAAJ,EAAcC,uBAAd;AAAsCrB,MAAM,CAACC,IAAP,CAAY,YAAZ,EAAyB;AAACmB,EAAAA,SAAS,CAAClB,CAAD,EAAG;AAACkB,IAAAA,SAAS,GAAClB,CAAV;AAAY,GAA1B;;AAA2BmB,EAAAA,uBAAuB,CAACnB,CAAD,EAAG;AAACmB,IAAAA,uBAAuB,GAACnB,CAAxB;AAA0B;;AAAhF,CAAzB,EAA2G,EAA3G;AAA+G,IAAIoB,oBAAJ;AAAyBtB,MAAM,CAACC,IAAP,CAAY,8CAAZ,EAA2D;AAACqB,EAAAA,oBAAoB,CAACpB,CAAD,EAAG;AAACoB,IAAAA,oBAAoB,GAACpB,CAArB;AAAuB;;AAAhD,CAA3D,EAA6G,EAA7G;AAAiH,IAAIqB,oBAAJ;AAAyBvB,MAAM,CAACC,IAAP,CAAY,oDAAZ,EAAiE;AAACsB,EAAAA,oBAAoB,CAACrB,CAAD,EAAG;AAACqB,IAAAA,oBAAoB,GAACrB,CAArB;AAAuB;;AAAhD,CAAjE,EAAmH,EAAnH;AAAuH,IAAIsB,cAAJ;AAAmBxB,MAAM,CAACC,IAAP,CAAY,gDAAZ,EAA6D;AAACuB,EAAAA,cAAc,CAACtB,CAAD,EAAG;AAACsB,IAAAA,cAAc,GAACtB,CAAf;AAAiB;;AAApC,CAA7D,EAAmG,EAAnG;AAmBp0D,MAAMuB,aAAa,GAAG;AACrB;AACA;AACA;AACA,GAAOnB,UAAU,CAACoB,IAAlB;AAAA,oCAA0B;AACzB,aAAO;AACNC,QAAAA,OAAO,EAAE;AADH,OAAP;AAGA,KAJD;AAAA,GAJqB;;AAUrB;AACA;AACA;AACA,GAAOrB,UAAU,CAACsB,OAAlB,EAA2BC,KAA3B;AAAA,oCAAkC;AACjC,cAAQA,KAAK,CAACC,IAAN,CAAWC,WAAnB;AACC,aAAK1B,kBAAkB,CAAC2B,IAAnB,CAAwBC,IAA7B;AACC,gBAAMC,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CADD,CAGC;;AACA,cAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,kBAAM;AACLG,cAAAA,IAAI,EAAE;AAAEO,gBAAAA;AAAF;AADD,gBAEFR,KAFJ,CADwB,CAKxB;;AACA,kBAAMS,aAAa,GAAG7B,KAAK,CAAC8B,OAAN,CAAc;AAAEC,cAAAA,GAAG,EAAEH,IAAI,CAACG;AAAZ,aAAd,CAAtB;;AAEA,gBAAIF,aAAJ,EAAmB;AAClB;AACA7B,cAAAA,KAAK,CAACgC,MAAN,CAAa;AAAED,gBAAAA,GAAG,EAAEF,aAAa,CAACE;AAArB,eAAb,EAAyC;AAAEE,gBAAAA,IAAI,EAAE;AAAEC,kBAAAA,UAAU,EAAEN,IAAI,CAACM;AAAnB;AAAR,eAAzC;AACA,aAHD,MAGO;AACN;AACA,oBAAMC,gBAAgB,GAAG/B,WAAW,CAACgC,eAAZ,CAA4BR,IAA5B,CAAzB,CAFM,CAIN;;AACA5B,cAAAA,KAAK,CAACqC,MAAN,CAAaF,gBAAb;AACA;AACD;;AACD,iBAAOV,WAAP;AAxBF;AA0BA,KA3BD;AAAA,GAbqB;;AA0CrB;AACA;AACA;AACA,GAAO5B,UAAU,CAACyC,WAAlB,EAA+BlB,KAA/B;AAAA,oCAAsC;AACrC,YAAM;AACLC,QAAAA,IAAI,EAAE;AAAEkB,UAAAA;AAAF;AADD,UAEFnB,KAFJ,CADqC,CAKrC;;AACA,YAAMS,aAAa,GAAG7B,KAAK,CAAC8B,OAAN,CAAc;AAAEC,QAAAA,GAAG,EAAEQ;AAAP,OAAd,CAAtB;;AAEA,UAAIV,aAAJ,EAAmB;AAClB;AACAxB,QAAAA,UAAU,CAACkC,MAAD,CAAV;AACA,OAXoC,CAarC;;;AACA,oBAAMzC,oBAAoB,CAAC0C,gBAArB,CAAsCD,MAAtC,CAAN;AAEA,aAAO;AACNrB,QAAAA,OAAO,EAAE;AADH,OAAP;AAGA,KAnBD;AAAA,GA7CqB;;AAkErB;AACA;AACA;AACA,GAAOrB,UAAU,CAAC4C,aAAlB,EAAiCrB,KAAjC;AAAA,oCAAwC;AACvC,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CADuC,CAGvC;;AACA,UAAIsB,iBAAiB,GAAG,KAAxB,CAJuC,CAMvC;;AACA,UAAIjB,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEkB,YAAAA,MAAF;AAAUI,YAAAA,IAAV;AAAgBC,YAAAA,YAAhB;AAA8BC,YAAAA;AAA9B;AADD,YAEFzB,KAFJ,CADwB,CAKxB;;AACA,cAAM0B,aAAa,GAAG5C,KAAK,CAAC4B,OAAN,CAAc;AAAEC,UAAAA,GAAG,EAAEY,IAAI,CAACZ;AAAZ,SAAd,CAAtB;;AAEA,YAAIe,aAAJ,EAAmB;AAClB;AACA,cAAI,CAACA,aAAa,CAACZ,UAAnB,EAA+B;AAC9BhC,YAAAA,KAAK,CAAC8B,MAAN,CAAa;AAAED,cAAAA,GAAG,EAAEe,aAAa,CAACf;AAArB,aAAb,EAAyC;AAAEE,cAAAA,IAAI,EAAE;AAAEC,gBAAAA,UAAU,EAAES,IAAI,CAACT;AAAnB;AAAR,aAAzC;AACAQ,YAAAA,iBAAiB,GAAG,IAApB;AACA;AACD,SAND,MAMO;AACN;AACA,gBAAMK,gBAAgB,GAAG3C,WAAW,CAAC4C,eAAZ,CAA4BL,IAA5B,CAAzB,CAFM,CAIN;;AACAzC,UAAAA,KAAK,CAACmC,MAAN,CAAaU,gBAAb;AACAL,UAAAA,iBAAiB,GAAG,IAApB;AACA,SArBuB,CAuBxB;;;AACA,cAAMO,qBAAqB,GAAGhD,aAAa,CAAC6B,OAAd,CAAsB;AAAEC,UAAAA,GAAG,EAAEa,YAAY,CAACb;AAApB,SAAtB,CAA9B;;AAEA,YAAI;AACH,cAAIkB,qBAAJ,EAA2B;AAC1B;AACA,gBAAI,CAACA,qBAAqB,CAACf,UAA3B,EAAuC;AACtCjC,cAAAA,aAAa,CAAC+B,MAAd,CAAqB;AAAED,gBAAAA,GAAG,EAAEkB,qBAAqB,CAAClB;AAA7B,eAArB,EAAyD;AAAEE,gBAAAA,IAAI,EAAE;AAAEC,kBAAAA,UAAU,EAAEU,YAAY,CAACV;AAA3B;AAAR,eAAzD;AACAQ,cAAAA,iBAAiB,GAAG,IAApB;AACA;AACD,WAND,MAMO;AACN;AACA,kBAAMQ,wBAAwB,GAAG9C,WAAW,CAAC+C,uBAAZ,CAAoCP,YAApC,CAAjC,CAFM,CAIN;;AACA3C,YAAAA,aAAa,CAACoC,MAAd,CAAqBa,wBAArB;AACAR,YAAAA,iBAAiB,GAAG,IAApB;AACA;AACD,SAfD,CAeE,OAAOU,EAAP,EAAW;AACZzD,UAAAA,YAAY,CAAC0D,KAAb,oDAA+DV,IAAI,CAACZ,GAApE,yBAAsFQ,MAAtF;AACA,SA3CuB,CA6CxB;;;AACA,YAAIG,iBAAJ,EAAuB;AACtB,wBAAMvC,iBAAiB,CAACmD,cAAlB,EAAN,EADsB,CAGtB;;AACAtD,UAAAA,KAAK,CAACgC,MAAN,CAAa;AAAED,YAAAA,GAAG,EAAEQ;AAAP,WAAb,EAA8B;AAAEN,YAAAA,IAAI,EAAE;AAAE,oCAAsBY;AAAxB;AAAR,WAA9B;AACA;AACD;;AAED,aAAOpB,WAAP;AACA,KA9DD;AAAA,GArEqB;;AAqIrB;AACA;AACA;AACA,GAAO5B,UAAU,CAAC0D,gBAAlB,EAAoCnC,KAApC;AAAA,oCAA2C;AAC1C,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CAD0C,CAG1C;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEkB,YAAAA,MAAF;AAAUI,YAAAA,IAAV;AAAgBa,YAAAA;AAAhB;AADD,YAEFpC,KAFJ,CADwB,CAKxB;;AACAnB,QAAAA,aAAa,CAACwD,uBAAd,CAAsClB,MAAtC,EAA8CI,IAAI,CAACZ,GAAnD,EANwB,CAQxB;;AACA,sBAAM5B,iBAAiB,CAACmD,cAAlB,EAAN,EATwB,CAWxB;;AACAtD,QAAAA,KAAK,CAACgC,MAAN,CAAa;AAAED,UAAAA,GAAG,EAAEQ;AAAP,SAAb,EAA8B;AAAEN,UAAAA,IAAI,EAAE;AAAE,kCAAsBuB;AAAxB;AAAR,SAA9B;AACA;;AAED,aAAO/B,WAAP;AACA,KApBD;AAAA,GAxIqB;;AA8JrB;AACA;AACA;AACA,GAAO5B,UAAU,CAAC6D,cAAlB,EAAkCtC,KAAlC;AAAA,oCAAyC;AACxC,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CADwC,CAGxC;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEkB,YAAAA,MAAF;AAAUI,YAAAA,IAAV;AAAgBa,YAAAA;AAAhB;AADD,YAEFpC,KAFJ,CADwB,CAKxB;;AACAnB,QAAAA,aAAa,CAACwD,uBAAd,CAAsClB,MAAtC,EAA8CI,IAAI,CAACZ,GAAnD,EANwB,CAQxB;;AACA,sBAAM5B,iBAAiB,CAACmD,cAAlB,EAAN,EATwB,CAWxB;;AACAtD,QAAAA,KAAK,CAACgC,MAAN,CAAa;AAAED,UAAAA,GAAG,EAAEQ;AAAP,SAAb,EAA8B;AAAEN,UAAAA,IAAI,EAAE;AAAE,kCAAsBuB;AAAxB;AAAR,SAA9B;AACA;;AAED,aAAO/B,WAAP;AACA,KApBD;AAAA,GAjKqB;;AAuLrB;AACA;AACA;AACA,GAAO5B,UAAU,CAAC8D,YAAlB,EAAgCvC,KAAhC;AAAA,oCAAuC;AACtC,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CADsC,CAGtC;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEuC,YAAAA;AAAF;AADD,YAEFxC,KAFJ,CADwB,CAKxB;;AACA,cAAMyC,gBAAgB,GAAG9D,QAAQ,CAAC+B,OAAT,CAAiB;AAAEC,UAAAA,GAAG,EAAE6B,OAAO,CAAC7B;AAAf,SAAjB,CAAzB;;AAEA,YAAI8B,gBAAJ,EAAsB;AACrB;AACA,cAAI,CAACA,gBAAgB,CAAC3B,UAAtB,EAAkC;AACjCnC,YAAAA,QAAQ,CAACiC,MAAT,CAAgB;AAAED,cAAAA,GAAG,EAAE8B,gBAAgB,CAAC9B;AAAxB,aAAhB,EAA+C;AAAEE,cAAAA,IAAI,EAAE;AAAEC,gBAAAA,UAAU,EAAE0B,OAAO,CAAC1B;AAAtB;AAAR,aAA/C;AACA;AACD,SALD,MAKO;AACN;AACA,gBAAMN,IAAI,GAAG5B,KAAK,CAAC8D,WAAN,CAAkBF,OAAO,CAACG,GAA1B,CAAb,CAFM,CAIN;;AACA,gBAAMC,mBAAmB,GAAG5D,WAAW,CAAC6D,kBAAZ,CAA+BL,OAA/B,CAA5B,CALM,CAON;;AACA,cAAII,mBAAmB,CAACE,IAAxB,EAA8B;AAC7B,kBAAMC,SAAS,GAAG5D,UAAU,CAAC6D,QAAX,CAAoB,SAApB,CAAlB;AAEA,kBAAM;AACLlC,cAAAA,UAAU,EAAE;AAAEmC,gBAAAA;AAAF;AADP,gBAEFL,mBAFJ;AAIA,kBAAM;AAAEM,cAAAA,MAAF;AAAUC,cAAAA;AAAV,8BAA2B5D,SAAS,CAAC0D,MAAD,EAASL,mBAAmB,CAACE,IAApB,CAAyBnC,GAAlC,CAApC,CAAN;AAEA,kBAAMyC,WAAW,GAAGF,MAAM,CAACvC,GAA3B,CAT6B,CAW7B;;AACA,mBAAOuC,MAAM,CAACvC,GAAd;AACAuC,YAAAA,MAAM,CAACP,GAAP,GAAaC,mBAAmB,CAACD,GAAjC;AACAO,YAAAA,MAAM,CAACG,MAAP,GAAgBT,mBAAmB,CAACU,CAApB,CAAsB3C,GAAtC;AACAuC,YAAAA,MAAM,CAACpC,UAAP,GAAoB;AACnBH,cAAAA,GAAG,EAAEiC,mBAAmB,CAACE,IAApB,CAAyBnC,GADX;AAEnBsC,cAAAA;AAFmB,aAApB;AAKAF,YAAAA,SAAS,CAACQ,UAAV,CAAqBL,MAArB,EAA6BC,MAA7B,EApB6B,CAsB7B;;AACAP,YAAAA,mBAAmB,CAACE,IAApB,CAAyBnC,GAAzB,GAA+BuC,MAAM,CAACvC,GAAtC,CAvB6B,CAyB7B;;AACA,iBAAK,MAAM6C,UAAX,IAAyBZ,mBAAmB,CAACa,WAA7C,EAA0D;AACzDD,cAAAA,UAAU,CAACE,UAAX,GAAwBF,UAAU,CAACE,UAAX,CAAsBC,OAAtB,CAA8BP,WAA9B,EAA2CF,MAAM,CAACvC,GAAlD,CAAxB;;AACA,kBAAI,aAAaiD,IAAb,CAAkBhB,mBAAmB,CAACE,IAApB,CAAyB1C,IAA3C,CAAJ,EAAsD;AACrDoD,gBAAAA,UAAU,CAACK,SAAX,GAAuBL,UAAU,CAACK,SAAX,CAAqBF,OAArB,CAA6BP,WAA7B,EAA0CF,MAAM,CAACvC,GAAjD,CAAvB;AACA,eAFD,MAEO,IAAI,aAAaiD,IAAb,CAAkBhB,mBAAmB,CAACE,IAApB,CAAyB1C,IAA3C,CAAJ,EAAsD;AAC5DoD,gBAAAA,UAAU,CAACM,SAAX,GAAuBN,UAAU,CAACM,SAAX,CAAqBH,OAArB,CAA6BP,WAA7B,EAA0CF,MAAM,CAACvC,GAAjD,CAAvB;AACA,eAFM,MAEA,IAAI,aAAaiD,IAAb,CAAkBhB,mBAAmB,CAACE,IAApB,CAAyB1C,IAA3C,CAAJ,EAAsD;AAC5DoD,gBAAAA,UAAU,CAACO,SAAX,GAAuBP,UAAU,CAACO,SAAX,CAAqBJ,OAArB,CAA6BP,WAA7B,EAA0CF,MAAM,CAACvC,GAAjD,CAAvB;AACA;AACD;AACD,WA5CK,CA8CN;;;AACA,cAAI;AACHhC,YAAAA,QAAQ,CAACsC,MAAT,CAAgB2B,mBAAhB;AAEAjD,YAAAA,cAAc,CAACiD,mBAAD,EAAsBpC,IAAtB,CAAd,CAHG,CAKH;;AACAf,YAAAA,oBAAoB,CAACmD,mBAAD,EAAsBpC,IAAtB,CAApB;AACAd,YAAAA,oBAAoB,CAACkD,mBAAD,EAAsBpC,IAAtB,CAApB;AACA,WARD,CAQE,OAAOwD,GAAP,EAAY;AACbzF,YAAAA,YAAY,CAAC0D,KAAb,sCAAiDO,OAAO,CAAC7B,GAAzD;AACA;AACD;AACD;;AAED,aAAON,WAAP;AACA,KA/ED;AAAA,GA1LqB;;AA2QrB;AACA;AACA;AACA,GAAO5B,UAAU,CAACwF,iBAAlB,EAAqCjE,KAArC;AAAA,oCAA4C;AAC3C,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CAD2C,CAG3C;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEuC,YAAAA;AAAF;AADD,YAEFxC,KAFJ,CADwB,CAKxB;;AACA,cAAMyC,gBAAgB,GAAG9D,QAAQ,CAAC+B,OAAT,CAAiB;AAAEC,UAAAA,GAAG,EAAE6B,OAAO,CAAC7B;AAAf,SAAjB,CAAzB;;AAEA,YAAI,CAAC8B,gBAAL,EAAuB;AACtBpC,UAAAA,WAAW,CAACP,OAAZ,GAAsB,KAAtB;AACAO,UAAAA,WAAW,CAAC6D,MAAZ,GAAqB,sBAArB;AACA,SAHD,MAGO;AACN;AACAvF,UAAAA,QAAQ,CAACiC,MAAT,CAAgB;AAAED,YAAAA,GAAG,EAAE8B,gBAAgB,CAAC9B;AAAxB,WAAhB,EAA+C;AAAEE,YAAAA,IAAI,EAAE;AAAEsD,cAAAA,GAAG,EAAE3B,OAAO,CAAC2B,GAAf;AAAoBrD,cAAAA,UAAU,EAAE0B,OAAO,CAAC1B;AAAxC;AAAR,WAA/C;AACA;AACD;;AAED,aAAOT,WAAP;AACA,KAtBD;AAAA,GA9QqB;;AAsSrB;AACA;AACA;AACA,GAAO5B,UAAU,CAAC2F,mBAAlB,EAAuCpE,KAAvC;AAAA,oCAA8C;AAC7C,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CAD6C,CAG7C;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEkB,YAAAA,MAAF;AAAUkD,YAAAA;AAAV;AADD,YAEFrE,KAFJ,CADwB,CAKxB;;AACArB,QAAAA,QAAQ,CAAC2F,UAAT,CAAoBD,SAApB,EANwB,CAQxB;;AACAnF,QAAAA,aAAa,CAACqF,UAAd,CAAyBpD,MAAzB,EAAiC,eAAjC,EAAkD;AAAER,UAAAA,GAAG,EAAE0D;AAAP,SAAlD;AACA;;AAED,aAAOhE,WAAP;AACA,KAjBD;AAAA,GAzSqB;;AA4TrB;AACA;AACA;AACA,GAAO5B,UAAU,CAAC+F,yBAAlB,EAA6CxE,KAA7C;AAAA,oCAAoD;AACnD,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CADmD,CAGnD;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEoE,YAAAA,SAAF;AAAaI,YAAAA,QAAb;AAAuBC,YAAAA;AAAvB;AADD,YAEF1E,KAFJ,CADwB,CAKxB;;AACA,cAAMyC,gBAAgB,GAAG9D,QAAQ,CAAC+B,OAAT,CAAiB;AAAEC,UAAAA,GAAG,EAAE0D;AAAP,SAAjB,CAAzB,CANwB,CAQxB;;AACA5B,QAAAA,gBAAgB,CAACkC,SAAjB,GAA6BlC,gBAAgB,CAACkC,SAAjB,IAA8B,EAA3D;AAEA,YAAIC,WAAW,GAAGnC,gBAAgB,CAACkC,SAAjB,CAA2BD,QAA3B,CAAlB,CAXwB,CAaxB;;AACA,YAAI,CAACE,WAAL,EAAkB;AACjBA,UAAAA,WAAW,GAAG;AACbC,YAAAA,SAAS,EAAE,CAACJ,QAAD;AADE,WAAd;AAGA,SAJD,MAIO;AACN;AACAG,UAAAA,WAAW,CAACC,SAAZ,CAAsBC,IAAtB,CAA2BL,QAA3B;AACAG,UAAAA,WAAW,CAACC,SAAZ,GAAwB,CAAC,GAAG,IAAIE,GAAJ,CAAQH,WAAW,CAACC,SAApB,CAAJ,CAAxB;AACA,SAtBuB,CAwBxB;;;AACAlG,QAAAA,QAAQ,CAACiC,MAAT,CAAgB;AAAED,UAAAA,GAAG,EAAE0D;AAAP,SAAhB,EAAoC;AAAExD,UAAAA,IAAI,EAAE;AAAE,iCAAc6D,QAAd,IAA2BE;AAA7B;AAAR,SAApC;AACA;;AAED,aAAOvE,WAAP;AACA,KAjCD;AAAA,GA/TqB;;AAkWrB;AACA;AACA;AACA,GAAO5B,UAAU,CAACuG,2BAAlB,EAA+ChF,KAA/C;AAAA,oCAAsD;AACrD,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CADqD,CAGrD;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEoE,YAAAA,SAAF;AAAaI,YAAAA,QAAb;AAAuBC,YAAAA;AAAvB;AADD,YAEF1E,KAFJ,CADwB,CAKxB;;AACA,cAAMyC,gBAAgB,GAAG9D,QAAQ,CAAC+B,OAAT,CAAiB;AAAEC,UAAAA,GAAG,EAAE0D;AAAP,SAAjB,CAAzB,CANwB,CAQxB;;AACA5B,QAAAA,gBAAgB,CAACkC,SAAjB,GAA6BlC,gBAAgB,CAACkC,SAAjB,IAA8B,EAA3D,CATwB,CAWxB;;AACA,YAAI,CAAClC,gBAAgB,CAACkC,SAAjB,CAA2BD,QAA3B,CAAL,EAA2C;AAC1C,iBAAOrE,WAAP;AACA;;AAED,cAAMuE,WAAW,GAAGnC,gBAAgB,CAACkC,SAAjB,CAA2BD,QAA3B,CAApB,CAhBwB,CAkBxB;;AACA,cAAMO,WAAW,GAAGL,WAAW,CAACC,SAAZ,CAAsBK,OAAtB,CAA8BT,QAA9B,CAApB,CAnBwB,CAqBxB;;AACA,YAAIQ,WAAW,KAAK,CAAC,CAArB,EAAwB;AACvB,iBAAO5E,WAAP;AACA,SAxBuB,CA0BxB;;;AACAuE,QAAAA,WAAW,CAACC,SAAZ,CAAsBM,MAAtB,CAA6BF,WAA7B,EAA0C,CAA1C,EA3BwB,CA6BxB;;AACA,YAAIL,WAAW,CAACC,SAAZ,CAAsBO,MAAtB,KAAiC,CAArC,EAAwC;AACvCzG,UAAAA,QAAQ,CAACiC,MAAT,CAAgB;AAAED,YAAAA,GAAG,EAAE0D;AAAP,WAAhB,EAAoC;AAAEgB,YAAAA,MAAM,EAAE;AAAE,mCAAcX,QAAd,IAA2B;AAA7B;AAAV,WAApC;AACA,SAFD,MAEO;AACN;AACA/F,UAAAA,QAAQ,CAACiC,MAAT,CAAgB;AAAED,YAAAA,GAAG,EAAE0D;AAAP,WAAhB,EAAoC;AAAExD,YAAAA,IAAI,EAAE;AAAE,mCAAc6D,QAAd,IAA2BE;AAA7B;AAAR,WAApC;AACA;AACD;;AAED,aAAOvE,WAAP;AACA,KA3CD;AAAA,GArWqB;;AAkZrB;AACA;AACA;AACA,GAAO5B,UAAU,CAAC6G,cAAlB,EAAkCtF,KAAlC;AAAA,oCAAyC;AACxC,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CADwC,CAGxC;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEkB,YAAAA,MAAF;AAAUI,YAAAA;AAAV;AADD,YAEFvB,KAFJ,CADwB,CAKxB;;AACA,cAAM2B,gBAAgB,GAAG3C,WAAW,CAAC4C,eAAZ,CAA4BL,IAA5B,CAAzB,CANwB,CAQxB;;AACA3C,QAAAA,KAAK,CAAC2G,oBAAN,CAA2BpE,MAA3B,EAAmCQ,gBAAgB,CAAC8C,QAApD;AACA;;AAED,aAAOpE,WAAP;AACA,KAjBD;AAAA,GArZqB;;AAwarB;AACA;AACA;AACA,GAAO5B,UAAU,CAAC+G,gBAAlB,EAAoCxF,KAApC;AAAA,oCAA2C;AAC1C,YAAMK,WAAW,iBAAS3B,oBAAoB,CAAC4B,QAArB,CAA8BN,KAAK,CAACO,OAApC,EAA6CP,KAA7C,CAAT,CAAjB,CAD0C,CAG1C;;AACA,UAAIK,WAAW,CAACP,OAAhB,EAAyB;AACxB,cAAM;AACLG,UAAAA,IAAI,EAAE;AAAEkB,YAAAA,MAAF;AAAUI,YAAAA;AAAV;AADD,YAEFvB,KAFJ,CADwB,CAKxB;;AACA,cAAM2B,gBAAgB,GAAG3C,WAAW,CAAC4C,eAAZ,CAA4BL,IAA5B,CAAzB,CANwB,CAQxB;;AACA3C,QAAAA,KAAK,CAAC6G,sBAAN,CAA6BtE,MAA7B,EAAqCQ,gBAAgB,CAAC8C,QAAtD;AACA;;AAED,aAAOpE,WAAP;AACA,KAjBD;AAAA;;AA3aqB,CAAtB;AA+bA/B,GAAG,CAACoH,EAAJ,CAAOC,QAAP,CACC,4BADD,EAEC;AAAEC,EAAAA,YAAY,EAAE,KAAhB;AAAuBC,EAAAA,kBAAkB,EAAE;AAAEC,IAAAA,kBAAkB,EAAE,EAAtB;AAA0BC,IAAAA,gBAAgB,EAAE;AAA5C;AAA3C,CAFD,EAGC;AACCC,EAAAA,IAAI,GAAG;AACN,QAAI,CAAC1G,mBAAmB,EAAxB,EAA4B;AAC3B,aAAOhB,GAAG,CAACoH,EAAJ,CAAOO,OAAP,CAAe,wBAAf,CAAP;AACA,KAHK,CAKN;AACA;;;AACA,QAAIC,OAAJ;;AAEA,QAAI;AACHA,MAAAA,OAAO,GAAGC,OAAO,CAACC,KAAR,CAAc/G,eAAe,CAAC,KAAKgH,OAAN,EAAe,KAAKC,UAApB,CAA7B,CAAV;AACA,KAFD,CAEE,OAAOtC,GAAP,EAAY;AACb,aAAO1F,GAAG,CAACoH,EAAJ,CAAOO,OAAP,CAAe,2BAAf,CAAP;AACA,KAbK,CAeN;AACA;;;AACA,UAAM;AAAEM,MAAAA;AAAF,QAAarI,KAAK,CAACsI,aAAN,CAAoBN,OAApB,CAAnB;AAEA3H,IAAAA,YAAY,CAAC0D,KAAb,CAAmB;AAAEkC,MAAAA,GAAG,EAAE,4BAAP;AAAqCoC,MAAAA;AAArC,KAAnB,EAnBM,CAqBN;;AACA,SAAK,MAAMvG,KAAX,IAAoBuG,MAApB,EAA4B;AAC3B;AAEA,UAAIlG,WAAJ;;AAEA,UAAIT,aAAa,CAACI,KAAK,CAACI,IAAP,CAAjB,EAA+B;AAC9BC,QAAAA,WAAW,GAAG8F,OAAO,CAACC,KAAR,CAAcxG,aAAa,CAACI,KAAK,CAACI,IAAP,CAAb,CAA0BJ,KAA1B,CAAd,CAAd;AACA,OAP0B,CAS3B;;;AACA,UAAI,CAACK,WAAD,IAAgB,CAACA,WAAW,CAACP,OAAjC,EAA0C;AACzC,YAAI;AACHvB,UAAAA,YAAY,CAAC0D,KAAb,CAAmB;AAClBkC,YAAAA,GAAG,EAAE,yDADa;AAElBnE,YAAAA;AAFkB,WAAnB;AAKAmG,UAAAA,OAAO,CAACC,KAAR,CACC5G,uBAAuB,CACtBQ,KAAK,CAACiD,MADgB,EAEtB7D,mBAAmB,EAFG,EAGtBZ,kBAAkB,CAACiI,UAAnB,CAA8BzG,KAA9B,CAHsB,EAItBA,KAAK,CAACO,OAJgB,EAKtBF,WAAW,CAACqG,cALU,CADxB,EANG,CAgBH;;AACA;AACA,SAlBD,CAkBE,OAAO1C,GAAP,EAAY;AACbzF,UAAAA,YAAY,CAACoI,KAAb,CAAmB;AAAExC,YAAAA,GAAG,EAAE,UAAP;AAAmBnE,YAAAA,KAAnB;AAA0BK,YAAAA,WAA1B;AAAuC2D,YAAAA;AAAvC,WAAnB;AAEA,gBAAMA,GAAN;AACA;AACD;AAED;;AACA,KA3DK,CA6DN;;;AACA,WAAO1F,GAAG,CAACoH,EAAJ,CAAO5F,OAAP,EAAP;AACA;;AAhEF,CAHD","sourcesContent":["import { EJSON } from 'meteor/ejson';\n\nimport { API } from '../../../api/server';\nimport { serverLogger } from '../lib/logger';\nimport { contextDefinitions, eventTypes } from '../../../models/server/models/FederationEvents';\nimport { FederationRoomEvents, Messages, Rooms, Subscriptions, Users } from '../../../models/server';\nimport { FederationServers } from '../../../models/server/raw';\nimport { normalizers } from '../normalizers';\nimport { deleteRoom } from '../../../lib/server/functions';\nimport { Notifications } from '../../../notifications/server';\nimport { FileUpload } from '../../../file-upload';\nimport { getFederationDomain } from '../lib/getFederationDomain';\nimport { decryptIfNeeded } from '../lib/crypt';\nimport { isFederationEnabled } from '../lib/isFederationEnabled';\nimport { getUpload, requestEventsFromLatest } from '../handler';\nimport { notifyUsersOnMessage } from '../../../lib/server/lib/notifyUsersOnMessage';\nimport { sendAllNotifications } from '../../../lib/server/lib/sendNotificationsOnMessage';\nimport { processThreads } from '../../../threads/server/hooks/aftersavemessage';\n\nconst eventHandlers = {\n\t//\n\t// PING\n\t//\n\tasync [eventTypes.PING]() {\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t},\n\n\t//\n\t// GENESIS\n\t//\n\tasync [eventTypes.GENESIS](event) {\n\t\tswitch (event.data.contextType) {\n\t\t\tcase contextDefinitions.ROOM.type:\n\t\t\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t\t\t// If the event was successfully added, handle the event locally\n\t\t\t\tif (eventResult.success) {\n\t\t\t\t\tconst {\n\t\t\t\t\t\tdata: { room },\n\t\t\t\t\t} = event;\n\n\t\t\t\t\t// Check if room exists\n\t\t\t\t\tconst persistedRoom = Rooms.findOne({ _id: room._id });\n\n\t\t\t\t\tif (persistedRoom) {\n\t\t\t\t\t\t// Update the federation\n\t\t\t\t\t\tRooms.update({ _id: persistedRoom._id }, { $set: { federation: room.federation } });\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Denormalize room\n\t\t\t\t\t\tconst denormalizedRoom = normalizers.denormalizeRoom(room);\n\n\t\t\t\t\t\t// Create the room\n\t\t\t\t\t\tRooms.insert(denormalizedRoom);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn eventResult;\n\t\t}\n\t},\n\n\t//\n\t// ROOM_DELETE\n\t//\n\tasync [eventTypes.ROOM_DELETE](event) {\n\t\tconst {\n\t\t\tdata: { roomId },\n\t\t} = event;\n\n\t\t// Check if room exists\n\t\tconst persistedRoom = Rooms.findOne({ _id: roomId });\n\n\t\tif (persistedRoom) {\n\t\t\t// Delete the room\n\t\t\tdeleteRoom(roomId);\n\t\t}\n\n\t\t// Remove all room events\n\t\tawait FederationRoomEvents.removeRoomEvents(roomId);\n\n\t\treturn {\n\t\t\tsuccess: true,\n\t\t};\n\t},\n\n\t//\n\t// ROOM_ADD_USER\n\t//\n\tasync [eventTypes.ROOM_ADD_USER](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// We only want to refresh the server list and update the room federation array if something changed\n\t\tlet federationAltered = false;\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user, subscription, domainsAfterAdd },\n\t\t\t} = event;\n\n\t\t\t// Check if user exists\n\t\t\tconst persistedUser = Users.findOne({ _id: user._id });\n\n\t\t\tif (persistedUser) {\n\t\t\t\t// Update the federation, if its not already set (if it's set, this is likely an event being reprocessed)\n\t\t\t\tif (!persistedUser.federation) {\n\t\t\t\t\tUsers.update({ _id: persistedUser._id }, { $set: { federation: user.federation } });\n\t\t\t\t\tfederationAltered = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Denormalize user\n\t\t\t\tconst denormalizedUser = normalizers.denormalizeUser(user);\n\n\t\t\t\t// Create the user\n\t\t\t\tUsers.insert(denormalizedUser);\n\t\t\t\tfederationAltered = true;\n\t\t\t}\n\n\t\t\t// Check if subscription exists\n\t\t\tconst persistedSubscription = Subscriptions.findOne({ _id: subscription._id });\n\n\t\t\ttry {\n\t\t\t\tif (persistedSubscription) {\n\t\t\t\t\t// Update the federation, if its not already set (if it's set, this is likely an event being reprocessed\n\t\t\t\t\tif (!persistedSubscription.federation) {\n\t\t\t\t\t\tSubscriptions.update({ _id: persistedSubscription._id }, { $set: { federation: subscription.federation } });\n\t\t\t\t\t\tfederationAltered = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Denormalize subscription\n\t\t\t\t\tconst denormalizedSubscription = normalizers.denormalizeSubscription(subscription);\n\n\t\t\t\t\t// Create the subscription\n\t\t\t\t\tSubscriptions.insert(denormalizedSubscription);\n\t\t\t\t\tfederationAltered = true;\n\t\t\t\t}\n\t\t\t} catch (ex) {\n\t\t\t\tserverLogger.debug(`unable to create subscription for user ( ${user._id} ) in room (${roomId})`);\n\t\t\t}\n\n\t\t\t// Refresh the servers list\n\t\t\tif (federationAltered) {\n\t\t\t\tawait FederationServers.refreshServers();\n\n\t\t\t\t// Update the room's federation property\n\t\t\t\tRooms.update({ _id: roomId }, { $set: { 'federation.domains': domainsAfterAdd } });\n\t\t\t}\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_REMOVE_USER\n\t//\n\tasync [eventTypes.ROOM_REMOVE_USER](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user, domainsAfterRemoval },\n\t\t\t} = event;\n\n\t\t\t// Remove the user's subscription\n\t\t\tSubscriptions.removeByRoomIdAndUserId(roomId, user._id);\n\n\t\t\t// Refresh the servers list\n\t\t\tawait FederationServers.refreshServers();\n\n\t\t\t// Update the room's federation property\n\t\t\tRooms.update({ _id: roomId }, { $set: { 'federation.domains': domainsAfterRemoval } });\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_USER_LEFT\n\t//\n\tasync [eventTypes.ROOM_USER_LEFT](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user, domainsAfterRemoval },\n\t\t\t} = event;\n\n\t\t\t// Remove the user's subscription\n\t\t\tSubscriptions.removeByRoomIdAndUserId(roomId, user._id);\n\n\t\t\t// Refresh the servers list\n\t\t\tawait FederationServers.refreshServers();\n\n\t\t\t// Update the room's federation property\n\t\t\tRooms.update({ _id: roomId }, { $set: { 'federation.domains': domainsAfterRemoval } });\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_MESSAGE\n\t//\n\tasync [eventTypes.ROOM_MESSAGE](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { message },\n\t\t\t} = event;\n\n\t\t\t// Check if message exists\n\t\t\tconst persistedMessage = Messages.findOne({ _id: message._id });\n\n\t\t\tif (persistedMessage) {\n\t\t\t\t// Update the federation\n\t\t\t\tif (!persistedMessage.federation) {\n\t\t\t\t\tMessages.update({ _id: persistedMessage._id }, { $set: { federation: message.federation } });\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Load the room\n\t\t\t\tconst room = Rooms.findOneById(message.rid);\n\n\t\t\t\t// Denormalize message\n\t\t\t\tconst denormalizedMessage = normalizers.denormalizeMessage(message);\n\n\t\t\t\t// Is there a file?\n\t\t\t\tif (denormalizedMessage.file) {\n\t\t\t\t\tconst fileStore = FileUpload.getStore('Uploads');\n\n\t\t\t\t\tconst {\n\t\t\t\t\t\tfederation: { origin },\n\t\t\t\t\t} = denormalizedMessage;\n\n\t\t\t\t\tconst { upload, buffer } = await getUpload(origin, denormalizedMessage.file._id);\n\n\t\t\t\t\tconst oldUploadId = upload._id;\n\n\t\t\t\t\t// Normalize upload\n\t\t\t\t\tdelete upload._id;\n\t\t\t\t\tupload.rid = denormalizedMessage.rid;\n\t\t\t\t\tupload.userId = denormalizedMessage.u._id;\n\t\t\t\t\tupload.federation = {\n\t\t\t\t\t\t_id: denormalizedMessage.file._id,\n\t\t\t\t\t\torigin,\n\t\t\t\t\t};\n\n\t\t\t\t\tfileStore.insertSync(upload, buffer);\n\n\t\t\t\t\t// Update the message's file\n\t\t\t\t\tdenormalizedMessage.file._id = upload._id;\n\n\t\t\t\t\t// Update the message's attachments dependent on type\n\t\t\t\t\tfor (const attachment of denormalizedMessage.attachments) {\n\t\t\t\t\t\tattachment.title_link = attachment.title_link.replace(oldUploadId, upload._id);\n\t\t\t\t\t\tif (/^image\\/.+/.test(denormalizedMessage.file.type)) {\n\t\t\t\t\t\t\tattachment.image_url = attachment.image_url.replace(oldUploadId, upload._id);\n\t\t\t\t\t\t} else if (/^audio\\/.+/.test(denormalizedMessage.file.type)) {\n\t\t\t\t\t\t\tattachment.audio_url = attachment.audio_url.replace(oldUploadId, upload._id);\n\t\t\t\t\t\t} else if (/^video\\/.+/.test(denormalizedMessage.file.type)) {\n\t\t\t\t\t\t\tattachment.video_url = attachment.video_url.replace(oldUploadId, upload._id);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create the message\n\t\t\t\ttry {\n\t\t\t\t\tMessages.insert(denormalizedMessage);\n\n\t\t\t\t\tprocessThreads(denormalizedMessage, room);\n\n\t\t\t\t\t// Notify users\n\t\t\t\t\tnotifyUsersOnMessage(denormalizedMessage, room);\n\t\t\t\t\tsendAllNotifications(denormalizedMessage, room);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tserverLogger.debug(`Error on creating message: ${message._id}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_EDIT_MESSAGE\n\t//\n\tasync [eventTypes.ROOM_EDIT_MESSAGE](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { message },\n\t\t\t} = event;\n\n\t\t\t// Check if message exists\n\t\t\tconst persistedMessage = Messages.findOne({ _id: message._id });\n\n\t\t\tif (!persistedMessage) {\n\t\t\t\teventResult.success = false;\n\t\t\t\teventResult.reason = 'missingMessageToEdit';\n\t\t\t} else {\n\t\t\t\t// Update the message\n\t\t\t\tMessages.update({ _id: persistedMessage._id }, { $set: { msg: message.msg, federation: message.federation } });\n\t\t\t}\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_DELETE_MESSAGE\n\t//\n\tasync [eventTypes.ROOM_DELETE_MESSAGE](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, messageId },\n\t\t\t} = event;\n\n\t\t\t// Remove the message\n\t\t\tMessages.removeById(messageId);\n\n\t\t\t// Notify the room\n\t\t\tNotifications.notifyRoom(roomId, 'deleteMessage', { _id: messageId });\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_SET_MESSAGE_REACTION\n\t//\n\tasync [eventTypes.ROOM_SET_MESSAGE_REACTION](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { messageId, username, reaction },\n\t\t\t} = event;\n\n\t\t\t// Get persisted message\n\t\t\tconst persistedMessage = Messages.findOne({ _id: messageId });\n\n\t\t\t// Make sure reactions exist\n\t\t\tpersistedMessage.reactions = persistedMessage.reactions || {};\n\n\t\t\tlet reactionObj = persistedMessage.reactions[reaction];\n\n\t\t\t// If there are no reactions of that type, add it\n\t\t\tif (!reactionObj) {\n\t\t\t\treactionObj = {\n\t\t\t\t\tusernames: [username],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\t// Otherwise, add the username\n\t\t\t\treactionObj.usernames.push(username);\n\t\t\t\treactionObj.usernames = [...new Set(reactionObj.usernames)];\n\t\t\t}\n\n\t\t\t// Update the property\n\t\t\tMessages.update({ _id: messageId }, { $set: { [`reactions.${reaction}`]: reactionObj } });\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_UNSET_MESSAGE_REACTION\n\t//\n\tasync [eventTypes.ROOM_UNSET_MESSAGE_REACTION](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { messageId, username, reaction },\n\t\t\t} = event;\n\n\t\t\t// Get persisted message\n\t\t\tconst persistedMessage = Messages.findOne({ _id: messageId });\n\n\t\t\t// Make sure reactions exist\n\t\t\tpersistedMessage.reactions = persistedMessage.reactions || {};\n\n\t\t\t// If there are no reactions of that type, ignore\n\t\t\tif (!persistedMessage.reactions[reaction]) {\n\t\t\t\treturn eventResult;\n\t\t\t}\n\n\t\t\tconst reactionObj = persistedMessage.reactions[reaction];\n\n\t\t\t// Get the username index on the list\n\t\t\tconst usernameIdx = reactionObj.usernames.indexOf(username);\n\n\t\t\t// If the index is not found, ignore\n\t\t\tif (usernameIdx === -1) {\n\t\t\t\treturn eventResult;\n\t\t\t}\n\n\t\t\t// Remove the username from the given reaction\n\t\t\treactionObj.usernames.splice(usernameIdx, 1);\n\n\t\t\t// If there are no more users for that reaction, remove the property\n\t\t\tif (reactionObj.usernames.length === 0) {\n\t\t\t\tMessages.update({ _id: messageId }, { $unset: { [`reactions.${reaction}`]: 1 } });\n\t\t\t} else {\n\t\t\t\t// Otherwise, update the property\n\t\t\t\tMessages.update({ _id: messageId }, { $set: { [`reactions.${reaction}`]: reactionObj } });\n\t\t\t}\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_MUTE_USER\n\t//\n\tasync [eventTypes.ROOM_MUTE_USER](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user },\n\t\t\t} = event;\n\n\t\t\t// Denormalize user\n\t\t\tconst denormalizedUser = normalizers.denormalizeUser(user);\n\n\t\t\t// Mute user\n\t\t\tRooms.muteUsernameByRoomId(roomId, denormalizedUser.username);\n\t\t}\n\n\t\treturn eventResult;\n\t},\n\n\t//\n\t// ROOM_UNMUTE_USER\n\t//\n\tasync [eventTypes.ROOM_UNMUTE_USER](event) {\n\t\tconst eventResult = await FederationRoomEvents.addEvent(event.context, event);\n\n\t\t// If the event was successfully added, handle the event locally\n\t\tif (eventResult.success) {\n\t\t\tconst {\n\t\t\t\tdata: { roomId, user },\n\t\t\t} = event;\n\n\t\t\t// Denormalize user\n\t\t\tconst denormalizedUser = normalizers.denormalizeUser(user);\n\n\t\t\t// Mute user\n\t\t\tRooms.unmuteUsernameByRoomId(roomId, denormalizedUser.username);\n\t\t}\n\n\t\treturn eventResult;\n\t},\n};\n\nAPI.v1.addRoute(\n\t'federation.events.dispatch',\n\t{ authRequired: false, rateLimiterOptions: { numRequestsAllowed: 30, intervalTimeInMS: 1000 } },\n\t{\n\t\tpost() {\n\t\t\tif (!isFederationEnabled()) {\n\t\t\t\treturn API.v1.failure('Federation not enabled');\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Decrypt the payload if needed\n\t\t\tlet payload;\n\n\t\t\ttry {\n\t\t\t\tpayload = Promise.await(decryptIfNeeded(this.request, this.bodyParams));\n\t\t\t} catch (err) {\n\t\t\t\treturn API.v1.failure('Could not decrypt payload');\n\t\t\t}\n\n\t\t\t//\n\t\t\t// Convert from EJSON\n\t\t\tconst { events } = EJSON.fromJSONValue(payload);\n\n\t\t\tserverLogger.debug({ msg: 'federation.events.dispatch', events });\n\n\t\t\t// Loop over received events\n\t\t\tfor (const event of events) {\n\t\t\t\t/* eslint-disable no-await-in-loop */\n\n\t\t\t\tlet eventResult;\n\n\t\t\t\tif (eventHandlers[event.type]) {\n\t\t\t\t\teventResult = Promise.await(eventHandlers[event.type](event));\n\t\t\t\t}\n\n\t\t\t\t// If there was an error handling the event, take action\n\t\t\t\tif (!eventResult || !eventResult.success) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tserverLogger.debug({\n\t\t\t\t\t\t\tmsg: 'federation.events.dispatch => Event has missing parents',\n\t\t\t\t\t\t\tevent,\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tPromise.await(\n\t\t\t\t\t\t\trequestEventsFromLatest(\n\t\t\t\t\t\t\t\tevent.origin,\n\t\t\t\t\t\t\t\tgetFederationDomain(),\n\t\t\t\t\t\t\t\tcontextDefinitions.defineType(event),\n\t\t\t\t\t\t\t\tevent.context,\n\t\t\t\t\t\t\t\teventResult.latestEventIds,\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// And stop handling the events\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\tserverLogger.error({ msg: 'dispatch', event, eventResult, err });\n\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* eslint-enable no-await-in-loop */\n\t\t\t}\n\n\t\t\t// Respond\n\t\t\treturn API.v1.success();\n\t\t},\n\t},\n);\n"]},"sourceType":"module","hash":"80eee1c3fcfd6a8ecb45d81698a2fd48ba49361f"}
