{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/packages/accounts-base/accounts_server.js","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"packages/accounts-base/accounts_server.js","filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/packages/accounts-base/accounts_server.js","targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","root":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/packages/accounts-base/accounts_server.js","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"packages/accounts-base/accounts_server.js"}},"code":"const _excluded = [\"token\"];\n\nlet _objectWithoutProperties;\n\nmodule.link(\"@babel/runtime/helpers/objectWithoutProperties\", {\n  default(v) {\n    _objectWithoutProperties = v;\n  }\n\n}, 0);\n\nlet _objectSpread;\n\nmodule.link(\"@babel/runtime/helpers/objectSpread2\", {\n  default(v) {\n    _objectSpread = v;\n  }\n\n}, 1);\nmodule.export({\n  AccountsServer: () => AccountsServer\n});\nlet crypto;\nmodule.link(\"crypto\", {\n  default(v) {\n    crypto = v;\n  }\n\n}, 0);\nlet AccountsCommon, EXPIRE_TOKENS_INTERVAL_MS;\nmodule.link(\"./accounts_common.js\", {\n  AccountsCommon(v) {\n    AccountsCommon = v;\n  },\n\n  EXPIRE_TOKENS_INTERVAL_MS(v) {\n    EXPIRE_TOKENS_INTERVAL_MS = v;\n  }\n\n}, 1);\nlet URL;\nmodule.link(\"meteor/url\", {\n  URL(v) {\n    URL = v;\n  }\n\n}, 2);\nconst hasOwn = Object.prototype.hasOwnProperty; // XXX maybe this belongs in the check package\n\nconst NonEmptyString = Match.Where(x => {\n  check(x, String);\n  return x.length > 0;\n});\n/**\n * @summary Constructor for the `Accounts` namespace on the server.\n * @locus Server\n * @class AccountsServer\n * @extends AccountsCommon\n * @instancename accountsServer\n * @param {Object} server A server object such as `Meteor.server`.\n */\n\nclass AccountsServer extends AccountsCommon {\n  // Note that this constructor is less likely to be instantiated multiple\n  // times than the `AccountsClient` constructor, because a single server\n  // can provide only one set of methods.\n  constructor(server) {\n    var _this;\n\n    super();\n    _this = this;\n\n    this.onCreateLoginToken = function (func) {\n      if (this._onCreateLoginTokenHook) {\n        throw new Error('Can only call onCreateLoginToken once');\n      }\n\n      this._onCreateLoginTokenHook = func;\n    };\n\n    this._selectorForFastCaseInsensitiveLookup = (fieldName, string) => {\n      // Performance seems to improve up to 4 prefix characters\n      const prefix = string.substring(0, Math.min(string.length, 4));\n      const orClause = generateCasePermutationsForString(prefix).map(prefixPermutation => {\n        const selector = {};\n        selector[fieldName] = new RegExp(\"^\".concat(Meteor._escapeRegExp(prefixPermutation)));\n        return selector;\n      });\n      const caseInsensitiveClause = {};\n      caseInsensitiveClause[fieldName] = new RegExp(\"^\".concat(Meteor._escapeRegExp(string), \"$\"), 'i');\n      return {\n        $and: [{\n          $or: orClause\n        }, caseInsensitiveClause]\n      };\n    };\n\n    this._findUserByQuery = (query, options) => {\n      let user = null;\n\n      if (query.id) {\n        // default field selector is added within getUserById()\n        user = Meteor.users.findOne(query.id, this._addDefaultFieldSelector(options));\n      } else {\n        options = this._addDefaultFieldSelector(options);\n        let fieldName;\n        let fieldValue;\n\n        if (query.username) {\n          fieldName = 'username';\n          fieldValue = query.username;\n        } else if (query.email) {\n          fieldName = 'emails.address';\n          fieldValue = query.email;\n        } else {\n          throw new Error(\"shouldn't happen (validation missed something)\");\n        }\n\n        let selector = {};\n        selector[fieldName] = fieldValue;\n        user = Meteor.users.findOne(selector, options); // If user is not found, try a case insensitive lookup\n\n        if (!user) {\n          selector = this._selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n          const candidateUsers = Meteor.users.find(selector, options).fetch(); // No match if multiple candidates are found\n\n          if (candidateUsers.length === 1) {\n            user = candidateUsers[0];\n          }\n        }\n      }\n\n      return user;\n    };\n\n    this._handleError = function (msg) {\n      let throwError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      const error = new Meteor.Error(403, _this._options.ambiguousErrorMessages ? \"Something went wrong. Please check your credentials.\" : msg);\n\n      if (throwError) {\n        throw error;\n      }\n\n      return error;\n    };\n\n    this._userQueryValidator = Match.Where(user => {\n      check(user, {\n        id: Match.Optional(NonEmptyString),\n        username: Match.Optional(NonEmptyString),\n        email: Match.Optional(NonEmptyString)\n      });\n      if (Object.keys(user).length !== 1) throw new Match.Error(\"User property must have exactly one field\");\n      return true;\n    });\n    this._server = server || Meteor.server; // Set up the server's methods, as if by calling Meteor.methods.\n\n    this._initServerMethods();\n\n    this._initAccountDataHooks(); // If autopublish is on, publish these user fields. Login service\n    // packages (eg accounts-google) add to these by calling\n    // addAutopublishFields.  Notably, this isn't implemented with multiple\n    // publishes since DDP only merges only across top-level fields, not\n    // subfields (such as 'services.facebook.accessToken')\n\n\n    this._autopublishFields = {\n      loggedInUser: ['profile', 'username', 'emails'],\n      otherUsers: ['profile', 'username']\n    }; // use object to keep the reference when used in functions\n    // where _defaultPublishFields is destructured into lexical scope\n    // for publish callbacks that need `this`\n\n    this._defaultPublishFields = {\n      projection: {\n        profile: 1,\n        username: 1,\n        emails: 1\n      }\n    };\n\n    this._initServerPublications(); // connectionId -> {connection, loginToken}\n\n\n    this._accountData = {}; // connection id -> observe handle for the login token that this connection is\n    // currently associated with, or a number. The number indicates that we are in\n    // the process of setting up the observe (using a number instead of a single\n    // sentinel allows multiple attempts to set up the observe to identify which\n    // one was theirs).\n\n    this._userObservesForConnections = {};\n    this._nextUserObserveNumber = 1; // for the number described above.\n    // list of all registered handlers.\n\n    this._loginHandlers = [];\n    setupUsersCollection(this.users);\n    setupDefaultLoginHandlers(this);\n    setExpireTokensInterval(this);\n    this._validateLoginHook = new Hook({\n      bindEnvironment: false\n    });\n    this._validateNewUserHooks = [defaultValidateNewUserHook.bind(this)];\n\n    this._deleteSavedTokensForAllUsersOnStartup();\n\n    this._skipCaseInsensitiveChecksForTest = {};\n    this.urls = {\n      resetPassword: (token, extraParams) => this.buildEmailUrl(\"#/reset-password/\".concat(token), extraParams),\n      verifyEmail: (token, extraParams) => this.buildEmailUrl(\"#/verify-email/\".concat(token), extraParams),\n      loginToken: (selector, token, extraParams) => this.buildEmailUrl(\"/?loginToken=\".concat(token, \"&selector=\").concat(selector), extraParams),\n      enrollAccount: (token, extraParams) => this.buildEmailUrl(\"#/enroll-account/\".concat(token), extraParams)\n    };\n    this.addDefaultRateLimit();\n\n    this.buildEmailUrl = function (path) {\n      let extraParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const url = new URL(Meteor.absoluteUrl(path));\n      const params = Object.entries(extraParams);\n\n      if (params.length > 0) {\n        // Add additional parameters to the url\n        for (const [key, value] of params) {\n          url.searchParams.append(key, value);\n        }\n      }\n\n      return url.toString();\n    };\n  } ///\n  /// CURRENT USER\n  ///\n  // @override of \"abstract\" non-implementation in accounts_common.js\n\n\n  userId() {\n    // This function only works if called inside a method or a pubication.\n    // Using any of the information from Meteor.user() in a method or\n    // publish function will always use the value from when the function first\n    // runs. This is likely not what the user expects. The way to make this work\n    // in a method or publish function is to do Meteor.find(this.userId).observe\n    // and recompute when the user record changes.\n    const currentInvocation = DDP._CurrentMethodInvocation.get() || DDP._CurrentPublicationInvocation.get();\n\n    if (!currentInvocation) throw new Error(\"Meteor.userId can only be invoked in method calls or publications.\");\n    return currentInvocation.userId;\n  } ///\n  /// LOGIN HOOKS\n  ///\n\n  /**\n   * @summary Validate login attempts.\n   * @locus Server\n   * @param {Function} func Called whenever a login is attempted (either successful or unsuccessful).  A login can be aborted by returning a falsy value or throwing an exception.\n   */\n\n\n  validateLoginAttempt(func) {\n    // Exceptions inside the hook callback are passed up to us.\n    return this._validateLoginHook.register(func);\n  }\n  /**\n   * @summary Set restrictions on new user creation.\n   * @locus Server\n   * @param {Function} func Called whenever a new user is created. Takes the new user object, and returns true to allow the creation or false to abort.\n   */\n\n\n  validateNewUser(func) {\n    this._validateNewUserHooks.push(func);\n  }\n  /**\n   * @summary Validate login from external service\n   * @locus Server\n   * @param {Function} func Called whenever login/user creation from external service is attempted. Login or user creation based on this login can be aborted by passing a falsy value or throwing an exception.\n   */\n\n\n  beforeExternalLogin(func) {\n    if (this._beforeExternalLoginHook) {\n      throw new Error(\"Can only call beforeExternalLogin once\");\n    }\n\n    this._beforeExternalLoginHook = func;\n  } ///\n  /// CREATE USER HOOKS\n  ///\n\n  /**\n   * @summary Customize login token creation.\n   * @locus Server\n   * @param {Function} func Called whenever a new token is created.\n   * Return the sequence and the user object. Return true to keep sending the default email, or false to override the behavior.\n   */\n\n\n  /**\n   * @summary Customize new user creation.\n   * @locus Server\n   * @param {Function} func Called whenever a new user is created. Return the new user object, or throw an `Error` to abort the creation.\n   */\n  onCreateUser(func) {\n    if (this._onCreateUserHook) {\n      throw new Error(\"Can only call onCreateUser once\");\n    }\n\n    this._onCreateUserHook = func;\n  }\n  /**\n   * @summary Customize oauth user profile updates\n   * @locus Server\n   * @param {Function} func Called whenever a user is logged in via oauth. Return the profile object to be merged, or throw an `Error` to abort the creation.\n   */\n\n\n  onExternalLogin(func) {\n    if (this._onExternalLoginHook) {\n      throw new Error(\"Can only call onExternalLogin once\");\n    }\n\n    this._onExternalLoginHook = func;\n  }\n  /**\n   * @summary Customize user selection on external logins\n   * @locus Server\n   * @param {Function} func Called whenever a user is logged in via oauth and a\n   * user is not found with the service id. Return the user or undefined.\n   */\n\n\n  setAdditionalFindUserOnExternalLogin(func) {\n    if (this._additionalFindUserOnExternalLogin) {\n      throw new Error(\"Can only call setAdditionalFindUserOnExternalLogin once\");\n    }\n\n    this._additionalFindUserOnExternalLogin = func;\n  }\n\n  _validateLogin(connection, attempt) {\n    this._validateLoginHook.each(callback => {\n      let ret;\n\n      try {\n        ret = callback(cloneAttemptWithConnection(connection, attempt));\n      } catch (e) {\n        attempt.allowed = false; // XXX this means the last thrown error overrides previous error\n        // messages. Maybe this is surprising to users and we should make\n        // overriding errors more explicit. (see\n        // https://github.com/meteor/meteor/issues/1960)\n\n        attempt.error = e;\n        return true;\n      }\n\n      if (!ret) {\n        attempt.allowed = false; // don't override a specific error provided by a previous\n        // validator or the initial attempt (eg \"incorrect password\").\n\n        if (!attempt.error) attempt.error = new Meteor.Error(403, \"Login forbidden\");\n      }\n\n      return true;\n    });\n  }\n\n  _successfulLogin(connection, attempt) {\n    this._onLoginHook.each(callback => {\n      callback(cloneAttemptWithConnection(connection, attempt));\n      return true;\n    });\n  }\n\n  _failedLogin(connection, attempt) {\n    this._onLoginFailureHook.each(callback => {\n      callback(cloneAttemptWithConnection(connection, attempt));\n      return true;\n    });\n  }\n\n  _successfulLogout(connection, userId) {\n    // don't fetch the user object unless there are some callbacks registered\n    let user;\n\n    this._onLogoutHook.each(callback => {\n      if (!user && userId) user = this.users.findOne(userId, {\n        fields: this._options.defaultFieldSelector\n      });\n      callback({\n        user,\n        connection\n      });\n      return true;\n    });\n  }\n\n  ///\n  /// LOGIN METHODS\n  ///\n  // Login methods return to the client an object containing these\n  // fields when the user was logged in successfully:\n  //\n  //   id: userId\n  //   token: *\n  //   tokenExpires: *\n  //\n  // tokenExpires is optional and intends to provide a hint to the\n  // client as to when the token will expire. If not provided, the\n  // client will call Accounts._tokenExpiration, passing it the date\n  // that it received the token.\n  //\n  // The login method will throw an error back to the client if the user\n  // failed to log in.\n  //\n  //\n  // Login handlers and service specific login methods such as\n  // `createUser` internally return a `result` object containing these\n  // fields:\n  //\n  //   type:\n  //     optional string; the service name, overrides the handler\n  //     default if present.\n  //\n  //   error:\n  //     exception; if the user is not allowed to login, the reason why.\n  //\n  //   userId:\n  //     string; the user id of the user attempting to login (if\n  //     known), required for an allowed login.\n  //\n  //   options:\n  //     optional object merged into the result returned by the login\n  //     method; used by HAMK from SRP.\n  //\n  //   stampedLoginToken:\n  //     optional object with `token` and `when` indicating the login\n  //     token is already present in the database, returned by the\n  //     \"resume\" login handler.\n  //\n  // For convenience, login methods can also throw an exception, which\n  // is converted into an {error} result.  However, if the id of the\n  // user attempting the login is known, a {userId, error} result should\n  // be returned instead since the user id is not captured when an\n  // exception is thrown.\n  //\n  // This internal `result` object is automatically converted into the\n  // public {id, token, tokenExpires} object returned to the client.\n  // Try a login method, converting thrown exceptions into an {error}\n  // result.  The `type` argument is a default, inserted into the result\n  // object if not explicitly returned.\n  //\n  // Log in a user on a connection.\n  //\n  // We use the method invocation to set the user id on the connection,\n  // not the connection object directly. setUserId is tied to methods to\n  // enforce clear ordering of method application (using wait methods on\n  // the client, and a no setUserId after unblock restriction on the\n  // server)\n  //\n  // The `stampedLoginToken` parameter is optional.  When present, it\n  // indicates that the login token has already been inserted into the\n  // database and doesn't need to be inserted again.  (It's used by the\n  // \"resume\" login handler).\n  _loginUser(methodInvocation, userId, stampedLoginToken) {\n    if (!stampedLoginToken) {\n      stampedLoginToken = this._generateStampedLoginToken();\n\n      this._insertLoginToken(userId, stampedLoginToken);\n    } // This order (and the avoidance of yields) is important to make\n    // sure that when publish functions are rerun, they see a\n    // consistent view of the world: the userId is set and matches\n    // the login token on the connection (not that there is\n    // currently a public API for reading the login token on a\n    // connection).\n\n\n    Meteor._noYieldsAllowed(() => this._setLoginToken(userId, methodInvocation.connection, this._hashLoginToken(stampedLoginToken.token)));\n\n    methodInvocation.setUserId(userId);\n    return {\n      id: userId,\n      token: stampedLoginToken.token,\n      tokenExpires: this._tokenExpiration(stampedLoginToken.when)\n    };\n  }\n\n  // After a login method has completed, call the login hooks.  Note\n  // that `attemptLogin` is called for *all* login attempts, even ones\n  // which aren't successful (such as an invalid password, etc).\n  //\n  // If the login is allowed and isn't aborted by a validate login hook\n  // callback, log in the user.\n  //\n  _attemptLogin(methodInvocation, methodName, methodArgs, result) {\n    if (!result) throw new Error(\"result is required\"); // XXX A programming error in a login handler can lead to this occurring, and\n    // then we don't call onLogin or onLoginFailure callbacks. Should\n    // tryLoginMethod catch this case and turn it into an error?\n\n    if (!result.userId && !result.error) throw new Error(\"A login method must specify a userId or an error\");\n    let user;\n    if (result.userId) user = this.users.findOne(result.userId, {\n      fields: this._options.defaultFieldSelector\n    });\n    const attempt = {\n      type: result.type || \"unknown\",\n      allowed: !!(result.userId && !result.error),\n      methodName: methodName,\n      methodArguments: Array.from(methodArgs)\n    };\n\n    if (result.error) {\n      attempt.error = result.error;\n    }\n\n    if (user) {\n      attempt.user = user;\n    } // _validateLogin may mutate `attempt` by adding an error and changing allowed\n    // to false, but that's the only change it can make (and the user's callbacks\n    // only get a clone of `attempt`).\n\n\n    this._validateLogin(methodInvocation.connection, attempt);\n\n    if (attempt.allowed) {\n      const ret = _objectSpread(_objectSpread({}, this._loginUser(methodInvocation, result.userId, result.stampedLoginToken)), result.options);\n\n      ret.type = attempt.type;\n\n      this._successfulLogin(methodInvocation.connection, attempt);\n\n      return ret;\n    } else {\n      this._failedLogin(methodInvocation.connection, attempt);\n\n      throw attempt.error;\n    }\n  }\n\n  // All service specific login methods should go through this function.\n  // Ensure that thrown exceptions are caught and that login hook\n  // callbacks are still called.\n  //\n  _loginMethod(methodInvocation, methodName, methodArgs, type, fn) {\n    return this._attemptLogin(methodInvocation, methodName, methodArgs, tryLoginMethod(type, fn));\n  }\n\n  // Report a login attempt failed outside the context of a normal login\n  // method. This is for use in the case where there is a multi-step login\n  // procedure (eg SRP based password login). If a method early in the\n  // chain fails, it should call this function to report a failure. There\n  // is no corresponding method for a successful login; methods that can\n  // succeed at logging a user in should always be actual login methods\n  // (using either Accounts._loginMethod or Accounts.registerLoginHandler).\n  _reportLoginFailure(methodInvocation, methodName, methodArgs, result) {\n    const attempt = {\n      type: result.type || \"unknown\",\n      allowed: false,\n      error: result.error,\n      methodName: methodName,\n      methodArguments: Array.from(methodArgs)\n    };\n\n    if (result.userId) {\n      attempt.user = this.users.findOne(result.userId, {\n        fields: this._options.defaultFieldSelector\n      });\n    }\n\n    this._validateLogin(methodInvocation.connection, attempt);\n\n    this._failedLogin(methodInvocation.connection, attempt); // _validateLogin may mutate attempt to set a new error message. Return\n    // the modified version.\n\n\n    return attempt;\n  }\n\n  ///\n  /// LOGIN HANDLERS\n  ///\n  // The main entry point for auth packages to hook in to login.\n  //\n  // A login handler is a login method which can return `undefined` to\n  // indicate that the login request is not handled by this handler.\n  //\n  // @param name {String} Optional.  The service name, used by default\n  // if a specific service name isn't returned in the result.\n  //\n  // @param handler {Function} A function that receives an options object\n  // (as passed as an argument to the `login` method) and returns one of:\n  // - `undefined`, meaning don't handle;\n  // - a login method result object\n  registerLoginHandler(name, handler) {\n    if (!handler) {\n      handler = name;\n      name = null;\n    }\n\n    this._loginHandlers.push({\n      name: name,\n      handler: handler\n    });\n  }\n\n  // Checks a user's credentials against all the registered login\n  // handlers, and returns a login token if the credentials are valid. It\n  // is like the login method, except that it doesn't set the logged-in\n  // user on the connection. Throws a Meteor.Error if logging in fails,\n  // including the case where none of the login handlers handled the login\n  // request. Otherwise, returns {id: userId, token: *, tokenExpires: *}.\n  //\n  // For example, if you want to login with a plaintext password, `options` could be\n  //   { user: { username: <username> }, password: <password> }, or\n  //   { user: { email: <email> }, password: <password> }.\n  // Try all of the registered login handlers until one of them doesn't\n  // return `undefined`, meaning it handled this call to `login`. Return\n  // that return value.\n  _runLoginHandlers(methodInvocation, options) {\n    for (let handler of this._loginHandlers) {\n      const result = tryLoginMethod(handler.name, () => handler.handler.call(methodInvocation, options));\n\n      if (result) {\n        return result;\n      }\n\n      if (result !== undefined) {\n        throw new Meteor.Error(400, \"A login handler should return a result or undefined\");\n      }\n    }\n\n    return {\n      type: null,\n      error: new Meteor.Error(400, \"Unrecognized options for login request\")\n    };\n  }\n\n  // Deletes the given loginToken from the database.\n  //\n  // For new-style hashed token, this will cause all connections\n  // associated with the token to be closed.\n  //\n  // Any connections associated with old-style unhashed tokens will be\n  // in the process of becoming associated with hashed tokens and then\n  // they'll get closed.\n  destroyToken(userId, loginToken) {\n    this.users.update(userId, {\n      $pull: {\n        \"services.resume.loginTokens\": {\n          $or: [{\n            hashedToken: loginToken\n          }, {\n            token: loginToken\n          }]\n        }\n      }\n    });\n  }\n\n  _initServerMethods() {\n    // The methods created in this function need to be created here so that\n    // this variable is available in their scope.\n    const accounts = this; // This object will be populated with methods and then passed to\n    // accounts._server.methods further below.\n\n    const methods = {}; // @returns {Object|null}\n    //   If successful, returns {token: reconnectToken, id: userId}\n    //   If unsuccessful (for example, if the user closed the oauth login popup),\n    //     throws an error describing the reason\n\n    methods.login = function (options) {\n      // Login handlers should really also check whatever field they look at in\n      // options, but we don't enforce it.\n      check(options, Object);\n\n      const result = accounts._runLoginHandlers(this, options);\n\n      return accounts._attemptLogin(this, \"login\", arguments, result);\n    };\n\n    methods.logout = function () {\n      const token = accounts._getLoginToken(this.connection.id);\n\n      accounts._setLoginToken(this.userId, this.connection, null);\n\n      if (token && this.userId) {\n        accounts.destroyToken(this.userId, token);\n      }\n\n      accounts._successfulLogout(this.connection, this.userId);\n\n      this.setUserId(null);\n    }; // Generates a new login token with the same expiration as the\n    // connection's current token and saves it to the database. Associates\n    // the connection with this new token and returns it. Throws an error\n    // if called on a connection that isn't logged in.\n    //\n    // @returns Object\n    //   If successful, returns { token: <new token>, id: <user id>,\n    //   tokenExpires: <expiration date> }.\n\n\n    methods.getNewToken = function () {\n      const user = accounts.users.findOne(this.userId, {\n        fields: {\n          \"services.resume.loginTokens\": 1\n        }\n      });\n\n      if (!this.userId || !user) {\n        throw new Meteor.Error(\"You are not logged in.\");\n      } // Be careful not to generate a new token that has a later\n      // expiration than the curren token. Otherwise, a bad guy with a\n      // stolen token could use this method to stop his stolen token from\n      // ever expiring.\n\n\n      const currentHashedToken = accounts._getLoginToken(this.connection.id);\n\n      const currentStampedToken = user.services.resume.loginTokens.find(stampedToken => stampedToken.hashedToken === currentHashedToken);\n\n      if (!currentStampedToken) {\n        // safety belt: this should never happen\n        throw new Meteor.Error(\"Invalid login token\");\n      }\n\n      const newStampedToken = accounts._generateStampedLoginToken();\n\n      newStampedToken.when = currentStampedToken.when;\n\n      accounts._insertLoginToken(this.userId, newStampedToken);\n\n      return accounts._loginUser(this, this.userId, newStampedToken);\n    }; // Removes all tokens except the token associated with the current\n    // connection. Throws an error if the connection is not logged\n    // in. Returns nothing on success.\n\n\n    methods.removeOtherTokens = function () {\n      if (!this.userId) {\n        throw new Meteor.Error(\"You are not logged in.\");\n      }\n\n      const currentToken = accounts._getLoginToken(this.connection.id);\n\n      accounts.users.update(this.userId, {\n        $pull: {\n          \"services.resume.loginTokens\": {\n            hashedToken: {\n              $ne: currentToken\n            }\n          }\n        }\n      });\n    }; // Allow a one-time configuration for a login service. Modifications\n    // to this collection are also allowed in insecure mode.\n\n\n    methods.configureLoginService = options => {\n      check(options, Match.ObjectIncluding({\n        service: String\n      })); // Don't let random users configure a service we haven't added yet (so\n      // that when we do later add it, it's set up with their configuration\n      // instead of ours).\n      // XXX if service configuration is oauth-specific then this code should\n      //     be in accounts-oauth; if it's not then the registry should be\n      //     in this package\n\n      if (!(accounts.oauth && accounts.oauth.serviceNames().includes(options.service))) {\n        throw new Meteor.Error(403, \"Service unknown\");\n      }\n\n      const {\n        ServiceConfiguration\n      } = Package['service-configuration'];\n      if (ServiceConfiguration.configurations.findOne({\n        service: options.service\n      })) throw new Meteor.Error(403, \"Service \".concat(options.service, \" already configured\"));\n      if (hasOwn.call(options, 'secret') && usingOAuthEncryption()) options.secret = OAuthEncryption.seal(options.secret);\n      ServiceConfiguration.configurations.insert(options);\n    };\n\n    accounts._server.methods(methods);\n  }\n\n  _initAccountDataHooks() {\n    this._server.onConnection(connection => {\n      this._accountData[connection.id] = {\n        connection: connection\n      };\n      connection.onClose(() => {\n        this._removeTokenFromConnection(connection.id);\n\n        delete this._accountData[connection.id];\n      });\n    });\n  }\n\n  _initServerPublications() {\n    // Bring into lexical scope for publish callbacks that need `this`\n    const {\n      users,\n      _autopublishFields,\n      _defaultPublishFields\n    } = this; // Publish all login service configuration fields other than secret.\n\n    this._server.publish(\"meteor.loginServiceConfiguration\", () => {\n      const {\n        ServiceConfiguration\n      } = Package['service-configuration'];\n      return ServiceConfiguration.configurations.find({}, {\n        fields: {\n          secret: 0\n        }\n      });\n    }, {\n      is_auto: true\n    }); // not technically autopublish, but stops the warning.\n    // Use Meteor.startup to give other packages a chance to call\n    // setDefaultPublishFields.\n\n\n    Meteor.startup(() => {\n      // Publish the current user's record to the client.\n      this._server.publish(null, function () {\n        if (this.userId) {\n          return users.find({\n            _id: this.userId\n          }, {\n            fields: _defaultPublishFields.projection\n          });\n        } else {\n          return null;\n        }\n      },\n      /*suppress autopublish warning*/\n      {\n        is_auto: true\n      });\n    }); // Use Meteor.startup to give other packages a chance to call\n    // addAutopublishFields.\n\n    Package.autopublish && Meteor.startup(() => {\n      // ['profile', 'username'] -> {profile: 1, username: 1}\n      const toFieldSelector = fields => fields.reduce((prev, field) => _objectSpread(_objectSpread({}, prev), {}, {\n        [field]: 1\n      }), {});\n\n      this._server.publish(null, function () {\n        if (this.userId) {\n          return users.find({\n            _id: this.userId\n          }, {\n            fields: toFieldSelector(_autopublishFields.loggedInUser)\n          });\n        } else {\n          return null;\n        }\n      },\n      /*suppress autopublish warning*/\n      {\n        is_auto: true\n      }); // XXX this publish is neither dedup-able nor is it optimized by our special\n      // treatment of queries on a specific _id. Therefore this will have O(n^2)\n      // run-time performance every time a user document is changed (eg someone\n      // logging in). If this is a problem, we can instead write a manual publish\n      // function which filters out fields based on 'this.userId'.\n\n\n      this._server.publish(null, function () {\n        const selector = this.userId ? {\n          _id: {\n            $ne: this.userId\n          }\n        } : {};\n        return users.find(selector, {\n          fields: toFieldSelector(_autopublishFields.otherUsers)\n        });\n      },\n      /*suppress autopublish warning*/\n      {\n        is_auto: true\n      });\n    });\n  }\n\n  // Add to the list of fields or subfields to be automatically\n  // published if autopublish is on. Must be called from top-level\n  // code (ie, before Meteor.startup hooks run).\n  //\n  // @param opts {Object} with:\n  //   - forLoggedInUser {Array} Array of fields published to the logged-in user\n  //   - forOtherUsers {Array} Array of fields published to users that aren't logged in\n  addAutopublishFields(opts) {\n    this._autopublishFields.loggedInUser.push.apply(this._autopublishFields.loggedInUser, opts.forLoggedInUser);\n\n    this._autopublishFields.otherUsers.push.apply(this._autopublishFields.otherUsers, opts.forOtherUsers);\n  }\n\n  // Replaces the fields to be automatically\n  // published when the user logs in\n  //\n  // @param {MongoFieldSpecifier} fields Dictionary of fields to return or exclude.\n  setDefaultPublishFields(fields) {\n    this._defaultPublishFields.projection = fields;\n  }\n\n  ///\n  /// ACCOUNT DATA\n  ///\n  // HACK: This is used by 'meteor-accounts' to get the loginToken for a\n  // connection. Maybe there should be a public way to do that.\n  _getAccountData(connectionId, field) {\n    const data = this._accountData[connectionId];\n    return data && data[field];\n  }\n\n  _setAccountData(connectionId, field, value) {\n    const data = this._accountData[connectionId]; // safety belt. shouldn't happen. accountData is set in onConnection,\n    // we don't have a connectionId until it is set.\n\n    if (!data) return;\n    if (value === undefined) delete data[field];else data[field] = value;\n  }\n\n  ///\n  /// RECONNECT TOKENS\n  ///\n  /// support reconnecting using a meteor login token\n  _hashLoginToken(loginToken) {\n    const hash = crypto.createHash('sha256');\n    hash.update(loginToken);\n    return hash.digest('base64');\n  }\n\n  // {token, when} => {hashedToken, when}\n  _hashStampedToken(stampedToken) {\n    const {\n      token\n    } = stampedToken,\n          hashedStampedToken = _objectWithoutProperties(stampedToken, _excluded);\n\n    return _objectSpread(_objectSpread({}, hashedStampedToken), {}, {\n      hashedToken: this._hashLoginToken(token)\n    });\n  }\n\n  // Using $addToSet avoids getting an index error if another client\n  // logging in simultaneously has already inserted the new hashed\n  // token.\n  _insertHashedLoginToken(userId, hashedToken, query) {\n    query = query ? _objectSpread({}, query) : {};\n    query._id = userId;\n    this.users.update(query, {\n      $addToSet: {\n        \"services.resume.loginTokens\": hashedToken\n      }\n    });\n  }\n\n  // Exported for tests.\n  _insertLoginToken(userId, stampedToken, query) {\n    this._insertHashedLoginToken(userId, this._hashStampedToken(stampedToken), query);\n  }\n\n  _clearAllLoginTokens(userId) {\n    this.users.update(userId, {\n      $set: {\n        'services.resume.loginTokens': []\n      }\n    });\n  }\n\n  // test hook\n  _getUserObserve(connectionId) {\n    return this._userObservesForConnections[connectionId];\n  }\n\n  // Clean up this connection's association with the token: that is, stop\n  // the observe that we started when we associated the connection with\n  // this token.\n  _removeTokenFromConnection(connectionId) {\n    if (hasOwn.call(this._userObservesForConnections, connectionId)) {\n      const observe = this._userObservesForConnections[connectionId];\n\n      if (typeof observe === 'number') {\n        // We're in the process of setting up an observe for this connection. We\n        // can't clean up that observe yet, but if we delete the placeholder for\n        // this connection, then the observe will get cleaned up as soon as it has\n        // been set up.\n        delete this._userObservesForConnections[connectionId];\n      } else {\n        delete this._userObservesForConnections[connectionId];\n        observe.stop();\n      }\n    }\n  }\n\n  _getLoginToken(connectionId) {\n    return this._getAccountData(connectionId, 'loginToken');\n  }\n\n  // newToken is a hashed token.\n  _setLoginToken(userId, connection, newToken) {\n    this._removeTokenFromConnection(connection.id);\n\n    this._setAccountData(connection.id, 'loginToken', newToken);\n\n    if (newToken) {\n      // Set up an observe for this token. If the token goes away, we need\n      // to close the connection.  We defer the observe because there's\n      // no need for it to be on the critical path for login; we just need\n      // to ensure that the connection will get closed at some point if\n      // the token gets deleted.\n      //\n      // Initially, we set the observe for this connection to a number; this\n      // signifies to other code (which might run while we yield) that we are in\n      // the process of setting up an observe for this connection. Once the\n      // observe is ready to go, we replace the number with the real observe\n      // handle (unless the placeholder has been deleted or replaced by a\n      // different placehold number, signifying that the connection was closed\n      // already -- in this case we just clean up the observe that we started).\n      const myObserveNumber = ++this._nextUserObserveNumber;\n      this._userObservesForConnections[connection.id] = myObserveNumber;\n      Meteor.defer(() => {\n        // If something else happened on this connection in the meantime (it got\n        // closed, or another call to _setLoginToken happened), just do\n        // nothing. We don't need to start an observe for an old connection or old\n        // token.\n        if (this._userObservesForConnections[connection.id] !== myObserveNumber) {\n          return;\n        }\n\n        let foundMatchingUser; // Because we upgrade unhashed login tokens to hashed tokens at\n        // login time, sessions will only be logged in with a hashed\n        // token. Thus we only need to observe hashed tokens here.\n\n        const observe = this.users.find({\n          _id: userId,\n          'services.resume.loginTokens.hashedToken': newToken\n        }, {\n          fields: {\n            _id: 1\n          }\n        }).observeChanges({\n          added: () => {\n            foundMatchingUser = true;\n          },\n          removed: connection.close // The onClose callback for the connection takes care of\n          // cleaning up the observe handle and any other state we have\n          // lying around.\n\n        }, {\n          nonMutatingCallbacks: true\n        }); // If the user ran another login or logout command we were waiting for the\n        // defer or added to fire (ie, another call to _setLoginToken occurred),\n        // then we let the later one win (start an observe, etc) and just stop our\n        // observe now.\n        //\n        // Similarly, if the connection was already closed, then the onClose\n        // callback would have called _removeTokenFromConnection and there won't\n        // be an entry in _userObservesForConnections. We can stop the observe.\n\n        if (this._userObservesForConnections[connection.id] !== myObserveNumber) {\n          observe.stop();\n          return;\n        }\n\n        this._userObservesForConnections[connection.id] = observe;\n\n        if (!foundMatchingUser) {\n          // We've set up an observe on the user associated with `newToken`,\n          // so if the new token is removed from the database, we'll close\n          // the connection. But the token might have already been deleted\n          // before we set up the observe, which wouldn't have closed the\n          // connection because the observe wasn't running yet.\n          connection.close();\n        }\n      });\n    }\n  }\n\n  // (Also used by Meteor Accounts server and tests).\n  //\n  _generateStampedLoginToken() {\n    return {\n      token: Random.secret(),\n      when: new Date()\n    };\n  }\n\n  ///\n  /// TOKEN EXPIRATION\n  ///\n  // Deletes expired password reset tokens from the database.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n  _expirePasswordResetTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getPasswordResetTokenLifetimeMs(); // when calling from a test with extra arguments, you must specify both!\n\n\n    if (oldestValidDate && !userId || !oldestValidDate && userId) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate || new Date(new Date() - tokenLifetimeMs);\n    const tokenFilter = {\n      $or: [{\n        \"services.password.reset.reason\": \"reset\"\n      }, {\n        \"services.password.reset.reason\": {\n          $exists: false\n        }\n      }]\n    };\n    expirePasswordToken(this, oldestValidDate, tokenFilter, userId);\n  } // Deletes expired password enroll tokens from the database.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n\n\n  _expirePasswordEnrollTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getPasswordEnrollTokenLifetimeMs(); // when calling from a test with extra arguments, you must specify both!\n\n\n    if (oldestValidDate && !userId || !oldestValidDate && userId) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate || new Date(new Date() - tokenLifetimeMs);\n    const tokenFilter = {\n      \"services.password.enroll.reason\": \"enroll\"\n    };\n    expirePasswordToken(this, oldestValidDate, tokenFilter, userId);\n  } // Deletes expired tokens from the database and closes all open connections\n  // associated with these tokens.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n\n\n  _expireTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getTokenLifetimeMs(); // when calling from a test with extra arguments, you must specify both!\n\n\n    if (oldestValidDate && !userId || !oldestValidDate && userId) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate || new Date(new Date() - tokenLifetimeMs);\n    const userFilter = userId ? {\n      _id: userId\n    } : {}; // Backwards compatible with older versions of meteor that stored login token\n    // timestamps as numbers.\n\n    this.users.update(_objectSpread(_objectSpread({}, userFilter), {}, {\n      $or: [{\n        \"services.resume.loginTokens.when\": {\n          $lt: oldestValidDate\n        }\n      }, {\n        \"services.resume.loginTokens.when\": {\n          $lt: +oldestValidDate\n        }\n      }]\n    }), {\n      $pull: {\n        \"services.resume.loginTokens\": {\n          $or: [{\n            when: {\n              $lt: oldestValidDate\n            }\n          }, {\n            when: {\n              $lt: +oldestValidDate\n            }\n          }]\n        }\n      }\n    }, {\n      multi: true\n    }); // The observe on Meteor.users will take care of closing connections for\n    // expired tokens.\n  }\n\n  // @override from accounts_common.js\n  config(options) {\n    // Call the overridden implementation of the method.\n    const superResult = AccountsCommon.prototype.config.apply(this, arguments); // If the user set loginExpirationInDays to null, then we need to clear the\n    // timer that periodically expires tokens.\n\n    if (hasOwn.call(this._options, 'loginExpirationInDays') && this._options.loginExpirationInDays === null && this.expireTokenInterval) {\n      Meteor.clearInterval(this.expireTokenInterval);\n      this.expireTokenInterval = null;\n    }\n\n    return superResult;\n  }\n\n  // Called by accounts-password\n  insertUserDoc(options, user) {\n    // - clone user document, to protect from modification\n    // - add createdAt timestamp\n    // - prepare an _id, so that you can modify other collections (eg\n    // create a first task for every new user)\n    //\n    // XXX If the onCreateUser or validateNewUser hooks fail, we might\n    // end up having modified some other collection\n    // inappropriately. The solution is probably to have onCreateUser\n    // accept two callbacks - one that gets called before inserting\n    // the user document (in which you can modify its contents), and\n    // one that gets called after (in which you should change other\n    // collections)\n    user = _objectSpread({\n      createdAt: new Date(),\n      _id: Random.id()\n    }, user);\n\n    if (user.services) {\n      Object.keys(user.services).forEach(service => pinEncryptedFieldsToUser(user.services[service], user._id));\n    }\n\n    let fullUser;\n\n    if (this._onCreateUserHook) {\n      fullUser = this._onCreateUserHook(options, user); // This is *not* part of the API. We need this because we can't isolate\n      // the global server environment between tests, meaning we can't test\n      // both having a create user hook set and not having one set.\n\n      if (fullUser === 'TEST DEFAULT HOOK') fullUser = defaultCreateUserHook(options, user);\n    } else {\n      fullUser = defaultCreateUserHook(options, user);\n    }\n\n    this._validateNewUserHooks.forEach(hook => {\n      if (!hook(fullUser)) throw new Meteor.Error(403, \"User validation failed\");\n    });\n\n    let userId;\n\n    try {\n      userId = this.users.insert(fullUser);\n    } catch (e) {\n      // XXX string parsing sucks, maybe\n      // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\n      // https://jira.mongodb.org/browse/SERVER-4637\n      if (!e.errmsg) throw e;\n      if (e.errmsg.includes('emails.address')) throw new Meteor.Error(403, \"Email already exists.\");\n      if (e.errmsg.includes('username')) throw new Meteor.Error(403, \"Username already exists.\");\n      throw e;\n    }\n\n    return userId;\n  }\n\n  // Helper function: returns false if email does not match company domain from\n  // the configuration.\n  _testEmailDomain(email) {\n    const domain = this._options.restrictCreationByEmailDomain;\n    return !domain || typeof domain === 'function' && domain(email) || typeof domain === 'string' && new RegExp(\"@\".concat(Meteor._escapeRegExp(domain), \"$\"), 'i').test(email);\n  }\n\n  ///\n  /// CLEAN UP FOR `logoutOtherClients`\n  ///\n  _deleteSavedTokensForUser(userId, tokensToDelete) {\n    if (tokensToDelete) {\n      this.users.update(userId, {\n        $unset: {\n          \"services.resume.haveLoginTokensToDelete\": 1,\n          \"services.resume.loginTokensToDelete\": 1\n        },\n        $pullAll: {\n          \"services.resume.loginTokens\": tokensToDelete\n        }\n      });\n    }\n  }\n\n  _deleteSavedTokensForAllUsersOnStartup() {\n    // If we find users who have saved tokens to delete on startup, delete\n    // them now. It's possible that the server could have crashed and come\n    // back up before new tokens are found in localStorage, but this\n    // shouldn't happen very often. We shouldn't put a delay here because\n    // that would give a lot of power to an attacker with a stolen login\n    // token and the ability to crash the server.\n    Meteor.startup(() => {\n      this.users.find({\n        \"services.resume.haveLoginTokensToDelete\": true\n      }, {\n        fields: {\n          \"services.resume.loginTokensToDelete\": 1\n        }\n      }).forEach(user => {\n        this._deleteSavedTokensForUser(user._id, user.services.resume.loginTokensToDelete);\n      });\n    });\n  }\n\n  ///\n  /// MANAGING USER OBJECTS\n  ///\n  // Updates or creates a user after we authenticate with a 3rd party.\n  //\n  // @param serviceName {String} Service name (eg, twitter).\n  // @param serviceData {Object} Data to store in the user's record\n  //        under services[serviceName]. Must include an \"id\" field\n  //        which is a unique identifier for the user in the service.\n  // @param options {Object, optional} Other options to pass to insertUserDoc\n  //        (eg, profile)\n  // @returns {Object} Object with token and id keys, like the result\n  //        of the \"login\" method.\n  //\n  updateOrCreateUserFromExternalService(serviceName, serviceData, options) {\n    options = _objectSpread({}, options);\n\n    if (serviceName === \"password\" || serviceName === \"resume\") {\n      throw new Error(\"Can't use updateOrCreateUserFromExternalService with internal service \" + serviceName);\n    }\n\n    if (!hasOwn.call(serviceData, 'id')) {\n      throw new Error(\"Service data for service \".concat(serviceName, \" must include id\"));\n    } // Look for a user with the appropriate service user id.\n\n\n    const selector = {};\n    const serviceIdKey = \"services.\".concat(serviceName, \".id\"); // XXX Temporary special case for Twitter. (Issue #629)\n    //   The serviceData.id will be a string representation of an integer.\n    //   We want it to match either a stored string or int representation.\n    //   This is to cater to earlier versions of Meteor storing twitter\n    //   user IDs in number form, and recent versions storing them as strings.\n    //   This can be removed once migration technology is in place, and twitter\n    //   users stored with integer IDs have been migrated to string IDs.\n\n    if (serviceName === \"twitter\" && !isNaN(serviceData.id)) {\n      selector[\"$or\"] = [{}, {}];\n      selector[\"$or\"][0][serviceIdKey] = serviceData.id;\n      selector[\"$or\"][1][serviceIdKey] = parseInt(serviceData.id, 10);\n    } else {\n      selector[serviceIdKey] = serviceData.id;\n    }\n\n    let user = this.users.findOne(selector, {\n      fields: this._options.defaultFieldSelector\n    }); // Check to see if the developer has a custom way to find the user outside\n    // of the general selectors above.\n\n    if (!user && this._additionalFindUserOnExternalLogin) {\n      user = this._additionalFindUserOnExternalLogin({\n        serviceName,\n        serviceData,\n        options\n      });\n    } // Before continuing, run user hook to see if we should continue\n\n\n    if (this._beforeExternalLoginHook && !this._beforeExternalLoginHook(serviceName, serviceData, user)) {\n      throw new Meteor.Error(403, \"Login forbidden\");\n    } // When creating a new user we pass through all options. When updating an\n    // existing user, by default we only process/pass through the serviceData\n    // (eg, so that we keep an unexpired access token and don't cache old email\n    // addresses in serviceData.email). The onExternalLogin hook can be used when\n    // creating or updating a user, to modify or pass through more options as\n    // needed.\n\n\n    let opts = user ? {} : options;\n\n    if (this._onExternalLoginHook) {\n      opts = this._onExternalLoginHook(options, user);\n    }\n\n    if (user) {\n      pinEncryptedFieldsToUser(serviceData, user._id);\n      let setAttrs = {};\n      Object.keys(serviceData).forEach(key => setAttrs[\"services.\".concat(serviceName, \".\").concat(key)] = serviceData[key]); // XXX Maybe we should re-use the selector above and notice if the update\n      //     touches nothing?\n\n      setAttrs = _objectSpread(_objectSpread({}, setAttrs), opts);\n      this.users.update(user._id, {\n        $set: setAttrs\n      });\n      return {\n        type: serviceName,\n        userId: user._id\n      };\n    } else {\n      // Create a new user with the service data.\n      user = {\n        services: {}\n      };\n      user.services[serviceName] = serviceData;\n      return {\n        type: serviceName,\n        userId: this.insertUserDoc(opts, user)\n      };\n    }\n  }\n\n  // Removes default rate limiting rule\n  removeDefaultRateLimit() {\n    const resp = DDPRateLimiter.removeRule(this.defaultRateLimiterRuleId);\n    this.defaultRateLimiterRuleId = null;\n    return resp;\n  }\n\n  // Add a default rule of limiting logins, creating new users and password reset\n  // to 5 times every 10 seconds per connection.\n  addDefaultRateLimit() {\n    if (!this.defaultRateLimiterRuleId) {\n      this.defaultRateLimiterRuleId = DDPRateLimiter.addRule({\n        userId: null,\n        clientAddress: null,\n        type: 'method',\n        name: name => ['login', 'createUser', 'resetPassword', 'forgotPassword'].includes(name),\n        connectionId: connectionId => true\n      }, 5, 10000);\n    }\n  }\n\n  /**\n   * @summary Creates options for email sending for reset password and enroll account emails.\n   * You can use this function when customizing a reset password or enroll account email sending.\n   * @locus Server\n   * @param {Object} email Which address of the user's to send the email to.\n   * @param {Object} user The user object to generate options for.\n   * @param {String} url URL to which user is directed to confirm the email.\n   * @param {String} reason `resetPassword` or `enrollAccount`.\n   * @returns {Object} Options which can be passed to `Email.send`.\n   * @importFromPackage accounts-base\n   */\n  generateOptionsForEmail(email, user, url, reason) {\n    let extra = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const options = {\n      to: email,\n      from: this.emailTemplates[reason].from ? this.emailTemplates[reason].from(user) : this.emailTemplates.from,\n      subject: this.emailTemplates[reason].subject(user, url, extra)\n    };\n\n    if (typeof this.emailTemplates[reason].text === 'function') {\n      options.text = this.emailTemplates[reason].text(user, url, extra);\n    }\n\n    if (typeof this.emailTemplates[reason].html === 'function') {\n      options.html = this.emailTemplates[reason].html(user, url, extra);\n    }\n\n    if (typeof this.emailTemplates.headers === 'object') {\n      options.headers = this.emailTemplates.headers;\n    }\n\n    return options;\n  }\n\n  _checkForCaseInsensitiveDuplicates(fieldName, displayName, fieldValue, ownUserId) {\n    // Some tests need the ability to add users with the same case insensitive\n    // value, hence the _skipCaseInsensitiveChecksForTest check\n    const skipCheck = Object.prototype.hasOwnProperty.call(this._skipCaseInsensitiveChecksForTest, fieldValue);\n\n    if (fieldValue && !skipCheck) {\n      const matchedUsers = Meteor.users.find(this._selectorForFastCaseInsensitiveLookup(fieldName, fieldValue), {\n        fields: {\n          _id: 1\n        },\n        // we only need a maximum of 2 users for the logic below to work\n        limit: 2\n      }).fetch();\n\n      if (matchedUsers.length > 0 && ( // If we don't have a userId yet, any match we find is a duplicate\n      !ownUserId || // Otherwise, check to see if there are multiple matches or a match\n      // that is not us\n      matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId)) {\n        this._handleError(\"\".concat(displayName, \" already exists.\"));\n      }\n    }\n  }\n\n  _createUserCheckingDuplicates(_ref) {\n    let {\n      user,\n      email,\n      username,\n      options\n    } = _ref;\n\n    const newUser = _objectSpread(_objectSpread(_objectSpread({}, user), username ? {\n      username\n    } : {}), email ? {\n      emails: [{\n        address: email,\n        verified: false\n      }]\n    } : {}); // Perform a case insensitive check before insert\n\n\n    this._checkForCaseInsensitiveDuplicates('username', 'Username', username);\n\n    this._checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n\n    const userId = this.insertUserDoc(options, newUser); // Perform another check after insert, in case a matching user has been\n    // inserted in the meantime\n\n    try {\n      this._checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n\n      this._checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n    } catch (ex) {\n      // Remove inserted user if the check fails\n      Meteor.users.remove(userId);\n      throw ex;\n    }\n\n    return userId;\n  }\n\n}\n\n// Give each login hook callback a fresh cloned copy of the attempt\n// object, but don't clone the connection.\n//\nconst cloneAttemptWithConnection = (connection, attempt) => {\n  const clonedAttempt = EJSON.clone(attempt);\n  clonedAttempt.connection = connection;\n  return clonedAttempt;\n};\n\nconst tryLoginMethod = (type, fn) => {\n  let result;\n\n  try {\n    result = fn();\n  } catch (e) {\n    result = {\n      error: e\n    };\n  }\n\n  if (result && !result.type && type) result.type = type;\n  return result;\n};\n\nconst setupDefaultLoginHandlers = accounts => {\n  accounts.registerLoginHandler(\"resume\", function (options) {\n    return defaultResumeLoginHandler.call(this, accounts, options);\n  });\n}; // Login handler for resume tokens.\n\n\nconst defaultResumeLoginHandler = (accounts, options) => {\n  if (!options.resume) return undefined;\n  check(options.resume, String);\n\n  const hashedToken = accounts._hashLoginToken(options.resume); // First look for just the new-style hashed login token, to avoid\n  // sending the unhashed token to the database in a query if we don't\n  // need to.\n\n\n  let user = accounts.users.findOne({\n    \"services.resume.loginTokens.hashedToken\": hashedToken\n  }, {\n    fields: {\n      \"services.resume.loginTokens.$\": 1\n    }\n  });\n\n  if (!user) {\n    // If we didn't find the hashed login token, try also looking for\n    // the old-style unhashed token.  But we need to look for either\n    // the old-style token OR the new-style token, because another\n    // client connection logging in simultaneously might have already\n    // converted the token.\n    user = accounts.users.findOne({\n      $or: [{\n        \"services.resume.loginTokens.hashedToken\": hashedToken\n      }, {\n        \"services.resume.loginTokens.token\": options.resume\n      }]\n    }, // Note: Cannot use ...loginTokens.$ positional operator with $or query.\n    {\n      fields: {\n        \"services.resume.loginTokens\": 1\n      }\n    });\n  }\n\n  if (!user) return {\n    error: new Meteor.Error(403, \"You've been logged out by the server. Please log in again.\")\n  }; // Find the token, which will either be an object with fields\n  // {hashedToken, when} for a hashed token or {token, when} for an\n  // unhashed token.\n\n  let oldUnhashedStyleToken;\n  let token = user.services.resume.loginTokens.find(token => token.hashedToken === hashedToken);\n\n  if (token) {\n    oldUnhashedStyleToken = false;\n  } else {\n    token = user.services.resume.loginTokens.find(token => token.token === options.resume);\n    oldUnhashedStyleToken = true;\n  }\n\n  const tokenExpires = accounts._tokenExpiration(token.when);\n\n  if (new Date() >= tokenExpires) return {\n    userId: user._id,\n    error: new Meteor.Error(403, \"Your session has expired. Please log in again.\")\n  }; // Update to a hashed token when an unhashed token is encountered.\n\n  if (oldUnhashedStyleToken) {\n    // Only add the new hashed token if the old unhashed token still\n    // exists (this avoids resurrecting the token if it was deleted\n    // after we read it).  Using $addToSet avoids getting an index\n    // error if another client logging in simultaneously has already\n    // inserted the new hashed token.\n    accounts.users.update({\n      _id: user._id,\n      \"services.resume.loginTokens.token\": options.resume\n    }, {\n      $addToSet: {\n        \"services.resume.loginTokens\": {\n          \"hashedToken\": hashedToken,\n          \"when\": token.when\n        }\n      }\n    }); // Remove the old token *after* adding the new, since otherwise\n    // another client trying to login between our removing the old and\n    // adding the new wouldn't find a token to login with.\n\n    accounts.users.update(user._id, {\n      $pull: {\n        \"services.resume.loginTokens\": {\n          \"token\": options.resume\n        }\n      }\n    });\n  }\n\n  return {\n    userId: user._id,\n    stampedLoginToken: {\n      token: options.resume,\n      when: token.when\n    }\n  };\n};\n\nconst expirePasswordToken = (accounts, oldestValidDate, tokenFilter, userId) => {\n  // boolean value used to determine if this method was called from enroll account workflow\n  let isEnroll = false;\n  const userFilter = userId ? {\n    _id: userId\n  } : {}; // check if this method was called from enroll account workflow\n\n  if (tokenFilter['services.password.enroll.reason']) {\n    isEnroll = true;\n  }\n\n  let resetRangeOr = {\n    $or: [{\n      \"services.password.reset.when\": {\n        $lt: oldestValidDate\n      }\n    }, {\n      \"services.password.reset.when\": {\n        $lt: +oldestValidDate\n      }\n    }]\n  };\n\n  if (isEnroll) {\n    resetRangeOr = {\n      $or: [{\n        \"services.password.enroll.when\": {\n          $lt: oldestValidDate\n        }\n      }, {\n        \"services.password.enroll.when\": {\n          $lt: +oldestValidDate\n        }\n      }]\n    };\n  }\n\n  const expireFilter = {\n    $and: [tokenFilter, resetRangeOr]\n  };\n\n  if (isEnroll) {\n    accounts.users.update(_objectSpread(_objectSpread({}, userFilter), expireFilter), {\n      $unset: {\n        \"services.password.enroll\": \"\"\n      }\n    }, {\n      multi: true\n    });\n  } else {\n    accounts.users.update(_objectSpread(_objectSpread({}, userFilter), expireFilter), {\n      $unset: {\n        \"services.password.reset\": \"\"\n      }\n    }, {\n      multi: true\n    });\n  }\n};\n\nconst setExpireTokensInterval = accounts => {\n  accounts.expireTokenInterval = Meteor.setInterval(() => {\n    accounts._expireTokens();\n\n    accounts._expirePasswordResetTokens();\n\n    accounts._expirePasswordEnrollTokens();\n  }, EXPIRE_TOKENS_INTERVAL_MS);\n}; ///\n/// OAuth Encryption Support\n///\n\n\nconst OAuthEncryption = Package[\"oauth-encryption\"] && Package[\"oauth-encryption\"].OAuthEncryption;\n\nconst usingOAuthEncryption = () => {\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();\n}; // OAuth service data is temporarily stored in the pending credentials\n// collection during the oauth authentication process.  Sensitive data\n// such as access tokens are encrypted without the user id because\n// we don't know the user id yet.  We re-encrypt these fields with the\n// user id included when storing the service data permanently in\n// the users collection.\n//\n\n\nconst pinEncryptedFieldsToUser = (serviceData, userId) => {\n  Object.keys(serviceData).forEach(key => {\n    let value = serviceData[key];\n    if (OAuthEncryption && OAuthEncryption.isSealed(value)) value = OAuthEncryption.seal(OAuthEncryption.open(value), userId);\n    serviceData[key] = value;\n  });\n}; // Encrypt unencrypted login service secrets when oauth-encryption is\n// added.\n//\n// XXX For the oauthSecretKey to be available here at startup, the\n// developer must call Accounts.config({oauthSecretKey: ...}) at load\n// time, instead of in a Meteor.startup block, because the startup\n// block in the app code will run after this accounts-base startup\n// block.  Perhaps we need a post-startup callback?\n\n\nMeteor.startup(() => {\n  if (!usingOAuthEncryption()) {\n    return;\n  }\n\n  const {\n    ServiceConfiguration\n  } = Package['service-configuration'];\n  ServiceConfiguration.configurations.find({\n    $and: [{\n      secret: {\n        $exists: true\n      }\n    }, {\n      \"secret.algorithm\": {\n        $exists: false\n      }\n    }]\n  }).forEach(config => {\n    ServiceConfiguration.configurations.update(config._id, {\n      $set: {\n        secret: OAuthEncryption.seal(config.secret)\n      }\n    });\n  });\n}); // XXX see comment on Accounts.createUser in passwords_server about adding a\n// second \"server options\" argument.\n\nconst defaultCreateUserHook = (options, user) => {\n  if (options.profile) user.profile = options.profile;\n  return user;\n}; // Validate new user's email or Google/Facebook/GitHub account's email\n\n\nfunction defaultValidateNewUserHook(user) {\n  const domain = this._options.restrictCreationByEmailDomain;\n\n  if (!domain) {\n    return true;\n  }\n\n  let emailIsGood = false;\n\n  if (user.emails && user.emails.length > 0) {\n    emailIsGood = user.emails.reduce((prev, email) => prev || this._testEmailDomain(email.address), false);\n  } else if (user.services && Object.values(user.services).length > 0) {\n    // Find any email of any service and check it\n    emailIsGood = Object.values(user.services).reduce((prev, service) => service.email && this._testEmailDomain(service.email), false);\n  }\n\n  if (emailIsGood) {\n    return true;\n  }\n\n  if (typeof domain === 'string') {\n    throw new Meteor.Error(403, \"@\".concat(domain, \" email required\"));\n  } else {\n    throw new Meteor.Error(403, \"Email doesn't match the criteria.\");\n  }\n}\n\nconst setupUsersCollection = users => {\n  ///\n  /// RESTRICTING WRITES TO USER OBJECTS\n  ///\n  users.allow({\n    // clients can modify the profile field of their own document, and\n    // nothing else.\n    update: (userId, user, fields, modifier) => {\n      // make sure it is our record\n      if (user._id !== userId) {\n        return false;\n      } // user can only modify the 'profile' field. sets to multiple\n      // sub-keys (eg profile.foo and profile.bar) are merged into entry\n      // in the fields list.\n\n\n      if (fields.length !== 1 || fields[0] !== 'profile') {\n        return false;\n      }\n\n      return true;\n    },\n    fetch: ['_id'] // we only look at _id.\n\n  }); /// DEFAULT INDEXES ON USERS\n\n  users.createIndex('username', {\n    unique: true,\n    sparse: true\n  });\n  users.createIndex('emails.address', {\n    unique: true,\n    sparse: true\n  });\n  users.createIndex('services.resume.loginTokens.hashedToken', {\n    unique: true,\n    sparse: true\n  });\n  users.createIndex('services.resume.loginTokens.token', {\n    unique: true,\n    sparse: true\n  }); // For taking care of logoutOtherClients calls that crashed before the\n  // tokens were deleted.\n\n  users.createIndex('services.resume.haveLoginTokensToDelete', {\n    sparse: true\n  }); // For expiring login tokens\n\n  users.createIndex(\"services.resume.loginTokens.when\", {\n    sparse: true\n  }); // For expiring password tokens\n\n  users.createIndex('services.password.reset.when', {\n    sparse: true\n  });\n  users.createIndex('services.password.enroll.when', {\n    sparse: true\n  });\n}; // Generates permutations of all case variations of a given string.\n\n\nconst generateCasePermutationsForString = string => {\n  let permutations = [''];\n\n  for (let i = 0; i < string.length; i++) {\n    const ch = string.charAt(i);\n    permutations = [].concat(...permutations.map(prefix => {\n      const lowerCaseChar = ch.toLowerCase();\n      const upperCaseChar = ch.toUpperCase(); // Don't add unnecessary permutations when ch is not a letter\n\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    }));\n  }\n\n  return permutations;\n};","map":{"version":3,"sources":["packages/accounts-base/accounts_server.js"],"names":["_objectWithoutProperties","module","link","default","v","_objectSpread","export","AccountsServer","crypto","AccountsCommon","EXPIRE_TOKENS_INTERVAL_MS","URL","hasOwn","Object","prototype","hasOwnProperty","NonEmptyString","Match","Where","x","check","String","length","constructor","server","onCreateLoginToken","func","_onCreateLoginTokenHook","Error","_selectorForFastCaseInsensitiveLookup","fieldName","string","prefix","substring","Math","min","orClause","generateCasePermutationsForString","map","prefixPermutation","selector","RegExp","Meteor","_escapeRegExp","caseInsensitiveClause","$and","$or","_findUserByQuery","query","options","user","id","users","findOne","_addDefaultFieldSelector","fieldValue","username","email","candidateUsers","find","fetch","_handleError","msg","throwError","error","_options","ambiguousErrorMessages","_userQueryValidator","Optional","keys","_server","_initServerMethods","_initAccountDataHooks","_autopublishFields","loggedInUser","otherUsers","_defaultPublishFields","projection","profile","emails","_initServerPublications","_accountData","_userObservesForConnections","_nextUserObserveNumber","_loginHandlers","setupUsersCollection","setupDefaultLoginHandlers","setExpireTokensInterval","_validateLoginHook","Hook","bindEnvironment","_validateNewUserHooks","defaultValidateNewUserHook","bind","_deleteSavedTokensForAllUsersOnStartup","_skipCaseInsensitiveChecksForTest","urls","resetPassword","token","extraParams","buildEmailUrl","verifyEmail","loginToken","enrollAccount","addDefaultRateLimit","path","url","absoluteUrl","params","entries","key","value","searchParams","append","toString","userId","currentInvocation","DDP","_CurrentMethodInvocation","get","_CurrentPublicationInvocation","validateLoginAttempt","register","validateNewUser","push","beforeExternalLogin","_beforeExternalLoginHook","onCreateUser","_onCreateUserHook","onExternalLogin","_onExternalLoginHook","setAdditionalFindUserOnExternalLogin","_additionalFindUserOnExternalLogin","_validateLogin","connection","attempt","each","callback","ret","cloneAttemptWithConnection","e","allowed","_successfulLogin","_onLoginHook","_failedLogin","_onLoginFailureHook","_successfulLogout","_onLogoutHook","fields","defaultFieldSelector","_loginUser","methodInvocation","stampedLoginToken","_generateStampedLoginToken","_insertLoginToken","_noYieldsAllowed","_setLoginToken","_hashLoginToken","setUserId","tokenExpires","_tokenExpiration","when","_attemptLogin","methodName","methodArgs","result","type","methodArguments","Array","from","_loginMethod","fn","tryLoginMethod","_reportLoginFailure","registerLoginHandler","name","handler","_runLoginHandlers","call","undefined","destroyToken","update","$pull","hashedToken","accounts","methods","login","arguments","logout","_getLoginToken","getNewToken","currentHashedToken","currentStampedToken","services","resume","loginTokens","stampedToken","newStampedToken","removeOtherTokens","currentToken","$ne","configureLoginService","ObjectIncluding","service","oauth","serviceNames","includes","ServiceConfiguration","Package","configurations","usingOAuthEncryption","secret","OAuthEncryption","seal","insert","onConnection","onClose","_removeTokenFromConnection","publish","is_auto","startup","_id","autopublish","toFieldSelector","reduce","prev","field","addAutopublishFields","opts","apply","forLoggedInUser","forOtherUsers","setDefaultPublishFields","_getAccountData","connectionId","data","_setAccountData","hash","createHash","digest","_hashStampedToken","hashedStampedToken","_insertHashedLoginToken","$addToSet","_clearAllLoginTokens","$set","_getUserObserve","observe","stop","newToken","myObserveNumber","defer","foundMatchingUser","observeChanges","added","removed","close","nonMutatingCallbacks","Random","Date","_expirePasswordResetTokens","oldestValidDate","tokenLifetimeMs","_getPasswordResetTokenLifetimeMs","tokenFilter","$exists","expirePasswordToken","_expirePasswordEnrollTokens","_getPasswordEnrollTokenLifetimeMs","_expireTokens","_getTokenLifetimeMs","userFilter","$lt","multi","config","superResult","loginExpirationInDays","expireTokenInterval","clearInterval","insertUserDoc","createdAt","forEach","pinEncryptedFieldsToUser","fullUser","defaultCreateUserHook","hook","errmsg","_testEmailDomain","domain","restrictCreationByEmailDomain","test","_deleteSavedTokensForUser","tokensToDelete","$unset","$pullAll","loginTokensToDelete","updateOrCreateUserFromExternalService","serviceName","serviceData","serviceIdKey","isNaN","parseInt","setAttrs","removeDefaultRateLimit","resp","DDPRateLimiter","removeRule","defaultRateLimiterRuleId","addRule","clientAddress","generateOptionsForEmail","reason","extra","to","emailTemplates","subject","text","html","headers","_checkForCaseInsensitiveDuplicates","displayName","ownUserId","skipCheck","matchedUsers","limit","_createUserCheckingDuplicates","newUser","address","verified","ex","remove","clonedAttempt","EJSON","clone","defaultResumeLoginHandler","oldUnhashedStyleToken","isEnroll","resetRangeOr","expireFilter","setInterval","keyIsLoaded","isSealed","open","emailIsGood","values","allow","modifier","createIndex","unique","sparse","permutations","i","ch","charAt","concat","lowerCaseChar","toLowerCase","upperCaseChar","toUpperCase"],"mappings":";;AAAA,IAAIA,wBAAJ;;AAA6BC,MAAM,CAACC,IAAP,CAAY,gDAAZ,EAA6D;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACJ,IAAAA,wBAAwB,GAACI,CAAzB;AAA2B;;AAAvC,CAA7D,EAAsG,CAAtG;;AAAyG,IAAIC,aAAJ;;AAAkBJ,MAAM,CAACC,IAAP,CAAY,sCAAZ,EAAmD;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACC,IAAAA,aAAa,GAACD,CAAd;AAAgB;;AAA5B,CAAnD,EAAiF,CAAjF;AAAxJH,MAAM,CAACK,MAAP,CAAc;AAACC,EAAAA,cAAc,EAAC,MAAIA;AAApB,CAAd;AAAmD,IAAIC,MAAJ;AAAWP,MAAM,CAACC,IAAP,CAAY,QAAZ,EAAqB;AAACC,EAAAA,OAAO,CAACC,CAAD,EAAG;AAACI,IAAAA,MAAM,GAACJ,CAAP;AAAS;;AAArB,CAArB,EAA4C,CAA5C;AAA+C,IAAIK,cAAJ,EAAmBC,yBAAnB;AAA6CT,MAAM,CAACC,IAAP,CAAY,sBAAZ,EAAmC;AAACO,EAAAA,cAAc,CAACL,CAAD,EAAG;AAACK,IAAAA,cAAc,GAACL,CAAf;AAAiB,GAApC;;AAAqCM,EAAAA,yBAAyB,CAACN,CAAD,EAAG;AAACM,IAAAA,yBAAyB,GAACN,CAA1B;AAA4B;;AAA9F,CAAnC,EAAmI,CAAnI;AAAsI,IAAIO,GAAJ;AAAQV,MAAM,CAACC,IAAP,CAAY,YAAZ,EAAyB;AAACS,EAAAA,GAAG,CAACP,CAAD,EAAG;AAACO,IAAAA,GAAG,GAACP,CAAJ;AAAM;;AAAd,CAAzB,EAAyC,CAAzC;AAOxS,MAAMQ,MAAM,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAAhC,C,CAEA;;AACA,MAAMC,cAAc,GAAGC,KAAK,CAACC,KAAN,CAAYC,CAAC,IAAI;AACtCC,EAAAA,KAAK,CAACD,CAAD,EAAIE,MAAJ,CAAL;AACA,SAAOF,CAAC,CAACG,MAAF,GAAW,CAAlB;AACD,CAHsB,CAAvB;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACO,MAAMf,cAAN,SAA6BE,cAA7B,CAA4C;AACjD;AACA;AACA;AACAc,EAAAA,WAAW,CAACC,MAAD,EAAS;AAAA;;AAClB,WADkB;AAAA;;AAAA,SAkJpBC,kBAlJoB,GAkJC,UAASC,IAAT,EAAe;AAClC,UAAI,KAAKC,uBAAT,EAAkC;AAChC,cAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;AACD;;AAED,WAAKD,uBAAL,GAA+BD,IAA/B;AACD,KAxJmB;;AAAA,SA4PpBG,qCA5PoB,GA4PoB,CAACC,SAAD,EAAYC,MAAZ,KAAuB;AAC7D;AACA,YAAMC,MAAM,GAAGD,MAAM,CAACE,SAAP,CAAiB,CAAjB,EAAoBC,IAAI,CAACC,GAAL,CAASJ,MAAM,CAACT,MAAhB,EAAwB,CAAxB,CAApB,CAAf;AACA,YAAMc,QAAQ,GAAGC,iCAAiC,CAACL,MAAD,CAAjC,CAA0CM,GAA1C,CACbC,iBAAiB,IAAI;AACnB,cAAMC,QAAQ,GAAG,EAAjB;AACAA,QAAAA,QAAQ,CAACV,SAAD,CAAR,GACI,IAAIW,MAAJ,YAAeC,MAAM,CAACC,aAAP,CAAqBJ,iBAArB,CAAf,EADJ;AAEA,eAAOC,QAAP;AACD,OANY,CAAjB;AAOA,YAAMI,qBAAqB,GAAG,EAA9B;AACAA,MAAAA,qBAAqB,CAACd,SAAD,CAArB,GACI,IAAIW,MAAJ,YAAeC,MAAM,CAACC,aAAP,CAAqBZ,MAArB,CAAf,QAAgD,GAAhD,CADJ;AAEA,aAAO;AAACc,QAAAA,IAAI,EAAE,CAAC;AAACC,UAAAA,GAAG,EAAEV;AAAN,SAAD,EAAkBQ,qBAAlB;AAAP,OAAP;AACD,KA1QmB;;AAAA,SA4QpBG,gBA5QoB,GA4QD,CAACC,KAAD,EAAQC,OAAR,KAAoB;AACrC,UAAIC,IAAI,GAAG,IAAX;;AAEA,UAAIF,KAAK,CAACG,EAAV,EAAc;AACZ;AACAD,QAAAA,IAAI,GAAGR,MAAM,CAACU,KAAP,CAAaC,OAAb,CAAqBL,KAAK,CAACG,EAA3B,EAA+B,KAAKG,wBAAL,CAA8BL,OAA9B,CAA/B,CAAP;AACD,OAHD,MAGO;AACLA,QAAAA,OAAO,GAAG,KAAKK,wBAAL,CAA8BL,OAA9B,CAAV;AACA,YAAInB,SAAJ;AACA,YAAIyB,UAAJ;;AACA,YAAIP,KAAK,CAACQ,QAAV,EAAoB;AAClB1B,UAAAA,SAAS,GAAG,UAAZ;AACAyB,UAAAA,UAAU,GAAGP,KAAK,CAACQ,QAAnB;AACD,SAHD,MAGO,IAAIR,KAAK,CAACS,KAAV,EAAiB;AACtB3B,UAAAA,SAAS,GAAG,gBAAZ;AACAyB,UAAAA,UAAU,GAAGP,KAAK,CAACS,KAAnB;AACD,SAHM,MAGA;AACL,gBAAM,IAAI7B,KAAJ,CAAU,gDAAV,CAAN;AACD;;AACD,YAAIY,QAAQ,GAAG,EAAf;AACAA,QAAAA,QAAQ,CAACV,SAAD,CAAR,GAAsByB,UAAtB;AACAL,QAAAA,IAAI,GAAGR,MAAM,CAACU,KAAP,CAAaC,OAAb,CAAqBb,QAArB,EAA+BS,OAA/B,CAAP,CAfK,CAgBL;;AACA,YAAI,CAACC,IAAL,EAAW;AACTV,UAAAA,QAAQ,GAAG,KAAKX,qCAAL,CAA2CC,SAA3C,EAAsDyB,UAAtD,CAAX;AACA,gBAAMG,cAAc,GAAGhB,MAAM,CAACU,KAAP,CAAaO,IAAb,CAAkBnB,QAAlB,EAA4BS,OAA5B,EAAqCW,KAArC,EAAvB,CAFS,CAGT;;AACA,cAAIF,cAAc,CAACpC,MAAf,KAA0B,CAA9B,EAAiC;AAC/B4B,YAAAA,IAAI,GAAGQ,cAAc,CAAC,CAAD,CAArB;AACD;AACF;AACF;;AAED,aAAOR,IAAP;AACD,KA9SmB;;AAAA,SAm6CpBW,YAn6CoB,GAm6CL,UAACC,GAAD,EAA4B;AAAA,UAAtBC,UAAsB,uEAAT,IAAS;AACzC,YAAMC,KAAK,GAAG,IAAItB,MAAM,CAACd,KAAX,CACZ,GADY,EAEZ,KAAI,CAACqC,QAAL,CAAcC,sBAAd,GACI,sDADJ,GAEIJ,GAJQ,CAAd;;AAMA,UAAIC,UAAJ,EAAgB;AACd,cAAMC,KAAN;AACD;;AACD,aAAOA,KAAP;AACD,KA96CmB;;AAAA,SAg7CpBG,mBAh7CoB,GAg7CElD,KAAK,CAACC,KAAN,CAAYgC,IAAI,IAAI;AACxC9B,MAAAA,KAAK,CAAC8B,IAAD,EAAO;AACVC,QAAAA,EAAE,EAAElC,KAAK,CAACmD,QAAN,CAAepD,cAAf,CADM;AAEVwC,QAAAA,QAAQ,EAAEvC,KAAK,CAACmD,QAAN,CAAepD,cAAf,CAFA;AAGVyC,QAAAA,KAAK,EAAExC,KAAK,CAACmD,QAAN,CAAepD,cAAf;AAHG,OAAP,CAAL;AAKA,UAAIH,MAAM,CAACwD,IAAP,CAAYnB,IAAZ,EAAkB5B,MAAlB,KAA6B,CAAjC,EACE,MAAM,IAAIL,KAAK,CAACW,KAAV,CAAgB,2CAAhB,CAAN;AACF,aAAO,IAAP;AACD,KATqB,CAh7CF;AAGlB,SAAK0C,OAAL,GAAe9C,MAAM,IAAIkB,MAAM,CAAClB,MAAhC,CAHkB,CAIlB;;AACA,SAAK+C,kBAAL;;AAEA,SAAKC,qBAAL,GAPkB,CASlB;AACA;AACA;AACA;AACA;;;AACA,SAAKC,kBAAL,GAA0B;AACxBC,MAAAA,YAAY,EAAE,CAAC,SAAD,EAAY,UAAZ,EAAwB,QAAxB,CADU;AAExBC,MAAAA,UAAU,EAAE,CAAC,SAAD,EAAY,UAAZ;AAFY,KAA1B,CAdkB,CAmBlB;AACA;AACA;;AACA,SAAKC,qBAAL,GAA6B;AAC3BC,MAAAA,UAAU,EAAE;AACVC,QAAAA,OAAO,EAAE,CADC;AAEVtB,QAAAA,QAAQ,EAAE,CAFA;AAGVuB,QAAAA,MAAM,EAAE;AAHE;AADe,KAA7B;;AAQA,SAAKC,uBAAL,GA9BkB,CAgClB;;;AACA,SAAKC,YAAL,GAAoB,EAApB,CAjCkB,CAmClB;AACA;AACA;AACA;AACA;;AACA,SAAKC,2BAAL,GAAmC,EAAnC;AACA,SAAKC,sBAAL,GAA8B,CAA9B,CAzCkB,CAyCgB;AAElC;;AACA,SAAKC,cAAL,GAAsB,EAAtB;AAEAC,IAAAA,oBAAoB,CAAC,KAAKjC,KAAN,CAApB;AACAkC,IAAAA,yBAAyB,CAAC,IAAD,CAAzB;AACAC,IAAAA,uBAAuB,CAAC,IAAD,CAAvB;AAEA,SAAKC,kBAAL,GAA0B,IAAIC,IAAJ,CAAS;AAAEC,MAAAA,eAAe,EAAE;AAAnB,KAAT,CAA1B;AACA,SAAKC,qBAAL,GAA6B,CAC3BC,0BAA0B,CAACC,IAA3B,CAAgC,IAAhC,CAD2B,CAA7B;;AAIA,SAAKC,sCAAL;;AAEA,SAAKC,iCAAL,GAAyC,EAAzC;AAEA,SAAKC,IAAL,GAAY;AACVC,MAAAA,aAAa,EAAE,CAACC,KAAD,EAAQC,WAAR,KAAwB,KAAKC,aAAL,4BAAuCF,KAAvC,GAAgDC,WAAhD,CAD7B;AAEVE,MAAAA,WAAW,EAAE,CAACH,KAAD,EAAQC,WAAR,KAAwB,KAAKC,aAAL,0BAAqCF,KAArC,GAA8CC,WAA9C,CAF3B;AAGVG,MAAAA,UAAU,EAAE,CAAC9D,QAAD,EAAW0D,KAAX,EAAkBC,WAAlB,KACV,KAAKC,aAAL,wBAAmCF,KAAnC,uBAAqD1D,QAArD,GAAiE2D,WAAjE,CAJQ;AAKVI,MAAAA,aAAa,EAAE,CAACL,KAAD,EAAQC,WAAR,KAAwB,KAAKC,aAAL,4BAAuCF,KAAvC,GAAgDC,WAAhD;AAL7B,KAAZ;AAQA,SAAKK,mBAAL;;AAEA,SAAKJ,aAAL,GAAqB,UAACK,IAAD,EAA4B;AAAA,UAArBN,WAAqB,uEAAP,EAAO;AAC/C,YAAMO,GAAG,GAAG,IAAI/F,GAAJ,CAAQ+B,MAAM,CAACiE,WAAP,CAAmBF,IAAnB,CAAR,CAAZ;AACA,YAAMG,MAAM,GAAG/F,MAAM,CAACgG,OAAP,CAAeV,WAAf,CAAf;;AACA,UAAIS,MAAM,CAACtF,MAAP,GAAgB,CAApB,EAAuB;AACrB;AACA,aAAK,MAAM,CAACwF,GAAD,EAAMC,KAAN,CAAX,IAA2BH,MAA3B,EAAmC;AACjCF,UAAAA,GAAG,CAACM,YAAJ,CAAiBC,MAAjB,CAAwBH,GAAxB,EAA6BC,KAA7B;AACD;AACF;;AACD,aAAOL,GAAG,CAACQ,QAAJ,EAAP;AACD,KAVD;AAWD,GApFgD,CAsFjD;AACA;AACA;AAEA;;;AACAC,EAAAA,MAAM,GAAG;AACP;AACA;AACA;AACA;AACA;AACA;AACA,UAAMC,iBAAiB,GAAGC,GAAG,CAACC,wBAAJ,CAA6BC,GAA7B,MAAsCF,GAAG,CAACG,6BAAJ,CAAkCD,GAAlC,EAAhE;;AACA,QAAI,CAACH,iBAAL,EACE,MAAM,IAAIxF,KAAJ,CAAU,oEAAV,CAAN;AACF,WAAOwF,iBAAiB,CAACD,MAAzB;AACD,GAtGgD,CAwGjD;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;;;AACEM,EAAAA,oBAAoB,CAAC/F,IAAD,EAAO;AACzB;AACA,WAAO,KAAK8D,kBAAL,CAAwBkC,QAAxB,CAAiChG,IAAjC,CAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEiG,EAAAA,eAAe,CAACjG,IAAD,EAAO;AACpB,SAAKiE,qBAAL,CAA2BiC,IAA3B,CAAgClG,IAAhC;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEmG,EAAAA,mBAAmB,CAACnG,IAAD,EAAO;AACxB,QAAI,KAAKoG,wBAAT,EAAmC;AACjC,YAAM,IAAIlG,KAAJ,CAAU,wCAAV,CAAN;AACD;;AAED,SAAKkG,wBAAL,GAAgCpG,IAAhC;AACD,GA1IgD,CA4IjD;AACA;AACA;;AAEA;AACF;AACA;AACA;AACA;AACA;;;AASE;AACF;AACA;AACA;AACA;AACEqG,EAAAA,YAAY,CAACrG,IAAD,EAAO;AACjB,QAAI,KAAKsG,iBAAT,EAA4B;AAC1B,YAAM,IAAIpG,KAAJ,CAAU,iCAAV,CAAN;AACD;;AAED,SAAKoG,iBAAL,GAAyBtG,IAAzB;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEuG,EAAAA,eAAe,CAACvG,IAAD,EAAO;AACpB,QAAI,KAAKwG,oBAAT,EAA+B;AAC7B,YAAM,IAAItG,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,SAAKsG,oBAAL,GAA4BxG,IAA5B;AACD;AAED;AACF;AACA;AACA;AACA;AACA;;;AACEyG,EAAAA,oCAAoC,CAACzG,IAAD,EAAO;AACzC,QAAI,KAAK0G,kCAAT,EAA6C;AAC3C,YAAM,IAAIxG,KAAJ,CAAU,yDAAV,CAAN;AACD;;AACD,SAAKwG,kCAAL,GAA0C1G,IAA1C;AACD;;AAED2G,EAAAA,cAAc,CAACC,UAAD,EAAaC,OAAb,EAAsB;AAClC,SAAK/C,kBAAL,CAAwBgD,IAAxB,CAA6BC,QAAQ,IAAI;AACvC,UAAIC,GAAJ;;AACA,UAAI;AACFA,QAAAA,GAAG,GAAGD,QAAQ,CAACE,0BAA0B,CAACL,UAAD,EAAaC,OAAb,CAA3B,CAAd;AACD,OAFD,CAGA,OAAOK,CAAP,EAAU;AACRL,QAAAA,OAAO,CAACM,OAAR,GAAkB,KAAlB,CADQ,CAER;AACA;AACA;AACA;;AACAN,QAAAA,OAAO,CAACvE,KAAR,GAAgB4E,CAAhB;AACA,eAAO,IAAP;AACD;;AACD,UAAI,CAAEF,GAAN,EAAW;AACTH,QAAAA,OAAO,CAACM,OAAR,GAAkB,KAAlB,CADS,CAET;AACA;;AACA,YAAI,CAACN,OAAO,CAACvE,KAAb,EACEuE,OAAO,CAACvE,KAAR,GAAgB,IAAItB,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,iBAAtB,CAAhB;AACH;;AACD,aAAO,IAAP;AACD,KAtBD;AAuBD;;AAEDkH,EAAAA,gBAAgB,CAACR,UAAD,EAAaC,OAAb,EAAsB;AACpC,SAAKQ,YAAL,CAAkBP,IAAlB,CAAuBC,QAAQ,IAAI;AACjCA,MAAAA,QAAQ,CAACE,0BAA0B,CAACL,UAAD,EAAaC,OAAb,CAA3B,CAAR;AACA,aAAO,IAAP;AACD,KAHD;AAID;;AAEDS,EAAAA,YAAY,CAACV,UAAD,EAAaC,OAAb,EAAsB;AAChC,SAAKU,mBAAL,CAAyBT,IAAzB,CAA8BC,QAAQ,IAAI;AACxCA,MAAAA,QAAQ,CAACE,0BAA0B,CAACL,UAAD,EAAaC,OAAb,CAA3B,CAAR;AACA,aAAO,IAAP;AACD,KAHD;AAID;;AAEDW,EAAAA,iBAAiB,CAACZ,UAAD,EAAanB,MAAb,EAAqB;AACpC;AACA,QAAIjE,IAAJ;;AACA,SAAKiG,aAAL,CAAmBX,IAAnB,CAAwBC,QAAQ,IAAI;AAClC,UAAI,CAACvF,IAAD,IAASiE,MAAb,EAAqBjE,IAAI,GAAG,KAAKE,KAAL,CAAWC,OAAX,CAAmB8D,MAAnB,EAA2B;AAACiC,QAAAA,MAAM,EAAE,KAAKnF,QAAL,CAAcoF;AAAvB,OAA3B,CAAP;AACrBZ,MAAAA,QAAQ,CAAC;AAAEvF,QAAAA,IAAF;AAAQoF,QAAAA;AAAR,OAAD,CAAR;AACA,aAAO,IAAP;AACD,KAJD;AAKD;;AA+DD;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAgB,EAAAA,UAAU,CAACC,gBAAD,EAAmBpC,MAAnB,EAA2BqC,iBAA3B,EAA8C;AACtD,QAAI,CAAEA,iBAAN,EAAyB;AACvBA,MAAAA,iBAAiB,GAAG,KAAKC,0BAAL,EAApB;;AACA,WAAKC,iBAAL,CAAuBvC,MAAvB,EAA+BqC,iBAA/B;AACD,KAJqD,CAMtD;AACA;AACA;AACA;AACA;AACA;;;AACA9G,IAAAA,MAAM,CAACiH,gBAAP,CAAwB,MACtB,KAAKC,cAAL,CACEzC,MADF,EAEEoC,gBAAgB,CAACjB,UAFnB,EAGE,KAAKuB,eAAL,CAAqBL,iBAAiB,CAACtD,KAAvC,CAHF,CADF;;AAQAqD,IAAAA,gBAAgB,CAACO,SAAjB,CAA2B3C,MAA3B;AAEA,WAAO;AACLhE,MAAAA,EAAE,EAAEgE,MADC;AAELjB,MAAAA,KAAK,EAAEsD,iBAAiB,CAACtD,KAFpB;AAGL6D,MAAAA,YAAY,EAAE,KAAKC,gBAAL,CAAsBR,iBAAiB,CAACS,IAAxC;AAHT,KAAP;AAKD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,aAAa,CACXX,gBADW,EAEXY,UAFW,EAGXC,UAHW,EAIXC,MAJW,EAKX;AACA,QAAI,CAACA,MAAL,EACE,MAAM,IAAIzI,KAAJ,CAAU,oBAAV,CAAN,CAFF,CAIA;AACA;AACA;;AACA,QAAI,CAACyI,MAAM,CAAClD,MAAR,IAAkB,CAACkD,MAAM,CAACrG,KAA9B,EACE,MAAM,IAAIpC,KAAJ,CAAU,kDAAV,CAAN;AAEF,QAAIsB,IAAJ;AACA,QAAImH,MAAM,CAAClD,MAAX,EACEjE,IAAI,GAAG,KAAKE,KAAL,CAAWC,OAAX,CAAmBgH,MAAM,CAAClD,MAA1B,EAAkC;AAACiC,MAAAA,MAAM,EAAE,KAAKnF,QAAL,CAAcoF;AAAvB,KAAlC,CAAP;AAEF,UAAMd,OAAO,GAAG;AACd+B,MAAAA,IAAI,EAAED,MAAM,CAACC,IAAP,IAAe,SADP;AAEdzB,MAAAA,OAAO,EAAE,CAAC,EAAGwB,MAAM,CAAClD,MAAP,IAAiB,CAACkD,MAAM,CAACrG,KAA5B,CAFI;AAGdmG,MAAAA,UAAU,EAAEA,UAHE;AAIdI,MAAAA,eAAe,EAAEC,KAAK,CAACC,IAAN,CAAWL,UAAX;AAJH,KAAhB;;AAMA,QAAIC,MAAM,CAACrG,KAAX,EAAkB;AAChBuE,MAAAA,OAAO,CAACvE,KAAR,GAAgBqG,MAAM,CAACrG,KAAvB;AACD;;AACD,QAAId,IAAJ,EAAU;AACRqF,MAAAA,OAAO,CAACrF,IAAR,GAAeA,IAAf;AACD,KAzBD,CA2BA;AACA;AACA;;;AACA,SAAKmF,cAAL,CAAoBkB,gBAAgB,CAACjB,UAArC,EAAiDC,OAAjD;;AAEA,QAAIA,OAAO,CAACM,OAAZ,EAAqB;AACnB,YAAMH,GAAG,mCACJ,KAAKY,UAAL,CACDC,gBADC,EAEDc,MAAM,CAAClD,MAFN,EAGDkD,MAAM,CAACb,iBAHN,CADI,GAMJa,MAAM,CAACpH,OANH,CAAT;;AAQAyF,MAAAA,GAAG,CAAC4B,IAAJ,GAAW/B,OAAO,CAAC+B,IAAnB;;AACA,WAAKxB,gBAAL,CAAsBS,gBAAgB,CAACjB,UAAvC,EAAmDC,OAAnD;;AACA,aAAOG,GAAP;AACD,KAZD,MAaK;AACH,WAAKM,YAAL,CAAkBO,gBAAgB,CAACjB,UAAnC,EAA+CC,OAA/C;;AACA,YAAMA,OAAO,CAACvE,KAAd;AACD;AACF;;AAED;AACA;AACA;AACA;AACA0G,EAAAA,YAAY,CACVnB,gBADU,EAEVY,UAFU,EAGVC,UAHU,EAIVE,IAJU,EAKVK,EALU,EAMV;AACA,WAAO,KAAKT,aAAL,CACLX,gBADK,EAELY,UAFK,EAGLC,UAHK,EAILQ,cAAc,CAACN,IAAD,EAAOK,EAAP,CAJT,CAAP;AAMD;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACAE,EAAAA,mBAAmB,CACjBtB,gBADiB,EAEjBY,UAFiB,EAGjBC,UAHiB,EAIjBC,MAJiB,EAKjB;AACA,UAAM9B,OAAO,GAAG;AACd+B,MAAAA,IAAI,EAAED,MAAM,CAACC,IAAP,IAAe,SADP;AAEdzB,MAAAA,OAAO,EAAE,KAFK;AAGd7E,MAAAA,KAAK,EAAEqG,MAAM,CAACrG,KAHA;AAIdmG,MAAAA,UAAU,EAAEA,UAJE;AAKdI,MAAAA,eAAe,EAAEC,KAAK,CAACC,IAAN,CAAWL,UAAX;AALH,KAAhB;;AAQA,QAAIC,MAAM,CAAClD,MAAX,EAAmB;AACjBoB,MAAAA,OAAO,CAACrF,IAAR,GAAe,KAAKE,KAAL,CAAWC,OAAX,CAAmBgH,MAAM,CAAClD,MAA1B,EAAkC;AAACiC,QAAAA,MAAM,EAAE,KAAKnF,QAAL,CAAcoF;AAAvB,OAAlC,CAAf;AACD;;AAED,SAAKhB,cAAL,CAAoBkB,gBAAgB,CAACjB,UAArC,EAAiDC,OAAjD;;AACA,SAAKS,YAAL,CAAkBO,gBAAgB,CAACjB,UAAnC,EAA+CC,OAA/C,EAdA,CAgBA;AACA;;;AACA,WAAOA,OAAP;AACD;;AAED;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEAuC,EAAAA,oBAAoB,CAACC,IAAD,EAAOC,OAAP,EAAgB;AAClC,QAAI,CAAEA,OAAN,EAAe;AACbA,MAAAA,OAAO,GAAGD,IAAV;AACAA,MAAAA,IAAI,GAAG,IAAP;AACD;;AAED,SAAK3F,cAAL,CAAoBwC,IAApB,CAAyB;AACvBmD,MAAAA,IAAI,EAAEA,IADiB;AAEvBC,MAAAA,OAAO,EAAEA;AAFc,KAAzB;AAID;;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACAC,EAAAA,iBAAiB,CAAC1B,gBAAD,EAAmBtG,OAAnB,EAA4B;AAC3C,SAAK,IAAI+H,OAAT,IAAoB,KAAK5F,cAAzB,EAAyC;AACvC,YAAMiF,MAAM,GAAGO,cAAc,CAC3BI,OAAO,CAACD,IADmB,EAE3B,MAAMC,OAAO,CAACA,OAAR,CAAgBE,IAAhB,CAAqB3B,gBAArB,EAAuCtG,OAAvC,CAFqB,CAA7B;;AAKA,UAAIoH,MAAJ,EAAY;AACV,eAAOA,MAAP;AACD;;AAED,UAAIA,MAAM,KAAKc,SAAf,EAA0B;AACxB,cAAM,IAAIzI,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,qDAAtB,CAAN;AACD;AACF;;AAED,WAAO;AACL0I,MAAAA,IAAI,EAAE,IADD;AAELtG,MAAAA,KAAK,EAAE,IAAItB,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,wCAAtB;AAFF,KAAP;AAID;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAwJ,EAAAA,YAAY,CAACjE,MAAD,EAASb,UAAT,EAAqB;AAC/B,SAAKlD,KAAL,CAAWiI,MAAX,CAAkBlE,MAAlB,EAA0B;AACxBmE,MAAAA,KAAK,EAAE;AACL,uCAA+B;AAC7BxI,UAAAA,GAAG,EAAE,CACH;AAAEyI,YAAAA,WAAW,EAAEjF;AAAf,WADG,EAEH;AAAEJ,YAAAA,KAAK,EAAEI;AAAT,WAFG;AADwB;AAD1B;AADiB,KAA1B;AAUD;;AAED/B,EAAAA,kBAAkB,GAAG;AACnB;AACA;AACA,UAAMiH,QAAQ,GAAG,IAAjB,CAHmB,CAMnB;AACA;;AACA,UAAMC,OAAO,GAAG,EAAhB,CARmB,CAUnB;AACA;AACA;AACA;;AACAA,IAAAA,OAAO,CAACC,KAAR,GAAgB,UAAUzI,OAAV,EAAmB;AACjC;AACA;AACA7B,MAAAA,KAAK,CAAC6B,OAAD,EAAUpC,MAAV,CAAL;;AAEA,YAAMwJ,MAAM,GAAGmB,QAAQ,CAACP,iBAAT,CAA2B,IAA3B,EAAiChI,OAAjC,CAAf;;AAEA,aAAOuI,QAAQ,CAACtB,aAAT,CAAuB,IAAvB,EAA6B,OAA7B,EAAsCyB,SAAtC,EAAiDtB,MAAjD,CAAP;AACD,KARD;;AAUAoB,IAAAA,OAAO,CAACG,MAAR,GAAiB,YAAY;AAC3B,YAAM1F,KAAK,GAAGsF,QAAQ,CAACK,cAAT,CAAwB,KAAKvD,UAAL,CAAgBnF,EAAxC,CAAd;;AACAqI,MAAAA,QAAQ,CAAC5B,cAAT,CAAwB,KAAKzC,MAA7B,EAAqC,KAAKmB,UAA1C,EAAsD,IAAtD;;AACA,UAAIpC,KAAK,IAAI,KAAKiB,MAAlB,EAA0B;AACxBqE,QAAAA,QAAQ,CAACJ,YAAT,CAAsB,KAAKjE,MAA3B,EAAmCjB,KAAnC;AACD;;AACDsF,MAAAA,QAAQ,CAACtC,iBAAT,CAA2B,KAAKZ,UAAhC,EAA4C,KAAKnB,MAAjD;;AACA,WAAK2C,SAAL,CAAe,IAAf;AACD,KARD,CAxBmB,CAkCnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA2B,IAAAA,OAAO,CAACK,WAAR,GAAsB,YAAY;AAChC,YAAM5I,IAAI,GAAGsI,QAAQ,CAACpI,KAAT,CAAeC,OAAf,CAAuB,KAAK8D,MAA5B,EAAoC;AAC/CiC,QAAAA,MAAM,EAAE;AAAE,yCAA+B;AAAjC;AADuC,OAApC,CAAb;;AAGA,UAAI,CAAE,KAAKjC,MAAP,IAAiB,CAAEjE,IAAvB,EAA6B;AAC3B,cAAM,IAAIR,MAAM,CAACd,KAAX,CAAiB,wBAAjB,CAAN;AACD,OAN+B,CAOhC;AACA;AACA;AACA;;;AACA,YAAMmK,kBAAkB,GAAGP,QAAQ,CAACK,cAAT,CAAwB,KAAKvD,UAAL,CAAgBnF,EAAxC,CAA3B;;AACA,YAAM6I,mBAAmB,GAAG9I,IAAI,CAAC+I,QAAL,CAAcC,MAAd,CAAqBC,WAArB,CAAiCxI,IAAjC,CAC1ByI,YAAY,IAAIA,YAAY,CAACb,WAAb,KAA6BQ,kBADnB,CAA5B;;AAGA,UAAI,CAAEC,mBAAN,EAA2B;AAAE;AAC3B,cAAM,IAAItJ,MAAM,CAACd,KAAX,CAAiB,qBAAjB,CAAN;AACD;;AACD,YAAMyK,eAAe,GAAGb,QAAQ,CAAC/B,0BAAT,EAAxB;;AACA4C,MAAAA,eAAe,CAACpC,IAAhB,GAAuB+B,mBAAmB,CAAC/B,IAA3C;;AACAuB,MAAAA,QAAQ,CAAC9B,iBAAT,CAA2B,KAAKvC,MAAhC,EAAwCkF,eAAxC;;AACA,aAAOb,QAAQ,CAAClC,UAAT,CAAoB,IAApB,EAA0B,KAAKnC,MAA/B,EAAuCkF,eAAvC,CAAP;AACD,KAtBD,CA1CmB,CAkEnB;AACA;AACA;;;AACAZ,IAAAA,OAAO,CAACa,iBAAR,GAA4B,YAAY;AACtC,UAAI,CAAE,KAAKnF,MAAX,EAAmB;AACjB,cAAM,IAAIzE,MAAM,CAACd,KAAX,CAAiB,wBAAjB,CAAN;AACD;;AACD,YAAM2K,YAAY,GAAGf,QAAQ,CAACK,cAAT,CAAwB,KAAKvD,UAAL,CAAgBnF,EAAxC,CAArB;;AACAqI,MAAAA,QAAQ,CAACpI,KAAT,CAAeiI,MAAf,CAAsB,KAAKlE,MAA3B,EAAmC;AACjCmE,QAAAA,KAAK,EAAE;AACL,yCAA+B;AAAEC,YAAAA,WAAW,EAAE;AAAEiB,cAAAA,GAAG,EAAED;AAAP;AAAf;AAD1B;AAD0B,OAAnC;AAKD,KAVD,CArEmB,CAiFnB;AACA;;;AACAd,IAAAA,OAAO,CAACgB,qBAAR,GAAiCxJ,OAAD,IAAa;AAC3C7B,MAAAA,KAAK,CAAC6B,OAAD,EAAUhC,KAAK,CAACyL,eAAN,CAAsB;AAACC,QAAAA,OAAO,EAAEtL;AAAV,OAAtB,CAAV,CAAL,CAD2C,CAE3C;AACA;AACA;AACA;AACA;AACA;;AACA,UAAI,EAAEmK,QAAQ,CAACoB,KAAT,IACDpB,QAAQ,CAACoB,KAAT,CAAeC,YAAf,GAA8BC,QAA9B,CAAuC7J,OAAO,CAAC0J,OAA/C,CADD,CAAJ,EAC+D;AAC7D,cAAM,IAAIjK,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,iBAAtB,CAAN;AACD;;AAED,YAAM;AAAEmL,QAAAA;AAAF,UAA2BC,OAAO,CAAC,uBAAD,CAAxC;AACA,UAAID,oBAAoB,CAACE,cAArB,CAAoC5J,OAApC,CAA4C;AAACsJ,QAAAA,OAAO,EAAE1J,OAAO,CAAC0J;AAAlB,OAA5C,CAAJ,EACE,MAAM,IAAIjK,MAAM,CAACd,KAAX,CAAiB,GAAjB,oBAAiCqB,OAAO,CAAC0J,OAAzC,yBAAN;AAEF,UAAI/L,MAAM,CAACsK,IAAP,CAAYjI,OAAZ,EAAqB,QAArB,KAAkCiK,oBAAoB,EAA1D,EACEjK,OAAO,CAACkK,MAAR,GAAiBC,eAAe,CAACC,IAAhB,CAAqBpK,OAAO,CAACkK,MAA7B,CAAjB;AAEFJ,MAAAA,oBAAoB,CAACE,cAArB,CAAoCK,MAApC,CAA2CrK,OAA3C;AACD,KArBD;;AAuBAuI,IAAAA,QAAQ,CAAClH,OAAT,CAAiBmH,OAAjB,CAAyBA,OAAzB;AACD;;AAEDjH,EAAAA,qBAAqB,GAAG;AACtB,SAAKF,OAAL,CAAaiJ,YAAb,CAA0BjF,UAAU,IAAI;AACtC,WAAKrD,YAAL,CAAkBqD,UAAU,CAACnF,EAA7B,IAAmC;AACjCmF,QAAAA,UAAU,EAAEA;AADqB,OAAnC;AAIAA,MAAAA,UAAU,CAACkF,OAAX,CAAmB,MAAM;AACvB,aAAKC,0BAAL,CAAgCnF,UAAU,CAACnF,EAA3C;;AACA,eAAO,KAAK8B,YAAL,CAAkBqD,UAAU,CAACnF,EAA7B,CAAP;AACD,OAHD;AAID,KATD;AAUD;;AAED6B,EAAAA,uBAAuB,GAAG;AACxB;AACA,UAAM;AAAE5B,MAAAA,KAAF;AAASqB,MAAAA,kBAAT;AAA6BG,MAAAA;AAA7B,QAAuD,IAA7D,CAFwB,CAIxB;;AACA,SAAKN,OAAL,CAAaoJ,OAAb,CAAqB,kCAArB,EAAyD,MAAM;AAC7D,YAAM;AAAEX,QAAAA;AAAF,UAA2BC,OAAO,CAAC,uBAAD,CAAxC;AACA,aAAOD,oBAAoB,CAACE,cAArB,CAAoCtJ,IAApC,CAAyC,EAAzC,EAA6C;AAACyF,QAAAA,MAAM,EAAE;AAAC+D,UAAAA,MAAM,EAAE;AAAT;AAAT,OAA7C,CAAP;AACD,KAHD,EAGG;AAACQ,MAAAA,OAAO,EAAE;AAAV,KAHH,EALwB,CAQH;AAErB;AACA;;;AACAjL,IAAAA,MAAM,CAACkL,OAAP,CAAe,MAAM;AACnB;AACA,WAAKtJ,OAAL,CAAaoJ,OAAb,CAAqB,IAArB,EAA2B,YAAY;AACrC,YAAI,KAAKvG,MAAT,EAAiB;AACf,iBAAO/D,KAAK,CAACO,IAAN,CAAW;AAChBkK,YAAAA,GAAG,EAAE,KAAK1G;AADM,WAAX,EAEJ;AACDiC,YAAAA,MAAM,EAAExE,qBAAqB,CAACC;AAD7B,WAFI,CAAP;AAKD,SAND,MAMO;AACL,iBAAO,IAAP;AACD;AACF,OAVD;AAUG;AAAgC;AAAC8I,QAAAA,OAAO,EAAE;AAAV,OAVnC;AAWD,KAbD,EAZwB,CA2BxB;AACA;;AACAX,IAAAA,OAAO,CAACc,WAAR,IAAuBpL,MAAM,CAACkL,OAAP,CAAe,MAAM;AAC1C;AACA,YAAMG,eAAe,GAAG3E,MAAM,IAAIA,MAAM,CAAC4E,MAAP,CAAc,CAACC,IAAD,EAAOC,KAAP,qCACvCD,IADuC;AACjC,SAACC,KAAD,GAAS;AADwB,QAAd,EAEhC,EAFgC,CAAlC;;AAIA,WAAK5J,OAAL,CAAaoJ,OAAb,CAAqB,IAArB,EAA2B,YAAY;AACrC,YAAI,KAAKvG,MAAT,EAAiB;AACf,iBAAO/D,KAAK,CAACO,IAAN,CAAW;AAAEkK,YAAAA,GAAG,EAAE,KAAK1G;AAAZ,WAAX,EAAiC;AACtCiC,YAAAA,MAAM,EAAE2E,eAAe,CAACtJ,kBAAkB,CAACC,YAApB;AADe,WAAjC,CAAP;AAGD,SAJD,MAIO;AACL,iBAAO,IAAP;AACD;AACF,OARD;AAQG;AAAgC;AAACiJ,QAAAA,OAAO,EAAE;AAAV,OARnC,EAN0C,CAgB1C;AACA;AACA;AACA;AACA;;;AACA,WAAKrJ,OAAL,CAAaoJ,OAAb,CAAqB,IAArB,EAA2B,YAAY;AACrC,cAAMlL,QAAQ,GAAG,KAAK2E,MAAL,GAAc;AAAE0G,UAAAA,GAAG,EAAE;AAAErB,YAAAA,GAAG,EAAE,KAAKrF;AAAZ;AAAP,SAAd,GAA8C,EAA/D;AACA,eAAO/D,KAAK,CAACO,IAAN,CAAWnB,QAAX,EAAqB;AAC1B4G,UAAAA,MAAM,EAAE2E,eAAe,CAACtJ,kBAAkB,CAACE,UAApB;AADG,SAArB,CAAP;AAGD,OALD;AAKG;AAAgC;AAACgJ,QAAAA,OAAO,EAAE;AAAV,OALnC;AAMD,KA3BsB,CAAvB;AA4BD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACAQ,EAAAA,oBAAoB,CAACC,IAAD,EAAO;AACzB,SAAK3J,kBAAL,CAAwBC,YAAxB,CAAqCkD,IAArC,CAA0CyG,KAA1C,CACE,KAAK5J,kBAAL,CAAwBC,YAD1B,EACwC0J,IAAI,CAACE,eAD7C;;AAEA,SAAK7J,kBAAL,CAAwBE,UAAxB,CAAmCiD,IAAnC,CAAwCyG,KAAxC,CACE,KAAK5J,kBAAL,CAAwBE,UAD1B,EACsCyJ,IAAI,CAACG,aAD3C;AAED;;AAED;AACA;AACA;AACA;AACAC,EAAAA,uBAAuB,CAACpF,MAAD,EAAS;AAC9B,SAAKxE,qBAAL,CAA2BC,UAA3B,GAAwCuE,MAAxC;AACD;;AAED;AACA;AACA;AAEA;AACA;AACAqF,EAAAA,eAAe,CAACC,YAAD,EAAeR,KAAf,EAAsB;AACnC,UAAMS,IAAI,GAAG,KAAK1J,YAAL,CAAkByJ,YAAlB,CAAb;AACA,WAAOC,IAAI,IAAIA,IAAI,CAACT,KAAD,CAAnB;AACD;;AAEDU,EAAAA,eAAe,CAACF,YAAD,EAAeR,KAAf,EAAsBnH,KAAtB,EAA6B;AAC1C,UAAM4H,IAAI,GAAG,KAAK1J,YAAL,CAAkByJ,YAAlB,CAAb,CAD0C,CAG1C;AACA;;AACA,QAAI,CAACC,IAAL,EACE;AAEF,QAAI5H,KAAK,KAAKoE,SAAd,EACE,OAAOwD,IAAI,CAACT,KAAD,CAAX,CADF,KAGES,IAAI,CAACT,KAAD,CAAJ,GAAcnH,KAAd;AACH;;AAED;AACA;AACA;AACA;AAEA8C,EAAAA,eAAe,CAACvD,UAAD,EAAa;AAC1B,UAAMuI,IAAI,GAAGrO,MAAM,CAACsO,UAAP,CAAkB,QAAlB,CAAb;AACAD,IAAAA,IAAI,CAACxD,MAAL,CAAY/E,UAAZ;AACA,WAAOuI,IAAI,CAACE,MAAL,CAAY,QAAZ,CAAP;AACD;;AAED;AACAC,EAAAA,iBAAiB,CAAC5C,YAAD,EAAe;AAC9B,UAAM;AAAElG,MAAAA;AAAF,QAAmCkG,YAAzC;AAAA,UAAkB6C,kBAAlB,4BAAyC7C,YAAzC;;AACA,2CACK6C,kBADL;AAEE1D,MAAAA,WAAW,EAAE,KAAK1B,eAAL,CAAqB3D,KAArB;AAFf;AAID;;AAED;AACA;AACA;AACAgJ,EAAAA,uBAAuB,CAAC/H,MAAD,EAASoE,WAAT,EAAsBvI,KAAtB,EAA6B;AAClDA,IAAAA,KAAK,GAAGA,KAAK,qBAAQA,KAAR,IAAkB,EAA/B;AACAA,IAAAA,KAAK,CAAC6K,GAAN,GAAY1G,MAAZ;AACA,SAAK/D,KAAL,CAAWiI,MAAX,CAAkBrI,KAAlB,EAAyB;AACvBmM,MAAAA,SAAS,EAAE;AACT,uCAA+B5D;AADtB;AADY,KAAzB;AAKD;;AAED;AACA7B,EAAAA,iBAAiB,CAACvC,MAAD,EAASiF,YAAT,EAAuBpJ,KAAvB,EAA8B;AAC7C,SAAKkM,uBAAL,CACE/H,MADF,EAEE,KAAK6H,iBAAL,CAAuB5C,YAAvB,CAFF,EAGEpJ,KAHF;AAKD;;AAEDoM,EAAAA,oBAAoB,CAACjI,MAAD,EAAS;AAC3B,SAAK/D,KAAL,CAAWiI,MAAX,CAAkBlE,MAAlB,EAA0B;AACxBkI,MAAAA,IAAI,EAAE;AACJ,uCAA+B;AAD3B;AADkB,KAA1B;AAKD;;AAED;AACAC,EAAAA,eAAe,CAACZ,YAAD,EAAe;AAC5B,WAAO,KAAKxJ,2BAAL,CAAiCwJ,YAAjC,CAAP;AACD;;AAED;AACA;AACA;AACAjB,EAAAA,0BAA0B,CAACiB,YAAD,EAAe;AACvC,QAAI9N,MAAM,CAACsK,IAAP,CAAY,KAAKhG,2BAAjB,EAA8CwJ,YAA9C,CAAJ,EAAiE;AAC/D,YAAMa,OAAO,GAAG,KAAKrK,2BAAL,CAAiCwJ,YAAjC,CAAhB;;AACA,UAAI,OAAOa,OAAP,KAAmB,QAAvB,EAAiC;AAC/B;AACA;AACA;AACA;AACA,eAAO,KAAKrK,2BAAL,CAAiCwJ,YAAjC,CAAP;AACD,OAND,MAMO;AACL,eAAO,KAAKxJ,2BAAL,CAAiCwJ,YAAjC,CAAP;AACAa,QAAAA,OAAO,CAACC,IAAR;AACD;AACF;AACF;;AAED3D,EAAAA,cAAc,CAAC6C,YAAD,EAAe;AAC3B,WAAO,KAAKD,eAAL,CAAqBC,YAArB,EAAmC,YAAnC,CAAP;AACD;;AAED;AACA9E,EAAAA,cAAc,CAACzC,MAAD,EAASmB,UAAT,EAAqBmH,QAArB,EAA+B;AAC3C,SAAKhC,0BAAL,CAAgCnF,UAAU,CAACnF,EAA3C;;AACA,SAAKyL,eAAL,CAAqBtG,UAAU,CAACnF,EAAhC,EAAoC,YAApC,EAAkDsM,QAAlD;;AAEA,QAAIA,QAAJ,EAAc;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAMC,eAAe,GAAG,EAAE,KAAKvK,sBAA/B;AACA,WAAKD,2BAAL,CAAiCoD,UAAU,CAACnF,EAA5C,IAAkDuM,eAAlD;AACAhN,MAAAA,MAAM,CAACiN,KAAP,CAAa,MAAM;AACjB;AACA;AACA;AACA;AACA,YAAI,KAAKzK,2BAAL,CAAiCoD,UAAU,CAACnF,EAA5C,MAAoDuM,eAAxD,EAAyE;AACvE;AACD;;AAED,YAAIE,iBAAJ,CATiB,CAUjB;AACA;AACA;;AACA,cAAML,OAAO,GAAG,KAAKnM,KAAL,CAAWO,IAAX,CAAgB;AAC9BkK,UAAAA,GAAG,EAAE1G,MADyB;AAE9B,qDAA2CsI;AAFb,SAAhB,EAGb;AAAErG,UAAAA,MAAM,EAAE;AAAEyE,YAAAA,GAAG,EAAE;AAAP;AAAV,SAHa,EAGWgC,cAHX,CAG0B;AACxCC,UAAAA,KAAK,EAAE,MAAM;AACXF,YAAAA,iBAAiB,GAAG,IAApB;AACD,WAHuC;AAIxCG,UAAAA,OAAO,EAAEzH,UAAU,CAAC0H,KAJoB,CAKxC;AACA;AACA;;AAPwC,SAH1B,EAWb;AAAEC,UAAAA,oBAAoB,EAAE;AAAxB,SAXa,CAAhB,CAbiB,CA0BjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAI,KAAK/K,2BAAL,CAAiCoD,UAAU,CAACnF,EAA5C,MAAoDuM,eAAxD,EAAyE;AACvEH,UAAAA,OAAO,CAACC,IAAR;AACA;AACD;;AAED,aAAKtK,2BAAL,CAAiCoD,UAAU,CAACnF,EAA5C,IAAkDoM,OAAlD;;AAEA,YAAI,CAAEK,iBAAN,EAAyB;AACvB;AACA;AACA;AACA;AACA;AACAtH,UAAAA,UAAU,CAAC0H,KAAX;AACD;AACF,OAjDD;AAkDD;AACF;;AAED;AACA;AACAvG,EAAAA,0BAA0B,GAAG;AAC3B,WAAO;AACLvD,MAAAA,KAAK,EAAEgK,MAAM,CAAC/C,MAAP,EADF;AAELlD,MAAAA,IAAI,EAAE,IAAIkG,IAAJ;AAFD,KAAP;AAID;;AAED;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,0BAA0B,CAACC,eAAD,EAAkBlJ,MAAlB,EAA0B;AAClD,UAAMmJ,eAAe,GAAG,KAAKC,gCAAL,EAAxB,CADkD,CAGlD;;;AACA,QAAKF,eAAe,IAAI,CAAClJ,MAArB,IAAiC,CAACkJ,eAAD,IAAoBlJ,MAAzD,EAAkE;AAChE,YAAM,IAAIvF,KAAJ,CAAU,yDAAV,CAAN;AACD;;AAEDyO,IAAAA,eAAe,GAAGA,eAAe,IAC9B,IAAIF,IAAJ,CAAS,IAAIA,IAAJ,KAAaG,eAAtB,CADH;AAGA,UAAME,WAAW,GAAG;AAClB1N,MAAAA,GAAG,EAAE,CACH;AAAE,0CAAkC;AAApC,OADG,EAEH;AAAE,0CAAkC;AAAC2N,UAAAA,OAAO,EAAE;AAAV;AAApC,OAFG;AADa,KAApB;AAOAC,IAAAA,mBAAmB,CAAC,IAAD,EAAOL,eAAP,EAAwBG,WAAxB,EAAqCrJ,MAArC,CAAnB;AACD,GAngCgD,CAqgCjD;AACA;AACA;AACA;AACA;AACA;;;AACAwJ,EAAAA,2BAA2B,CAACN,eAAD,EAAkBlJ,MAAlB,EAA0B;AACnD,UAAMmJ,eAAe,GAAG,KAAKM,iCAAL,EAAxB,CADmD,CAGnD;;;AACA,QAAKP,eAAe,IAAI,CAAClJ,MAArB,IAAiC,CAACkJ,eAAD,IAAoBlJ,MAAzD,EAAkE;AAChE,YAAM,IAAIvF,KAAJ,CAAU,yDAAV,CAAN;AACD;;AAEDyO,IAAAA,eAAe,GAAGA,eAAe,IAC9B,IAAIF,IAAJ,CAAS,IAAIA,IAAJ,KAAaG,eAAtB,CADH;AAGA,UAAME,WAAW,GAAG;AAClB,yCAAmC;AADjB,KAApB;AAIAE,IAAAA,mBAAmB,CAAC,IAAD,EAAOL,eAAP,EAAwBG,WAAxB,EAAqCrJ,MAArC,CAAnB;AACD,GA3hCgD,CA6hCjD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA0J,EAAAA,aAAa,CAACR,eAAD,EAAkBlJ,MAAlB,EAA0B;AACrC,UAAMmJ,eAAe,GAAG,KAAKQ,mBAAL,EAAxB,CADqC,CAGrC;;;AACA,QAAKT,eAAe,IAAI,CAAClJ,MAArB,IAAiC,CAACkJ,eAAD,IAAoBlJ,MAAzD,EAAkE;AAChE,YAAM,IAAIvF,KAAJ,CAAU,yDAAV,CAAN;AACD;;AAEDyO,IAAAA,eAAe,GAAGA,eAAe,IAC9B,IAAIF,IAAJ,CAAS,IAAIA,IAAJ,KAAaG,eAAtB,CADH;AAEA,UAAMS,UAAU,GAAG5J,MAAM,GAAG;AAAC0G,MAAAA,GAAG,EAAE1G;AAAN,KAAH,GAAmB,EAA5C,CAVqC,CAarC;AACA;;AACA,SAAK/D,KAAL,CAAWiI,MAAX,iCAAuB0F,UAAvB;AACEjO,MAAAA,GAAG,EAAE,CACH;AAAE,4CAAoC;AAAEkO,UAAAA,GAAG,EAAEX;AAAP;AAAtC,OADG,EAEH;AAAE,4CAAoC;AAAEW,UAAAA,GAAG,EAAE,CAACX;AAAR;AAAtC,OAFG;AADP,QAKG;AACD/E,MAAAA,KAAK,EAAE;AACL,uCAA+B;AAC7BxI,UAAAA,GAAG,EAAE,CACH;AAAEmH,YAAAA,IAAI,EAAE;AAAE+G,cAAAA,GAAG,EAAEX;AAAP;AAAR,WADG,EAEH;AAAEpG,YAAAA,IAAI,EAAE;AAAE+G,cAAAA,GAAG,EAAE,CAACX;AAAR;AAAR,WAFG;AADwB;AAD1B;AADN,KALH,EAcG;AAAEY,MAAAA,KAAK,EAAE;AAAT,KAdH,EAfqC,CA8BrC;AACA;AACD;;AAED;AACAC,EAAAA,MAAM,CAACjO,OAAD,EAAU;AACd;AACA,UAAMkO,WAAW,GAAG1Q,cAAc,CAACK,SAAf,CAAyBoQ,MAAzB,CAAgC7C,KAAhC,CAAsC,IAAtC,EAA4C1C,SAA5C,CAApB,CAFc,CAId;AACA;;AACA,QAAI/K,MAAM,CAACsK,IAAP,CAAY,KAAKjH,QAAjB,EAA2B,uBAA3B,KACF,KAAKA,QAAL,CAAcmN,qBAAd,KAAwC,IADtC,IAEF,KAAKC,mBAFP,EAE4B;AAC1B3O,MAAAA,MAAM,CAAC4O,aAAP,CAAqB,KAAKD,mBAA1B;AACA,WAAKA,mBAAL,GAA2B,IAA3B;AACD;;AAED,WAAOF,WAAP;AACD;;AAED;AACAI,EAAAA,aAAa,CAACtO,OAAD,EAAUC,IAAV,EAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,IAAAA,IAAI;AACFsO,MAAAA,SAAS,EAAE,IAAIrB,IAAJ,EADT;AAEFtC,MAAAA,GAAG,EAAEqC,MAAM,CAAC/M,EAAP;AAFH,OAGCD,IAHD,CAAJ;;AAMA,QAAIA,IAAI,CAAC+I,QAAT,EAAmB;AACjBpL,MAAAA,MAAM,CAACwD,IAAP,CAAYnB,IAAI,CAAC+I,QAAjB,EAA2BwF,OAA3B,CAAmC9E,OAAO,IACxC+E,wBAAwB,CAACxO,IAAI,CAAC+I,QAAL,CAAcU,OAAd,CAAD,EAAyBzJ,IAAI,CAAC2K,GAA9B,CAD1B;AAGD;;AAED,QAAI8D,QAAJ;;AACA,QAAI,KAAK3J,iBAAT,EAA4B;AAC1B2J,MAAAA,QAAQ,GAAG,KAAK3J,iBAAL,CAAuB/E,OAAvB,EAAgCC,IAAhC,CAAX,CAD0B,CAG1B;AACA;AACA;;AACA,UAAIyO,QAAQ,KAAK,mBAAjB,EACEA,QAAQ,GAAGC,qBAAqB,CAAC3O,OAAD,EAAUC,IAAV,CAAhC;AACH,KARD,MAQO;AACLyO,MAAAA,QAAQ,GAAGC,qBAAqB,CAAC3O,OAAD,EAAUC,IAAV,CAAhC;AACD;;AAED,SAAKyC,qBAAL,CAA2B8L,OAA3B,CAAmCI,IAAI,IAAI;AACzC,UAAI,CAAEA,IAAI,CAACF,QAAD,CAAV,EACE,MAAM,IAAIjP,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,wBAAtB,CAAN;AACH,KAHD;;AAKA,QAAIuF,MAAJ;;AACA,QAAI;AACFA,MAAAA,MAAM,GAAG,KAAK/D,KAAL,CAAWkK,MAAX,CAAkBqE,QAAlB,CAAT;AACD,KAFD,CAEE,OAAO/I,CAAP,EAAU;AACV;AACA;AACA;AACA,UAAI,CAACA,CAAC,CAACkJ,MAAP,EAAe,MAAMlJ,CAAN;AACf,UAAIA,CAAC,CAACkJ,MAAF,CAAShF,QAAT,CAAkB,gBAAlB,CAAJ,EACE,MAAM,IAAIpK,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,uBAAtB,CAAN;AACF,UAAIgH,CAAC,CAACkJ,MAAF,CAAShF,QAAT,CAAkB,UAAlB,CAAJ,EACE,MAAM,IAAIpK,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,0BAAtB,CAAN;AACF,YAAMgH,CAAN;AACD;;AACD,WAAOzB,MAAP;AACD;;AAED;AACA;AACA4K,EAAAA,gBAAgB,CAACtO,KAAD,EAAQ;AACtB,UAAMuO,MAAM,GAAG,KAAK/N,QAAL,CAAcgO,6BAA7B;AAEA,WAAO,CAACD,MAAD,IACJ,OAAOA,MAAP,KAAkB,UAAlB,IAAgCA,MAAM,CAACvO,KAAD,CADlC,IAEJ,OAAOuO,MAAP,KAAkB,QAAlB,IACE,IAAIvP,MAAJ,YAAeC,MAAM,CAACC,aAAP,CAAqBqP,MAArB,CAAf,QAAgD,GAAhD,CAAD,CAAuDE,IAAvD,CAA4DzO,KAA5D,CAHJ;AAID;;AAED;AACA;AACA;AAEA0O,EAAAA,yBAAyB,CAAChL,MAAD,EAASiL,cAAT,EAAyB;AAChD,QAAIA,cAAJ,EAAoB;AAClB,WAAKhP,KAAL,CAAWiI,MAAX,CAAkBlE,MAAlB,EAA0B;AACxBkL,QAAAA,MAAM,EAAE;AACN,qDAA2C,CADrC;AAEN,iDAAuC;AAFjC,SADgB;AAKxBC,QAAAA,QAAQ,EAAE;AACR,yCAA+BF;AADvB;AALc,OAA1B;AASD;AACF;;AAEDtM,EAAAA,sCAAsC,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACApD,IAAAA,MAAM,CAACkL,OAAP,CAAe,MAAM;AACnB,WAAKxK,KAAL,CAAWO,IAAX,CAAgB;AACd,mDAA2C;AAD7B,OAAhB,EAEG;AAACyF,QAAAA,MAAM,EAAE;AACR,iDAAuC;AAD/B;AAAT,OAFH,EAIMqI,OAJN,CAIcvO,IAAI,IAAI;AACpB,aAAKiP,yBAAL,CACEjP,IAAI,CAAC2K,GADP,EAEE3K,IAAI,CAAC+I,QAAL,CAAcC,MAAd,CAAqBqG,mBAFvB;AAID,OATD;AAUD,KAXD;AAYD;;AAED;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,EAAAA,qCAAqC,CACnCC,WADmC,EAEnCC,WAFmC,EAGnCzP,OAHmC,EAInC;AACAA,IAAAA,OAAO,qBAAQA,OAAR,CAAP;;AAEA,QAAIwP,WAAW,KAAK,UAAhB,IAA8BA,WAAW,KAAK,QAAlD,EAA4D;AAC1D,YAAM,IAAI7Q,KAAJ,CACJ,2EACE6Q,WAFE,CAAN;AAGD;;AACD,QAAI,CAAC7R,MAAM,CAACsK,IAAP,CAAYwH,WAAZ,EAAyB,IAAzB,CAAL,EAAqC;AACnC,YAAM,IAAI9Q,KAAJ,oCACwB6Q,WADxB,sBAAN;AAED,KAXD,CAaA;;;AACA,UAAMjQ,QAAQ,GAAG,EAAjB;AACA,UAAMmQ,YAAY,sBAAeF,WAAf,QAAlB,CAfA,CAiBA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIA,WAAW,KAAK,SAAhB,IAA6B,CAACG,KAAK,CAACF,WAAW,CAACvP,EAAb,CAAvC,EAAyD;AACvDX,MAAAA,QAAQ,CAAC,KAAD,CAAR,GAAkB,CAAC,EAAD,EAAI,EAAJ,CAAlB;AACAA,MAAAA,QAAQ,CAAC,KAAD,CAAR,CAAgB,CAAhB,EAAmBmQ,YAAnB,IAAmCD,WAAW,CAACvP,EAA/C;AACAX,MAAAA,QAAQ,CAAC,KAAD,CAAR,CAAgB,CAAhB,EAAmBmQ,YAAnB,IAAmCE,QAAQ,CAACH,WAAW,CAACvP,EAAb,EAAiB,EAAjB,CAA3C;AACD,KAJD,MAIO;AACLX,MAAAA,QAAQ,CAACmQ,YAAD,CAAR,GAAyBD,WAAW,CAACvP,EAArC;AACD;;AAED,QAAID,IAAI,GAAG,KAAKE,KAAL,CAAWC,OAAX,CAAmBb,QAAnB,EAA6B;AAAC4G,MAAAA,MAAM,EAAE,KAAKnF,QAAL,CAAcoF;AAAvB,KAA7B,CAAX,CAhCA,CAkCA;AACA;;AACA,QAAI,CAACnG,IAAD,IAAS,KAAKkF,kCAAlB,EAAsD;AACpDlF,MAAAA,IAAI,GAAG,KAAKkF,kCAAL,CAAwC;AAACqK,QAAAA,WAAD;AAAcC,QAAAA,WAAd;AAA2BzP,QAAAA;AAA3B,OAAxC,CAAP;AACD,KAtCD,CAwCA;;;AACA,QAAI,KAAK6E,wBAAL,IAAiC,CAAC,KAAKA,wBAAL,CAA8B2K,WAA9B,EAA2CC,WAA3C,EAAwDxP,IAAxD,CAAtC,EAAqG;AACnG,YAAM,IAAIR,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,iBAAtB,CAAN;AACD,KA3CD,CA6CA;AACA;AACA;AACA;AACA;AACA;;;AACA,QAAIwM,IAAI,GAAGlL,IAAI,GAAG,EAAH,GAAQD,OAAvB;;AACA,QAAI,KAAKiF,oBAAT,EAA+B;AAC7BkG,MAAAA,IAAI,GAAG,KAAKlG,oBAAL,CAA0BjF,OAA1B,EAAmCC,IAAnC,CAAP;AACD;;AAED,QAAIA,IAAJ,EAAU;AACRwO,MAAAA,wBAAwB,CAACgB,WAAD,EAAcxP,IAAI,CAAC2K,GAAnB,CAAxB;AAEA,UAAIiF,QAAQ,GAAG,EAAf;AACAjS,MAAAA,MAAM,CAACwD,IAAP,CAAYqO,WAAZ,EAAyBjB,OAAzB,CAAiC3K,GAAG,IAClCgM,QAAQ,oBAAaL,WAAb,cAA4B3L,GAA5B,EAAR,GAA6C4L,WAAW,CAAC5L,GAAD,CAD1D,EAJQ,CAQR;AACA;;AACAgM,MAAAA,QAAQ,mCAAQA,QAAR,GAAqB1E,IAArB,CAAR;AACA,WAAKhL,KAAL,CAAWiI,MAAX,CAAkBnI,IAAI,CAAC2K,GAAvB,EAA4B;AAC1BwB,QAAAA,IAAI,EAAEyD;AADoB,OAA5B;AAIA,aAAO;AACLxI,QAAAA,IAAI,EAAEmI,WADD;AAELtL,QAAAA,MAAM,EAAEjE,IAAI,CAAC2K;AAFR,OAAP;AAID,KAnBD,MAmBO;AACL;AACA3K,MAAAA,IAAI,GAAG;AAAC+I,QAAAA,QAAQ,EAAE;AAAX,OAAP;AACA/I,MAAAA,IAAI,CAAC+I,QAAL,CAAcwG,WAAd,IAA6BC,WAA7B;AACA,aAAO;AACLpI,QAAAA,IAAI,EAAEmI,WADD;AAELtL,QAAAA,MAAM,EAAE,KAAKoK,aAAL,CAAmBnD,IAAnB,EAAyBlL,IAAzB;AAFH,OAAP;AAID;AACF;;AAED;AACA6P,EAAAA,sBAAsB,GAAG;AACvB,UAAMC,IAAI,GAAGC,cAAc,CAACC,UAAf,CAA0B,KAAKC,wBAA/B,CAAb;AACA,SAAKA,wBAAL,GAAgC,IAAhC;AACA,WAAOH,IAAP;AACD;;AAED;AACA;AACAxM,EAAAA,mBAAmB,GAAG;AACpB,QAAI,CAAC,KAAK2M,wBAAV,EAAoC;AAClC,WAAKA,wBAAL,GAAgCF,cAAc,CAACG,OAAf,CAAuB;AACrDjM,QAAAA,MAAM,EAAE,IAD6C;AAErDkM,QAAAA,aAAa,EAAE,IAFsC;AAGrD/I,QAAAA,IAAI,EAAE,QAH+C;AAIrDS,QAAAA,IAAI,EAAEA,IAAI,IAAI,CAAC,OAAD,EAAU,YAAV,EAAwB,eAAxB,EAAyC,gBAAzC,EACX+B,QADW,CACF/B,IADE,CAJuC;AAMrD2D,QAAAA,YAAY,EAAGA,YAAD,IAAkB;AANqB,OAAvB,EAO7B,CAP6B,EAO1B,KAP0B,CAAhC;AAQD;AACF;;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE4E,EAAAA,uBAAuB,CAAC7P,KAAD,EAAQP,IAAR,EAAcwD,GAAd,EAAmB6M,MAAnB,EAAsC;AAAA,QAAXC,KAAW,uEAAH,EAAG;AAC3D,UAAMvQ,OAAO,GAAG;AACdwQ,MAAAA,EAAE,EAAEhQ,KADU;AAEdgH,MAAAA,IAAI,EAAE,KAAKiJ,cAAL,CAAoBH,MAApB,EAA4B9I,IAA5B,GACF,KAAKiJ,cAAL,CAAoBH,MAApB,EAA4B9I,IAA5B,CAAiCvH,IAAjC,CADE,GAEF,KAAKwQ,cAAL,CAAoBjJ,IAJV;AAKdkJ,MAAAA,OAAO,EAAE,KAAKD,cAAL,CAAoBH,MAApB,EAA4BI,OAA5B,CAAoCzQ,IAApC,EAA0CwD,GAA1C,EAA+C8M,KAA/C;AALK,KAAhB;;AAQA,QAAI,OAAO,KAAKE,cAAL,CAAoBH,MAApB,EAA4BK,IAAnC,KAA4C,UAAhD,EAA4D;AAC1D3Q,MAAAA,OAAO,CAAC2Q,IAAR,GAAe,KAAKF,cAAL,CAAoBH,MAApB,EAA4BK,IAA5B,CAAiC1Q,IAAjC,EAAuCwD,GAAvC,EAA4C8M,KAA5C,CAAf;AACD;;AAED,QAAI,OAAO,KAAKE,cAAL,CAAoBH,MAApB,EAA4BM,IAAnC,KAA4C,UAAhD,EAA4D;AAC1D5Q,MAAAA,OAAO,CAAC4Q,IAAR,GAAe,KAAKH,cAAL,CAAoBH,MAApB,EAA4BM,IAA5B,CAAiC3Q,IAAjC,EAAuCwD,GAAvC,EAA4C8M,KAA5C,CAAf;AACD;;AAED,QAAI,OAAO,KAAKE,cAAL,CAAoBI,OAA3B,KAAuC,QAA3C,EAAqD;AACnD7Q,MAAAA,OAAO,CAAC6Q,OAAR,GAAkB,KAAKJ,cAAL,CAAoBI,OAAtC;AACD;;AAED,WAAO7Q,OAAP;AACD;;AAED8Q,EAAAA,kCAAkC,CAChCjS,SADgC,EAEhCkS,WAFgC,EAGhCzQ,UAHgC,EAIhC0Q,SAJgC,EAKhC;AACA;AACA;AACA,UAAMC,SAAS,GAAGrT,MAAM,CAACC,SAAP,CAAiBC,cAAjB,CAAgCmK,IAAhC,CAChB,KAAKnF,iCADW,EAEhBxC,UAFgB,CAAlB;;AAKA,QAAIA,UAAU,IAAI,CAAC2Q,SAAnB,EAA8B;AAC5B,YAAMC,YAAY,GAAGzR,MAAM,CAACU,KAAP,CAClBO,IADkB,CAEjB,KAAK9B,qCAAL,CAA2CC,SAA3C,EAAsDyB,UAAtD,CAFiB,EAGjB;AACE6F,QAAAA,MAAM,EAAE;AAAEyE,UAAAA,GAAG,EAAE;AAAP,SADV;AAEE;AACAuG,QAAAA,KAAK,EAAE;AAHT,OAHiB,EASlBxQ,KATkB,EAArB;;AAWA,UACEuQ,YAAY,CAAC7S,MAAb,GAAsB,CAAtB,MACA;AACC,OAAC2S,SAAD,IACC;AACA;AACAE,MAAAA,YAAY,CAAC7S,MAAb,GAAsB,CAHvB,IAG4B6S,YAAY,CAAC,CAAD,CAAZ,CAAgBtG,GAAhB,KAAwBoG,SALrD,CADF,EAOE;AACA,aAAKpQ,YAAL,WAAqBmQ,WAArB;AACD;AACF;AACF;;AAEDK,EAAAA,6BAA6B,OAAqC;AAAA,QAApC;AAAEnR,MAAAA,IAAF;AAAQO,MAAAA,KAAR;AAAeD,MAAAA,QAAf;AAAyBP,MAAAA;AAAzB,KAAoC;;AAChE,UAAMqR,OAAO,iDACRpR,IADQ,GAEPM,QAAQ,GAAG;AAAEA,MAAAA;AAAF,KAAH,GAAkB,EAFnB,GAGPC,KAAK,GAAG;AAAEsB,MAAAA,MAAM,EAAE,CAAC;AAAEwP,QAAAA,OAAO,EAAE9Q,KAAX;AAAkB+Q,QAAAA,QAAQ,EAAE;AAA5B,OAAD;AAAV,KAAH,GAAuD,EAHrD,CAAb,CADgE,CAOhE;;;AACA,SAAKT,kCAAL,CAAwC,UAAxC,EAAoD,UAApD,EAAgEvQ,QAAhE;;AACA,SAAKuQ,kCAAL,CAAwC,gBAAxC,EAA0D,OAA1D,EAAmEtQ,KAAnE;;AAEA,UAAM0D,MAAM,GAAG,KAAKoK,aAAL,CAAmBtO,OAAnB,EAA4BqR,OAA5B,CAAf,CAXgE,CAYhE;AACA;;AACA,QAAI;AACF,WAAKP,kCAAL,CAAwC,UAAxC,EAAoD,UAApD,EAAgEvQ,QAAhE,EAA0E2D,MAA1E;;AACA,WAAK4M,kCAAL,CAAwC,gBAAxC,EAA0D,OAA1D,EAAmEtQ,KAAnE,EAA0E0D,MAA1E;AACD,KAHD,CAGE,OAAOsN,EAAP,EAAW;AACX;AACA/R,MAAAA,MAAM,CAACU,KAAP,CAAasR,MAAb,CAAoBvN,MAApB;AACA,YAAMsN,EAAN;AACD;;AACD,WAAOtN,MAAP;AACD;;AAr6CgD;;AAi8CnD;AACA;AACA;AACA,MAAMwB,0BAA0B,GAAG,CAACL,UAAD,EAAaC,OAAb,KAAyB;AAC1D,QAAMoM,aAAa,GAAGC,KAAK,CAACC,KAAN,CAAYtM,OAAZ,CAAtB;AACAoM,EAAAA,aAAa,CAACrM,UAAd,GAA2BA,UAA3B;AACA,SAAOqM,aAAP;AACD,CAJD;;AAMA,MAAM/J,cAAc,GAAG,CAACN,IAAD,EAAOK,EAAP,KAAc;AACnC,MAAIN,MAAJ;;AACA,MAAI;AACFA,IAAAA,MAAM,GAAGM,EAAE,EAAX;AACD,GAFD,CAGA,OAAO/B,CAAP,EAAU;AACRyB,IAAAA,MAAM,GAAG;AAACrG,MAAAA,KAAK,EAAE4E;AAAR,KAAT;AACD;;AAED,MAAIyB,MAAM,IAAI,CAACA,MAAM,CAACC,IAAlB,IAA0BA,IAA9B,EACED,MAAM,CAACC,IAAP,GAAcA,IAAd;AAEF,SAAOD,MAAP;AACD,CAbD;;AAeA,MAAM/E,yBAAyB,GAAGkG,QAAQ,IAAI;AAC5CA,EAAAA,QAAQ,CAACV,oBAAT,CAA8B,QAA9B,EAAwC,UAAU7H,OAAV,EAAmB;AACzD,WAAO6R,yBAAyB,CAAC5J,IAA1B,CAA+B,IAA/B,EAAqCM,QAArC,EAA+CvI,OAA/C,CAAP;AACD,GAFD;AAGD,CAJD,C,CAMA;;;AACA,MAAM6R,yBAAyB,GAAG,CAACtJ,QAAD,EAAWvI,OAAX,KAAuB;AACvD,MAAI,CAACA,OAAO,CAACiJ,MAAb,EACE,OAAOf,SAAP;AAEF/J,EAAAA,KAAK,CAAC6B,OAAO,CAACiJ,MAAT,EAAiB7K,MAAjB,CAAL;;AAEA,QAAMkK,WAAW,GAAGC,QAAQ,CAAC3B,eAAT,CAAyB5G,OAAO,CAACiJ,MAAjC,CAApB,CANuD,CAQvD;AACA;AACA;;;AACA,MAAIhJ,IAAI,GAAGsI,QAAQ,CAACpI,KAAT,CAAeC,OAAf,CACT;AAAC,+CAA2CkI;AAA5C,GADS,EAET;AAACnC,IAAAA,MAAM,EAAE;AAAC,uCAAiC;AAAlC;AAAT,GAFS,CAAX;;AAIA,MAAI,CAAElG,IAAN,EAAY;AACV;AACA;AACA;AACA;AACA;AACAA,IAAAA,IAAI,GAAGsI,QAAQ,CAACpI,KAAT,CAAeC,OAAf,CAAuB;AAC1BP,MAAAA,GAAG,EAAE,CACH;AAAC,mDAA2CyI;AAA5C,OADG,EAEH;AAAC,6CAAqCtI,OAAO,CAACiJ;AAA9C,OAFG;AADqB,KAAvB,EAML;AACA;AAAC9C,MAAAA,MAAM,EAAE;AAAC,uCAA+B;AAAhC;AAAT,KAPK,CAAP;AAQD;;AAED,MAAI,CAAElG,IAAN,EACE,OAAO;AACLc,IAAAA,KAAK,EAAE,IAAItB,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,4DAAtB;AADF,GAAP,CAhCqD,CAoCvD;AACA;AACA;;AACA,MAAImT,qBAAJ;AACA,MAAI7O,KAAK,GAAGhD,IAAI,CAAC+I,QAAL,CAAcC,MAAd,CAAqBC,WAArB,CAAiCxI,IAAjC,CAAsCuC,KAAK,IACrDA,KAAK,CAACqF,WAAN,KAAsBA,WADZ,CAAZ;;AAGA,MAAIrF,KAAJ,EAAW;AACT6O,IAAAA,qBAAqB,GAAG,KAAxB;AACD,GAFD,MAEO;AACL7O,IAAAA,KAAK,GAAGhD,IAAI,CAAC+I,QAAL,CAAcC,MAAd,CAAqBC,WAArB,CAAiCxI,IAAjC,CAAsCuC,KAAK,IACjDA,KAAK,CAACA,KAAN,KAAgBjD,OAAO,CAACiJ,MADlB,CAAR;AAGA6I,IAAAA,qBAAqB,GAAG,IAAxB;AACD;;AAED,QAAMhL,YAAY,GAAGyB,QAAQ,CAACxB,gBAAT,CAA0B9D,KAAK,CAAC+D,IAAhC,CAArB;;AACA,MAAI,IAAIkG,IAAJ,MAAcpG,YAAlB,EACE,OAAO;AACL5C,IAAAA,MAAM,EAAEjE,IAAI,CAAC2K,GADR;AAEL7J,IAAAA,KAAK,EAAE,IAAItB,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,gDAAtB;AAFF,GAAP,CAtDqD,CA2DvD;;AACA,MAAImT,qBAAJ,EAA2B;AACzB;AACA;AACA;AACA;AACA;AACAvJ,IAAAA,QAAQ,CAACpI,KAAT,CAAeiI,MAAf,CACE;AACEwC,MAAAA,GAAG,EAAE3K,IAAI,CAAC2K,GADZ;AAEE,2CAAqC5K,OAAO,CAACiJ;AAF/C,KADF,EAKE;AAACiD,MAAAA,SAAS,EAAE;AACR,uCAA+B;AAC7B,yBAAe5D,WADc;AAE7B,kBAAQrF,KAAK,CAAC+D;AAFe;AADvB;AAAZ,KALF,EANyB,CAmBzB;AACA;AACA;;AACAuB,IAAAA,QAAQ,CAACpI,KAAT,CAAeiI,MAAf,CAAsBnI,IAAI,CAAC2K,GAA3B,EAAgC;AAC9BvC,MAAAA,KAAK,EAAE;AACL,uCAA+B;AAAE,mBAASrI,OAAO,CAACiJ;AAAnB;AAD1B;AADuB,KAAhC;AAKD;;AAED,SAAO;AACL/E,IAAAA,MAAM,EAAEjE,IAAI,CAAC2K,GADR;AAELrE,IAAAA,iBAAiB,EAAE;AACjBtD,MAAAA,KAAK,EAAEjD,OAAO,CAACiJ,MADE;AAEjBjC,MAAAA,IAAI,EAAE/D,KAAK,CAAC+D;AAFK;AAFd,GAAP;AAOD,CAhGD;;AAkGA,MAAMyG,mBAAmB,GAAG,CAC1BlF,QAD0B,EAE1B6E,eAF0B,EAG1BG,WAH0B,EAI1BrJ,MAJ0B,KAKvB;AACH;AACA,MAAI6N,QAAQ,GAAG,KAAf;AACA,QAAMjE,UAAU,GAAG5J,MAAM,GAAG;AAAC0G,IAAAA,GAAG,EAAE1G;AAAN,GAAH,GAAmB,EAA5C,CAHG,CAIH;;AACA,MAAGqJ,WAAW,CAAC,iCAAD,CAAd,EAAmD;AACjDwE,IAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,MAAIC,YAAY,GAAG;AACjBnS,IAAAA,GAAG,EAAE,CACH;AAAE,sCAAgC;AAAEkO,QAAAA,GAAG,EAAEX;AAAP;AAAlC,KADG,EAEH;AAAE,sCAAgC;AAAEW,QAAAA,GAAG,EAAE,CAACX;AAAR;AAAlC,KAFG;AADY,GAAnB;;AAMA,MAAG2E,QAAH,EAAa;AACXC,IAAAA,YAAY,GAAG;AACbnS,MAAAA,GAAG,EAAE,CACH;AAAE,yCAAiC;AAAEkO,UAAAA,GAAG,EAAEX;AAAP;AAAnC,OADG,EAEH;AAAE,yCAAiC;AAAEW,UAAAA,GAAG,EAAE,CAACX;AAAR;AAAnC,OAFG;AADQ,KAAf;AAMD;;AACD,QAAM6E,YAAY,GAAG;AAAErS,IAAAA,IAAI,EAAE,CAAC2N,WAAD,EAAcyE,YAAd;AAAR,GAArB;;AACA,MAAGD,QAAH,EAAa;AACXxJ,IAAAA,QAAQ,CAACpI,KAAT,CAAeiI,MAAf,iCAA0B0F,UAA1B,GAAyCmE,YAAzC,GAAwD;AACtD7C,MAAAA,MAAM,EAAE;AACN,oCAA4B;AADtB;AAD8C,KAAxD,EAIG;AAAEpB,MAAAA,KAAK,EAAE;AAAT,KAJH;AAKD,GAND,MAMO;AACLzF,IAAAA,QAAQ,CAACpI,KAAT,CAAeiI,MAAf,iCAA0B0F,UAA1B,GAAyCmE,YAAzC,GAAwD;AACtD7C,MAAAA,MAAM,EAAE;AACN,mCAA2B;AADrB;AAD8C,KAAxD,EAIG;AAAEpB,MAAAA,KAAK,EAAE;AAAT,KAJH;AAKD;AAEF,CA1CD;;AA4CA,MAAM1L,uBAAuB,GAAGiG,QAAQ,IAAI;AAC1CA,EAAAA,QAAQ,CAAC6F,mBAAT,GAA+B3O,MAAM,CAACyS,WAAP,CAAmB,MAAM;AACtD3J,IAAAA,QAAQ,CAACqF,aAAT;;AACArF,IAAAA,QAAQ,CAAC4E,0BAAT;;AACA5E,IAAAA,QAAQ,CAACmF,2BAAT;AACD,GAJ8B,EAI5BjQ,yBAJ4B,CAA/B;AAKD,CAND,C,CAQA;AACA;AACA;;;AAEA,MAAM0M,eAAe,GACnBJ,OAAO,CAAC,kBAAD,CAAP,IACAA,OAAO,CAAC,kBAAD,CAAP,CAA4BI,eAF9B;;AAIA,MAAMF,oBAAoB,GAAG,MAAM;AACjC,SAAOE,eAAe,IAAIA,eAAe,CAACgI,WAAhB,EAA1B;AACD,CAFD,C,CAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM1D,wBAAwB,GAAG,CAACgB,WAAD,EAAcvL,MAAd,KAAyB;AACxDtG,EAAAA,MAAM,CAACwD,IAAP,CAAYqO,WAAZ,EAAyBjB,OAAzB,CAAiC3K,GAAG,IAAI;AACtC,QAAIC,KAAK,GAAG2L,WAAW,CAAC5L,GAAD,CAAvB;AACA,QAAIsG,eAAe,IAAIA,eAAe,CAACiI,QAAhB,CAAyBtO,KAAzB,CAAvB,EACEA,KAAK,GAAGqG,eAAe,CAACC,IAAhB,CAAqBD,eAAe,CAACkI,IAAhB,CAAqBvO,KAArB,CAArB,EAAkDI,MAAlD,CAAR;AACFuL,IAAAA,WAAW,CAAC5L,GAAD,CAAX,GAAmBC,KAAnB;AACD,GALD;AAMD,CAPD,C,CAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEArE,MAAM,CAACkL,OAAP,CAAe,MAAM;AACnB,MAAI,CAAEV,oBAAoB,EAA1B,EAA8B;AAC5B;AACD;;AAED,QAAM;AAAEH,IAAAA;AAAF,MAA2BC,OAAO,CAAC,uBAAD,CAAxC;AAEAD,EAAAA,oBAAoB,CAACE,cAArB,CAAoCtJ,IAApC,CAAyC;AACvCd,IAAAA,IAAI,EAAE,CAAC;AACLsK,MAAAA,MAAM,EAAE;AAAEsD,QAAAA,OAAO,EAAE;AAAX;AADH,KAAD,EAEH;AACD,0BAAoB;AAAEA,QAAAA,OAAO,EAAE;AAAX;AADnB,KAFG;AADiC,GAAzC,EAMGgB,OANH,CAMWP,MAAM,IAAI;AACnBnE,IAAAA,oBAAoB,CAACE,cAArB,CAAoC5B,MAApC,CAA2C6F,MAAM,CAACrD,GAAlD,EAAuD;AACrDwB,MAAAA,IAAI,EAAE;AACJlC,QAAAA,MAAM,EAAEC,eAAe,CAACC,IAAhB,CAAqB6D,MAAM,CAAC/D,MAA5B;AADJ;AAD+C,KAAvD;AAKD,GAZD;AAaD,CApBD,E,CAsBA;AACA;;AACA,MAAMyE,qBAAqB,GAAG,CAAC3O,OAAD,EAAUC,IAAV,KAAmB;AAC/C,MAAID,OAAO,CAAC6B,OAAZ,EACE5B,IAAI,CAAC4B,OAAL,GAAe7B,OAAO,CAAC6B,OAAvB;AACF,SAAO5B,IAAP;AACD,CAJD,C,CAMA;;;AACA,SAAS0C,0BAAT,CAAoC1C,IAApC,EAA0C;AACxC,QAAM8O,MAAM,GAAG,KAAK/N,QAAL,CAAcgO,6BAA7B;;AACA,MAAI,CAACD,MAAL,EAAa;AACX,WAAO,IAAP;AACD;;AAED,MAAIuD,WAAW,GAAG,KAAlB;;AACA,MAAIrS,IAAI,CAAC6B,MAAL,IAAe7B,IAAI,CAAC6B,MAAL,CAAYzD,MAAZ,GAAqB,CAAxC,EAA2C;AACzCiU,IAAAA,WAAW,GAAGrS,IAAI,CAAC6B,MAAL,CAAYiJ,MAAZ,CACZ,CAACC,IAAD,EAAOxK,KAAP,KAAiBwK,IAAI,IAAI,KAAK8D,gBAAL,CAAsBtO,KAAK,CAAC8Q,OAA5B,CADb,EACmD,KADnD,CAAd;AAGD,GAJD,MAIO,IAAIrR,IAAI,CAAC+I,QAAL,IAAiBpL,MAAM,CAAC2U,MAAP,CAActS,IAAI,CAAC+I,QAAnB,EAA6B3K,MAA7B,GAAsC,CAA3D,EAA8D;AACnE;AACAiU,IAAAA,WAAW,GAAG1U,MAAM,CAAC2U,MAAP,CAActS,IAAI,CAAC+I,QAAnB,EAA6B+B,MAA7B,CACZ,CAACC,IAAD,EAAOtB,OAAP,KAAmBA,OAAO,CAAClJ,KAAR,IAAiB,KAAKsO,gBAAL,CAAsBpF,OAAO,CAAClJ,KAA9B,CADxB,EAEZ,KAFY,CAAd;AAID;;AAED,MAAI8R,WAAJ,EAAiB;AACf,WAAO,IAAP;AACD;;AAED,MAAI,OAAOvD,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,UAAM,IAAItP,MAAM,CAACd,KAAX,CAAiB,GAAjB,aAA0BoQ,MAA1B,qBAAN;AACD,GAFD,MAEO;AACL,UAAM,IAAItP,MAAM,CAACd,KAAX,CAAiB,GAAjB,EAAsB,mCAAtB,CAAN;AACD;AACF;;AAED,MAAMyD,oBAAoB,GAAGjC,KAAK,IAAI;AACpC;AACA;AACA;AACAA,EAAAA,KAAK,CAACqS,KAAN,CAAY;AACV;AACA;AACApK,IAAAA,MAAM,EAAE,CAAClE,MAAD,EAASjE,IAAT,EAAekG,MAAf,EAAuBsM,QAAvB,KAAoC;AAC1C;AACA,UAAIxS,IAAI,CAAC2K,GAAL,KAAa1G,MAAjB,EAAyB;AACvB,eAAO,KAAP;AACD,OAJyC,CAM1C;AACA;AACA;;;AACA,UAAIiC,MAAM,CAAC9H,MAAP,KAAkB,CAAlB,IAAuB8H,MAAM,CAAC,CAAD,CAAN,KAAc,SAAzC,EAAoD;AAClD,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD,KAjBS;AAkBVxF,IAAAA,KAAK,EAAE,CAAC,KAAD,CAlBG,CAkBK;;AAlBL,GAAZ,EAJoC,CAyBpC;;AACAR,EAAAA,KAAK,CAACuS,WAAN,CAAkB,UAAlB,EAA8B;AAAEC,IAAAA,MAAM,EAAE,IAAV;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAA9B;AACAzS,EAAAA,KAAK,CAACuS,WAAN,CAAkB,gBAAlB,EAAoC;AAAEC,IAAAA,MAAM,EAAE,IAAV;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GAApC;AACAzS,EAAAA,KAAK,CAACuS,WAAN,CAAkB,yCAAlB,EACE;AAAEC,IAAAA,MAAM,EAAE,IAAV;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GADF;AAEAzS,EAAAA,KAAK,CAACuS,WAAN,CAAkB,mCAAlB,EACE;AAAEC,IAAAA,MAAM,EAAE,IAAV;AAAgBC,IAAAA,MAAM,EAAE;AAAxB,GADF,EA9BoC,CAgCpC;AACA;;AACAzS,EAAAA,KAAK,CAACuS,WAAN,CAAkB,yCAAlB,EACE;AAAEE,IAAAA,MAAM,EAAE;AAAV,GADF,EAlCoC,CAoCpC;;AACAzS,EAAAA,KAAK,CAACuS,WAAN,CAAkB,kCAAlB,EAAsD;AAAEE,IAAAA,MAAM,EAAE;AAAV,GAAtD,EArCoC,CAsCpC;;AACAzS,EAAAA,KAAK,CAACuS,WAAN,CAAkB,8BAAlB,EAAkD;AAAEE,IAAAA,MAAM,EAAE;AAAV,GAAlD;AACAzS,EAAAA,KAAK,CAACuS,WAAN,CAAkB,+BAAlB,EAAmD;AAAEE,IAAAA,MAAM,EAAE;AAAV,GAAnD;AACD,CAzCD,C,CA4CA;;;AACA,MAAMxT,iCAAiC,GAAGN,MAAM,IAAI;AAClD,MAAI+T,YAAY,GAAG,CAAC,EAAD,CAAnB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhU,MAAM,CAACT,MAA3B,EAAmCyU,CAAC,EAApC,EAAwC;AACtC,UAAMC,EAAE,GAAGjU,MAAM,CAACkU,MAAP,CAAcF,CAAd,CAAX;AACAD,IAAAA,YAAY,GAAG,GAAGI,MAAH,CAAU,GAAIJ,YAAY,CAACxT,GAAb,CAAiBN,MAAM,IAAI;AACtD,YAAMmU,aAAa,GAAGH,EAAE,CAACI,WAAH,EAAtB;AACA,YAAMC,aAAa,GAAGL,EAAE,CAACM,WAAH,EAAtB,CAFsD,CAGtD;;AACA,UAAIH,aAAa,KAAKE,aAAtB,EAAqC;AACnC,eAAO,CAACrU,MAAM,GAAGgU,EAAV,CAAP;AACD,OAFD,MAEO;AACL,eAAO,CAAChU,MAAM,GAAGmU,aAAV,EAAyBnU,MAAM,GAAGqU,aAAlC,CAAP;AACD;AACF,KAT4B,CAAd,CAAf;AAUD;;AACD,SAAOP,YAAP;AACD,CAhBD","sourcesContent":["import crypto from 'crypto';\nimport {\n  AccountsCommon,\n  EXPIRE_TOKENS_INTERVAL_MS,\n} from './accounts_common.js';\nimport { URL } from 'meteor/url';\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\n// XXX maybe this belongs in the check package\nconst NonEmptyString = Match.Where(x => {\n  check(x, String);\n  return x.length > 0;\n});\n\n/**\n * @summary Constructor for the `Accounts` namespace on the server.\n * @locus Server\n * @class AccountsServer\n * @extends AccountsCommon\n * @instancename accountsServer\n * @param {Object} server A server object such as `Meteor.server`.\n */\nexport class AccountsServer extends AccountsCommon {\n  // Note that this constructor is less likely to be instantiated multiple\n  // times than the `AccountsClient` constructor, because a single server\n  // can provide only one set of methods.\n  constructor(server) {\n    super();\n\n    this._server = server || Meteor.server;\n    // Set up the server's methods, as if by calling Meteor.methods.\n    this._initServerMethods();\n\n    this._initAccountDataHooks();\n\n    // If autopublish is on, publish these user fields. Login service\n    // packages (eg accounts-google) add to these by calling\n    // addAutopublishFields.  Notably, this isn't implemented with multiple\n    // publishes since DDP only merges only across top-level fields, not\n    // subfields (such as 'services.facebook.accessToken')\n    this._autopublishFields = {\n      loggedInUser: ['profile', 'username', 'emails'],\n      otherUsers: ['profile', 'username']\n    };\n\n    // use object to keep the reference when used in functions\n    // where _defaultPublishFields is destructured into lexical scope\n    // for publish callbacks that need `this`\n    this._defaultPublishFields = {\n      projection: {\n        profile: 1,\n        username: 1,\n        emails: 1,\n      }\n    };\n\n    this._initServerPublications();\n\n    // connectionId -> {connection, loginToken}\n    this._accountData = {};\n\n    // connection id -> observe handle for the login token that this connection is\n    // currently associated with, or a number. The number indicates that we are in\n    // the process of setting up the observe (using a number instead of a single\n    // sentinel allows multiple attempts to set up the observe to identify which\n    // one was theirs).\n    this._userObservesForConnections = {};\n    this._nextUserObserveNumber = 1;  // for the number described above.\n\n    // list of all registered handlers.\n    this._loginHandlers = [];\n\n    setupUsersCollection(this.users);\n    setupDefaultLoginHandlers(this);\n    setExpireTokensInterval(this);\n\n    this._validateLoginHook = new Hook({ bindEnvironment: false });\n    this._validateNewUserHooks = [\n      defaultValidateNewUserHook.bind(this)\n    ];\n\n    this._deleteSavedTokensForAllUsersOnStartup();\n\n    this._skipCaseInsensitiveChecksForTest = {};\n\n    this.urls = {\n      resetPassword: (token, extraParams) => this.buildEmailUrl(`#/reset-password/${token}`, extraParams),\n      verifyEmail: (token, extraParams) => this.buildEmailUrl(`#/verify-email/${token}`, extraParams),\n      loginToken: (selector, token, extraParams) =>\n        this.buildEmailUrl(`/?loginToken=${token}&selector=${selector}`, extraParams),\n      enrollAccount: (token, extraParams) => this.buildEmailUrl(`#/enroll-account/${token}`, extraParams),\n    };\n\n    this.addDefaultRateLimit();\n\n    this.buildEmailUrl = (path, extraParams = {}) => {\n      const url = new URL(Meteor.absoluteUrl(path));\n      const params = Object.entries(extraParams);\n      if (params.length > 0) {\n        // Add additional parameters to the url\n        for (const [key, value] of params) {\n          url.searchParams.append(key, value);\n        }\n      }\n      return url.toString();\n    };\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override of \"abstract\" non-implementation in accounts_common.js\n  userId() {\n    // This function only works if called inside a method or a pubication.\n    // Using any of the information from Meteor.user() in a method or\n    // publish function will always use the value from when the function first\n    // runs. This is likely not what the user expects. The way to make this work\n    // in a method or publish function is to do Meteor.find(this.userId).observe\n    // and recompute when the user record changes.\n    const currentInvocation = DDP._CurrentMethodInvocation.get() || DDP._CurrentPublicationInvocation.get();\n    if (!currentInvocation)\n      throw new Error(\"Meteor.userId can only be invoked in method calls or publications.\");\n    return currentInvocation.userId;\n  }\n\n  ///\n  /// LOGIN HOOKS\n  ///\n\n  /**\n   * @summary Validate login attempts.\n   * @locus Server\n   * @param {Function} func Called whenever a login is attempted (either successful or unsuccessful).  A login can be aborted by returning a falsy value or throwing an exception.\n   */\n  validateLoginAttempt(func) {\n    // Exceptions inside the hook callback are passed up to us.\n    return this._validateLoginHook.register(func);\n  }\n\n  /**\n   * @summary Set restrictions on new user creation.\n   * @locus Server\n   * @param {Function} func Called whenever a new user is created. Takes the new user object, and returns true to allow the creation or false to abort.\n   */\n  validateNewUser(func) {\n    this._validateNewUserHooks.push(func);\n  }\n\n  /**\n   * @summary Validate login from external service\n   * @locus Server\n   * @param {Function} func Called whenever login/user creation from external service is attempted. Login or user creation based on this login can be aborted by passing a falsy value or throwing an exception.\n   */\n  beforeExternalLogin(func) {\n    if (this._beforeExternalLoginHook) {\n      throw new Error(\"Can only call beforeExternalLogin once\");\n    }\n\n    this._beforeExternalLoginHook = func;\n  }\n\n  ///\n  /// CREATE USER HOOKS\n  ///\n\n  /**\n   * @summary Customize login token creation.\n   * @locus Server\n   * @param {Function} func Called whenever a new token is created.\n   * Return the sequence and the user object. Return true to keep sending the default email, or false to override the behavior.\n   */\n  onCreateLoginToken = function(func) {\n    if (this._onCreateLoginTokenHook) {\n      throw new Error('Can only call onCreateLoginToken once');\n    }\n\n    this._onCreateLoginTokenHook = func;\n  };\n\n  /**\n   * @summary Customize new user creation.\n   * @locus Server\n   * @param {Function} func Called whenever a new user is created. Return the new user object, or throw an `Error` to abort the creation.\n   */\n  onCreateUser(func) {\n    if (this._onCreateUserHook) {\n      throw new Error(\"Can only call onCreateUser once\");\n    }\n\n    this._onCreateUserHook = func;\n  }\n\n  /**\n   * @summary Customize oauth user profile updates\n   * @locus Server\n   * @param {Function} func Called whenever a user is logged in via oauth. Return the profile object to be merged, or throw an `Error` to abort the creation.\n   */\n  onExternalLogin(func) {\n    if (this._onExternalLoginHook) {\n      throw new Error(\"Can only call onExternalLogin once\");\n    }\n\n    this._onExternalLoginHook = func;\n  }\n\n  /**\n   * @summary Customize user selection on external logins\n   * @locus Server\n   * @param {Function} func Called whenever a user is logged in via oauth and a\n   * user is not found with the service id. Return the user or undefined.\n   */\n  setAdditionalFindUserOnExternalLogin(func) {\n    if (this._additionalFindUserOnExternalLogin) {\n      throw new Error(\"Can only call setAdditionalFindUserOnExternalLogin once\");\n    }\n    this._additionalFindUserOnExternalLogin = func;\n  }\n\n  _validateLogin(connection, attempt) {\n    this._validateLoginHook.each(callback => {\n      let ret;\n      try {\n        ret = callback(cloneAttemptWithConnection(connection, attempt));\n      }\n      catch (e) {\n        attempt.allowed = false;\n        // XXX this means the last thrown error overrides previous error\n        // messages. Maybe this is surprising to users and we should make\n        // overriding errors more explicit. (see\n        // https://github.com/meteor/meteor/issues/1960)\n        attempt.error = e;\n        return true;\n      }\n      if (! ret) {\n        attempt.allowed = false;\n        // don't override a specific error provided by a previous\n        // validator or the initial attempt (eg \"incorrect password\").\n        if (!attempt.error)\n          attempt.error = new Meteor.Error(403, \"Login forbidden\");\n      }\n      return true;\n    });\n  };\n\n  _successfulLogin(connection, attempt) {\n    this._onLoginHook.each(callback => {\n      callback(cloneAttemptWithConnection(connection, attempt));\n      return true;\n    });\n  };\n\n  _failedLogin(connection, attempt) {\n    this._onLoginFailureHook.each(callback => {\n      callback(cloneAttemptWithConnection(connection, attempt));\n      return true;\n    });\n  };\n\n  _successfulLogout(connection, userId) {\n    // don't fetch the user object unless there are some callbacks registered\n    let user;\n    this._onLogoutHook.each(callback => {\n      if (!user && userId) user = this.users.findOne(userId, {fields: this._options.defaultFieldSelector});\n      callback({ user, connection });\n      return true;\n    });\n  };\n\n  // Generates a MongoDB selector that can be used to perform a fast case\n  // insensitive lookup for the given fieldName and string. Since MongoDB does\n  // not support case insensitive indexes, and case insensitive regex queries\n  // are slow, we construct a set of prefix selectors for all permutations of\n  // the first 4 characters ourselves. We first attempt to matching against\n  // these, and because 'prefix expression' regex queries do use indexes (see\n  // http://docs.mongodb.org/v2.6/reference/operator/query/regex/#index-use),\n  // this has been found to greatly improve performance (from 1200ms to 5ms in a\n  // test with 1.000.000 users).\n  _selectorForFastCaseInsensitiveLookup = (fieldName, string) => {\n    // Performance seems to improve up to 4 prefix characters\n    const prefix = string.substring(0, Math.min(string.length, 4));\n    const orClause = generateCasePermutationsForString(prefix).map(\n        prefixPermutation => {\n          const selector = {};\n          selector[fieldName] =\n              new RegExp(`^${Meteor._escapeRegExp(prefixPermutation)}`);\n          return selector;\n        });\n    const caseInsensitiveClause = {};\n    caseInsensitiveClause[fieldName] =\n        new RegExp(`^${Meteor._escapeRegExp(string)}$`, 'i')\n    return {$and: [{$or: orClause}, caseInsensitiveClause]};\n  }\n\n  _findUserByQuery = (query, options) => {\n    let user = null;\n\n    if (query.id) {\n      // default field selector is added within getUserById()\n      user = Meteor.users.findOne(query.id, this._addDefaultFieldSelector(options));\n    } else {\n      options = this._addDefaultFieldSelector(options);\n      let fieldName;\n      let fieldValue;\n      if (query.username) {\n        fieldName = 'username';\n        fieldValue = query.username;\n      } else if (query.email) {\n        fieldName = 'emails.address';\n        fieldValue = query.email;\n      } else {\n        throw new Error(\"shouldn't happen (validation missed something)\");\n      }\n      let selector = {};\n      selector[fieldName] = fieldValue;\n      user = Meteor.users.findOne(selector, options);\n      // If user is not found, try a case insensitive lookup\n      if (!user) {\n        selector = this._selectorForFastCaseInsensitiveLookup(fieldName, fieldValue);\n        const candidateUsers = Meteor.users.find(selector, options).fetch();\n        // No match if multiple candidates are found\n        if (candidateUsers.length === 1) {\n          user = candidateUsers[0];\n        }\n      }\n    }\n\n    return user;\n  }\n\n  ///\n  /// LOGIN METHODS\n  ///\n\n  // Login methods return to the client an object containing these\n  // fields when the user was logged in successfully:\n  //\n  //   id: userId\n  //   token: *\n  //   tokenExpires: *\n  //\n  // tokenExpires is optional and intends to provide a hint to the\n  // client as to when the token will expire. If not provided, the\n  // client will call Accounts._tokenExpiration, passing it the date\n  // that it received the token.\n  //\n  // The login method will throw an error back to the client if the user\n  // failed to log in.\n  //\n  //\n  // Login handlers and service specific login methods such as\n  // `createUser` internally return a `result` object containing these\n  // fields:\n  //\n  //   type:\n  //     optional string; the service name, overrides the handler\n  //     default if present.\n  //\n  //   error:\n  //     exception; if the user is not allowed to login, the reason why.\n  //\n  //   userId:\n  //     string; the user id of the user attempting to login (if\n  //     known), required for an allowed login.\n  //\n  //   options:\n  //     optional object merged into the result returned by the login\n  //     method; used by HAMK from SRP.\n  //\n  //   stampedLoginToken:\n  //     optional object with `token` and `when` indicating the login\n  //     token is already present in the database, returned by the\n  //     \"resume\" login handler.\n  //\n  // For convenience, login methods can also throw an exception, which\n  // is converted into an {error} result.  However, if the id of the\n  // user attempting the login is known, a {userId, error} result should\n  // be returned instead since the user id is not captured when an\n  // exception is thrown.\n  //\n  // This internal `result` object is automatically converted into the\n  // public {id, token, tokenExpires} object returned to the client.\n\n  // Try a login method, converting thrown exceptions into an {error}\n  // result.  The `type` argument is a default, inserted into the result\n  // object if not explicitly returned.\n  //\n  // Log in a user on a connection.\n  //\n  // We use the method invocation to set the user id on the connection,\n  // not the connection object directly. setUserId is tied to methods to\n  // enforce clear ordering of method application (using wait methods on\n  // the client, and a no setUserId after unblock restriction on the\n  // server)\n  //\n  // The `stampedLoginToken` parameter is optional.  When present, it\n  // indicates that the login token has already been inserted into the\n  // database and doesn't need to be inserted again.  (It's used by the\n  // \"resume\" login handler).\n  _loginUser(methodInvocation, userId, stampedLoginToken) {\n    if (! stampedLoginToken) {\n      stampedLoginToken = this._generateStampedLoginToken();\n      this._insertLoginToken(userId, stampedLoginToken);\n    }\n\n    // This order (and the avoidance of yields) is important to make\n    // sure that when publish functions are rerun, they see a\n    // consistent view of the world: the userId is set and matches\n    // the login token on the connection (not that there is\n    // currently a public API for reading the login token on a\n    // connection).\n    Meteor._noYieldsAllowed(() =>\n      this._setLoginToken(\n        userId,\n        methodInvocation.connection,\n        this._hashLoginToken(stampedLoginToken.token)\n      )\n    );\n\n    methodInvocation.setUserId(userId);\n\n    return {\n      id: userId,\n      token: stampedLoginToken.token,\n      tokenExpires: this._tokenExpiration(stampedLoginToken.when)\n    };\n  };\n\n  // After a login method has completed, call the login hooks.  Note\n  // that `attemptLogin` is called for *all* login attempts, even ones\n  // which aren't successful (such as an invalid password, etc).\n  //\n  // If the login is allowed and isn't aborted by a validate login hook\n  // callback, log in the user.\n  //\n  _attemptLogin(\n    methodInvocation,\n    methodName,\n    methodArgs,\n    result\n  ) {\n    if (!result)\n      throw new Error(\"result is required\");\n\n    // XXX A programming error in a login handler can lead to this occurring, and\n    // then we don't call onLogin or onLoginFailure callbacks. Should\n    // tryLoginMethod catch this case and turn it into an error?\n    if (!result.userId && !result.error)\n      throw new Error(\"A login method must specify a userId or an error\");\n\n    let user;\n    if (result.userId)\n      user = this.users.findOne(result.userId, {fields: this._options.defaultFieldSelector});\n\n    const attempt = {\n      type: result.type || \"unknown\",\n      allowed: !! (result.userId && !result.error),\n      methodName: methodName,\n      methodArguments: Array.from(methodArgs)\n    };\n    if (result.error) {\n      attempt.error = result.error;\n    }\n    if (user) {\n      attempt.user = user;\n    }\n\n    // _validateLogin may mutate `attempt` by adding an error and changing allowed\n    // to false, but that's the only change it can make (and the user's callbacks\n    // only get a clone of `attempt`).\n    this._validateLogin(methodInvocation.connection, attempt);\n\n    if (attempt.allowed) {\n      const ret = {\n        ...this._loginUser(\n          methodInvocation,\n          result.userId,\n          result.stampedLoginToken\n        ),\n        ...result.options\n      };\n      ret.type = attempt.type;\n      this._successfulLogin(methodInvocation.connection, attempt);\n      return ret;\n    }\n    else {\n      this._failedLogin(methodInvocation.connection, attempt);\n      throw attempt.error;\n    }\n  };\n\n  // All service specific login methods should go through this function.\n  // Ensure that thrown exceptions are caught and that login hook\n  // callbacks are still called.\n  //\n  _loginMethod(\n    methodInvocation,\n    methodName,\n    methodArgs,\n    type,\n    fn\n  ) {\n    return this._attemptLogin(\n      methodInvocation,\n      methodName,\n      methodArgs,\n      tryLoginMethod(type, fn)\n    );\n  };\n\n\n  // Report a login attempt failed outside the context of a normal login\n  // method. This is for use in the case where there is a multi-step login\n  // procedure (eg SRP based password login). If a method early in the\n  // chain fails, it should call this function to report a failure. There\n  // is no corresponding method for a successful login; methods that can\n  // succeed at logging a user in should always be actual login methods\n  // (using either Accounts._loginMethod or Accounts.registerLoginHandler).\n  _reportLoginFailure(\n    methodInvocation,\n    methodName,\n    methodArgs,\n    result\n  ) {\n    const attempt = {\n      type: result.type || \"unknown\",\n      allowed: false,\n      error: result.error,\n      methodName: methodName,\n      methodArguments: Array.from(methodArgs)\n    };\n\n    if (result.userId) {\n      attempt.user = this.users.findOne(result.userId, {fields: this._options.defaultFieldSelector});\n    }\n\n    this._validateLogin(methodInvocation.connection, attempt);\n    this._failedLogin(methodInvocation.connection, attempt);\n\n    // _validateLogin may mutate attempt to set a new error message. Return\n    // the modified version.\n    return attempt;\n  };\n\n  ///\n  /// LOGIN HANDLERS\n  ///\n\n  // The main entry point for auth packages to hook in to login.\n  //\n  // A login handler is a login method which can return `undefined` to\n  // indicate that the login request is not handled by this handler.\n  //\n  // @param name {String} Optional.  The service name, used by default\n  // if a specific service name isn't returned in the result.\n  //\n  // @param handler {Function} A function that receives an options object\n  // (as passed as an argument to the `login` method) and returns one of:\n  // - `undefined`, meaning don't handle;\n  // - a login method result object\n\n  registerLoginHandler(name, handler) {\n    if (! handler) {\n      handler = name;\n      name = null;\n    }\n\n    this._loginHandlers.push({\n      name: name,\n      handler: handler\n    });\n  };\n\n\n  // Checks a user's credentials against all the registered login\n  // handlers, and returns a login token if the credentials are valid. It\n  // is like the login method, except that it doesn't set the logged-in\n  // user on the connection. Throws a Meteor.Error if logging in fails,\n  // including the case where none of the login handlers handled the login\n  // request. Otherwise, returns {id: userId, token: *, tokenExpires: *}.\n  //\n  // For example, if you want to login with a plaintext password, `options` could be\n  //   { user: { username: <username> }, password: <password> }, or\n  //   { user: { email: <email> }, password: <password> }.\n\n  // Try all of the registered login handlers until one of them doesn't\n  // return `undefined`, meaning it handled this call to `login`. Return\n  // that return value.\n  _runLoginHandlers(methodInvocation, options) {\n    for (let handler of this._loginHandlers) {\n      const result = tryLoginMethod(\n        handler.name,\n        () => handler.handler.call(methodInvocation, options)\n      );\n\n      if (result) {\n        return result;\n      }\n\n      if (result !== undefined) {\n        throw new Meteor.Error(400, \"A login handler should return a result or undefined\");\n      }\n    }\n\n    return {\n      type: null,\n      error: new Meteor.Error(400, \"Unrecognized options for login request\")\n    };\n  };\n\n  // Deletes the given loginToken from the database.\n  //\n  // For new-style hashed token, this will cause all connections\n  // associated with the token to be closed.\n  //\n  // Any connections associated with old-style unhashed tokens will be\n  // in the process of becoming associated with hashed tokens and then\n  // they'll get closed.\n  destroyToken(userId, loginToken) {\n    this.users.update(userId, {\n      $pull: {\n        \"services.resume.loginTokens\": {\n          $or: [\n            { hashedToken: loginToken },\n            { token: loginToken }\n          ]\n        }\n      }\n    });\n  };\n\n  _initServerMethods() {\n    // The methods created in this function need to be created here so that\n    // this variable is available in their scope.\n    const accounts = this;\n\n\n    // This object will be populated with methods and then passed to\n    // accounts._server.methods further below.\n    const methods = {};\n\n    // @returns {Object|null}\n    //   If successful, returns {token: reconnectToken, id: userId}\n    //   If unsuccessful (for example, if the user closed the oauth login popup),\n    //     throws an error describing the reason\n    methods.login = function (options) {\n      // Login handlers should really also check whatever field they look at in\n      // options, but we don't enforce it.\n      check(options, Object);\n\n      const result = accounts._runLoginHandlers(this, options);\n\n      return accounts._attemptLogin(this, \"login\", arguments, result);\n    };\n\n    methods.logout = function () {\n      const token = accounts._getLoginToken(this.connection.id);\n      accounts._setLoginToken(this.userId, this.connection, null);\n      if (token && this.userId) {\n        accounts.destroyToken(this.userId, token);\n      }\n      accounts._successfulLogout(this.connection, this.userId);\n      this.setUserId(null);\n    };\n\n    // Generates a new login token with the same expiration as the\n    // connection's current token and saves it to the database. Associates\n    // the connection with this new token and returns it. Throws an error\n    // if called on a connection that isn't logged in.\n    //\n    // @returns Object\n    //   If successful, returns { token: <new token>, id: <user id>,\n    //   tokenExpires: <expiration date> }.\n    methods.getNewToken = function () {\n      const user = accounts.users.findOne(this.userId, {\n        fields: { \"services.resume.loginTokens\": 1 }\n      });\n      if (! this.userId || ! user) {\n        throw new Meteor.Error(\"You are not logged in.\");\n      }\n      // Be careful not to generate a new token that has a later\n      // expiration than the curren token. Otherwise, a bad guy with a\n      // stolen token could use this method to stop his stolen token from\n      // ever expiring.\n      const currentHashedToken = accounts._getLoginToken(this.connection.id);\n      const currentStampedToken = user.services.resume.loginTokens.find(\n        stampedToken => stampedToken.hashedToken === currentHashedToken\n      );\n      if (! currentStampedToken) { // safety belt: this should never happen\n        throw new Meteor.Error(\"Invalid login token\");\n      }\n      const newStampedToken = accounts._generateStampedLoginToken();\n      newStampedToken.when = currentStampedToken.when;\n      accounts._insertLoginToken(this.userId, newStampedToken);\n      return accounts._loginUser(this, this.userId, newStampedToken);\n    };\n\n    // Removes all tokens except the token associated with the current\n    // connection. Throws an error if the connection is not logged\n    // in. Returns nothing on success.\n    methods.removeOtherTokens = function () {\n      if (! this.userId) {\n        throw new Meteor.Error(\"You are not logged in.\");\n      }\n      const currentToken = accounts._getLoginToken(this.connection.id);\n      accounts.users.update(this.userId, {\n        $pull: {\n          \"services.resume.loginTokens\": { hashedToken: { $ne: currentToken } }\n        }\n      });\n    };\n\n    // Allow a one-time configuration for a login service. Modifications\n    // to this collection are also allowed in insecure mode.\n    methods.configureLoginService = (options) => {\n      check(options, Match.ObjectIncluding({service: String}));\n      // Don't let random users configure a service we haven't added yet (so\n      // that when we do later add it, it's set up with their configuration\n      // instead of ours).\n      // XXX if service configuration is oauth-specific then this code should\n      //     be in accounts-oauth; if it's not then the registry should be\n      //     in this package\n      if (!(accounts.oauth\n        && accounts.oauth.serviceNames().includes(options.service))) {\n        throw new Meteor.Error(403, \"Service unknown\");\n      }\n\n      const { ServiceConfiguration } = Package['service-configuration'];\n      if (ServiceConfiguration.configurations.findOne({service: options.service}))\n        throw new Meteor.Error(403, `Service ${options.service} already configured`);\n\n      if (hasOwn.call(options, 'secret') && usingOAuthEncryption())\n        options.secret = OAuthEncryption.seal(options.secret);\n\n      ServiceConfiguration.configurations.insert(options);\n    };\n\n    accounts._server.methods(methods);\n  };\n\n  _initAccountDataHooks() {\n    this._server.onConnection(connection => {\n      this._accountData[connection.id] = {\n        connection: connection\n      };\n\n      connection.onClose(() => {\n        this._removeTokenFromConnection(connection.id);\n        delete this._accountData[connection.id];\n      });\n    });\n  };\n\n  _initServerPublications() {\n    // Bring into lexical scope for publish callbacks that need `this`\n    const { users, _autopublishFields, _defaultPublishFields } = this;\n\n    // Publish all login service configuration fields other than secret.\n    this._server.publish(\"meteor.loginServiceConfiguration\", () => {\n      const { ServiceConfiguration } = Package['service-configuration'];\n      return ServiceConfiguration.configurations.find({}, {fields: {secret: 0}});\n    }, {is_auto: true}); // not technically autopublish, but stops the warning.\n\n    // Use Meteor.startup to give other packages a chance to call\n    // setDefaultPublishFields.\n    Meteor.startup(() => {\n      // Publish the current user's record to the client.\n      this._server.publish(null, function () {\n        if (this.userId) {\n          return users.find({\n            _id: this.userId\n          }, {\n            fields: _defaultPublishFields.projection,\n          });\n        } else {\n          return null;\n        }\n      }, /*suppress autopublish warning*/{is_auto: true});\n    });\n\n    // Use Meteor.startup to give other packages a chance to call\n    // addAutopublishFields.\n    Package.autopublish && Meteor.startup(() => {\n      // ['profile', 'username'] -> {profile: 1, username: 1}\n      const toFieldSelector = fields => fields.reduce((prev, field) => (\n          { ...prev, [field]: 1 }),\n        {}\n      );\n      this._server.publish(null, function () {\n        if (this.userId) {\n          return users.find({ _id: this.userId }, {\n            fields: toFieldSelector(_autopublishFields.loggedInUser),\n          })\n        } else {\n          return null;\n        }\n      }, /*suppress autopublish warning*/{is_auto: true});\n\n      // XXX this publish is neither dedup-able nor is it optimized by our special\n      // treatment of queries on a specific _id. Therefore this will have O(n^2)\n      // run-time performance every time a user document is changed (eg someone\n      // logging in). If this is a problem, we can instead write a manual publish\n      // function which filters out fields based on 'this.userId'.\n      this._server.publish(null, function () {\n        const selector = this.userId ? { _id: { $ne: this.userId } } : {};\n        return users.find(selector, {\n          fields: toFieldSelector(_autopublishFields.otherUsers),\n        })\n      }, /*suppress autopublish warning*/{is_auto: true});\n    });\n  };\n\n  // Add to the list of fields or subfields to be automatically\n  // published if autopublish is on. Must be called from top-level\n  // code (ie, before Meteor.startup hooks run).\n  //\n  // @param opts {Object} with:\n  //   - forLoggedInUser {Array} Array of fields published to the logged-in user\n  //   - forOtherUsers {Array} Array of fields published to users that aren't logged in\n  addAutopublishFields(opts) {\n    this._autopublishFields.loggedInUser.push.apply(\n      this._autopublishFields.loggedInUser, opts.forLoggedInUser);\n    this._autopublishFields.otherUsers.push.apply(\n      this._autopublishFields.otherUsers, opts.forOtherUsers);\n  };\n\n  // Replaces the fields to be automatically\n  // published when the user logs in\n  //\n  // @param {MongoFieldSpecifier} fields Dictionary of fields to return or exclude.\n  setDefaultPublishFields(fields) {\n    this._defaultPublishFields.projection = fields;\n  };\n\n  ///\n  /// ACCOUNT DATA\n  ///\n\n  // HACK: This is used by 'meteor-accounts' to get the loginToken for a\n  // connection. Maybe there should be a public way to do that.\n  _getAccountData(connectionId, field) {\n    const data = this._accountData[connectionId];\n    return data && data[field];\n  };\n\n  _setAccountData(connectionId, field, value) {\n    const data = this._accountData[connectionId];\n\n    // safety belt. shouldn't happen. accountData is set in onConnection,\n    // we don't have a connectionId until it is set.\n    if (!data)\n      return;\n\n    if (value === undefined)\n      delete data[field];\n    else\n      data[field] = value;\n  };\n\n  ///\n  /// RECONNECT TOKENS\n  ///\n  /// support reconnecting using a meteor login token\n\n  _hashLoginToken(loginToken) {\n    const hash = crypto.createHash('sha256');\n    hash.update(loginToken);\n    return hash.digest('base64');\n  };\n\n  // {token, when} => {hashedToken, when}\n  _hashStampedToken(stampedToken) {\n    const { token, ...hashedStampedToken } = stampedToken;\n    return {\n      ...hashedStampedToken,\n      hashedToken: this._hashLoginToken(token)\n    };\n  };\n\n  // Using $addToSet avoids getting an index error if another client\n  // logging in simultaneously has already inserted the new hashed\n  // token.\n  _insertHashedLoginToken(userId, hashedToken, query) {\n    query = query ? { ...query } : {};\n    query._id = userId;\n    this.users.update(query, {\n      $addToSet: {\n        \"services.resume.loginTokens\": hashedToken\n      }\n    });\n  };\n\n  // Exported for tests.\n  _insertLoginToken(userId, stampedToken, query) {\n    this._insertHashedLoginToken(\n      userId,\n      this._hashStampedToken(stampedToken),\n      query\n    );\n  };\n\n  _clearAllLoginTokens(userId) {\n    this.users.update(userId, {\n      $set: {\n        'services.resume.loginTokens': []\n      }\n    });\n  };\n\n  // test hook\n  _getUserObserve(connectionId) {\n    return this._userObservesForConnections[connectionId];\n  };\n\n  // Clean up this connection's association with the token: that is, stop\n  // the observe that we started when we associated the connection with\n  // this token.\n  _removeTokenFromConnection(connectionId) {\n    if (hasOwn.call(this._userObservesForConnections, connectionId)) {\n      const observe = this._userObservesForConnections[connectionId];\n      if (typeof observe === 'number') {\n        // We're in the process of setting up an observe for this connection. We\n        // can't clean up that observe yet, but if we delete the placeholder for\n        // this connection, then the observe will get cleaned up as soon as it has\n        // been set up.\n        delete this._userObservesForConnections[connectionId];\n      } else {\n        delete this._userObservesForConnections[connectionId];\n        observe.stop();\n      }\n    }\n  };\n\n  _getLoginToken(connectionId) {\n    return this._getAccountData(connectionId, 'loginToken');\n  };\n\n  // newToken is a hashed token.\n  _setLoginToken(userId, connection, newToken) {\n    this._removeTokenFromConnection(connection.id);\n    this._setAccountData(connection.id, 'loginToken', newToken);\n\n    if (newToken) {\n      // Set up an observe for this token. If the token goes away, we need\n      // to close the connection.  We defer the observe because there's\n      // no need for it to be on the critical path for login; we just need\n      // to ensure that the connection will get closed at some point if\n      // the token gets deleted.\n      //\n      // Initially, we set the observe for this connection to a number; this\n      // signifies to other code (which might run while we yield) that we are in\n      // the process of setting up an observe for this connection. Once the\n      // observe is ready to go, we replace the number with the real observe\n      // handle (unless the placeholder has been deleted or replaced by a\n      // different placehold number, signifying that the connection was closed\n      // already -- in this case we just clean up the observe that we started).\n      const myObserveNumber = ++this._nextUserObserveNumber;\n      this._userObservesForConnections[connection.id] = myObserveNumber;\n      Meteor.defer(() => {\n        // If something else happened on this connection in the meantime (it got\n        // closed, or another call to _setLoginToken happened), just do\n        // nothing. We don't need to start an observe for an old connection or old\n        // token.\n        if (this._userObservesForConnections[connection.id] !== myObserveNumber) {\n          return;\n        }\n\n        let foundMatchingUser;\n        // Because we upgrade unhashed login tokens to hashed tokens at\n        // login time, sessions will only be logged in with a hashed\n        // token. Thus we only need to observe hashed tokens here.\n        const observe = this.users.find({\n          _id: userId,\n          'services.resume.loginTokens.hashedToken': newToken\n        }, { fields: { _id: 1 } }).observeChanges({\n          added: () => {\n            foundMatchingUser = true;\n          },\n          removed: connection.close,\n          // The onClose callback for the connection takes care of\n          // cleaning up the observe handle and any other state we have\n          // lying around.\n        }, { nonMutatingCallbacks: true });\n\n        // If the user ran another login or logout command we were waiting for the\n        // defer or added to fire (ie, another call to _setLoginToken occurred),\n        // then we let the later one win (start an observe, etc) and just stop our\n        // observe now.\n        //\n        // Similarly, if the connection was already closed, then the onClose\n        // callback would have called _removeTokenFromConnection and there won't\n        // be an entry in _userObservesForConnections. We can stop the observe.\n        if (this._userObservesForConnections[connection.id] !== myObserveNumber) {\n          observe.stop();\n          return;\n        }\n\n        this._userObservesForConnections[connection.id] = observe;\n\n        if (! foundMatchingUser) {\n          // We've set up an observe on the user associated with `newToken`,\n          // so if the new token is removed from the database, we'll close\n          // the connection. But the token might have already been deleted\n          // before we set up the observe, which wouldn't have closed the\n          // connection because the observe wasn't running yet.\n          connection.close();\n        }\n      });\n    }\n  };\n\n  // (Also used by Meteor Accounts server and tests).\n  //\n  _generateStampedLoginToken() {\n    return {\n      token: Random.secret(),\n      when: new Date\n    };\n  };\n\n  ///\n  /// TOKEN EXPIRATION\n  ///\n\n  // Deletes expired password reset tokens from the database.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n  _expirePasswordResetTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getPasswordResetTokenLifetimeMs();\n\n    // when calling from a test with extra arguments, you must specify both!\n    if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate ||\n      (new Date(new Date() - tokenLifetimeMs));\n\n    const tokenFilter = {\n      $or: [\n        { \"services.password.reset.reason\": \"reset\"},\n        { \"services.password.reset.reason\": {$exists: false}}\n      ]\n    };\n\n    expirePasswordToken(this, oldestValidDate, tokenFilter, userId);\n  }\n\n  // Deletes expired password enroll tokens from the database.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n  _expirePasswordEnrollTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getPasswordEnrollTokenLifetimeMs();\n\n    // when calling from a test with extra arguments, you must specify both!\n    if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate ||\n      (new Date(new Date() - tokenLifetimeMs));\n\n    const tokenFilter = {\n      \"services.password.enroll.reason\": \"enroll\"\n    };\n\n    expirePasswordToken(this, oldestValidDate, tokenFilter, userId);\n  }\n\n  // Deletes expired tokens from the database and closes all open connections\n  // associated with these tokens.\n  //\n  // Exported for tests. Also, the arguments are only used by\n  // tests. oldestValidDate is simulate expiring tokens without waiting\n  // for them to actually expire. userId is used by tests to only expire\n  // tokens for the test user.\n  _expireTokens(oldestValidDate, userId) {\n    const tokenLifetimeMs = this._getTokenLifetimeMs();\n\n    // when calling from a test with extra arguments, you must specify both!\n    if ((oldestValidDate && !userId) || (!oldestValidDate && userId)) {\n      throw new Error(\"Bad test. Must specify both oldestValidDate and userId.\");\n    }\n\n    oldestValidDate = oldestValidDate ||\n      (new Date(new Date() - tokenLifetimeMs));\n    const userFilter = userId ? {_id: userId} : {};\n\n\n    // Backwards compatible with older versions of meteor that stored login token\n    // timestamps as numbers.\n    this.users.update({ ...userFilter,\n      $or: [\n        { \"services.resume.loginTokens.when\": { $lt: oldestValidDate } },\n        { \"services.resume.loginTokens.when\": { $lt: +oldestValidDate } }\n      ]\n    }, {\n      $pull: {\n        \"services.resume.loginTokens\": {\n          $or: [\n            { when: { $lt: oldestValidDate } },\n            { when: { $lt: +oldestValidDate } }\n          ]\n        }\n      }\n    }, { multi: true });\n    // The observe on Meteor.users will take care of closing connections for\n    // expired tokens.\n  };\n\n  // @override from accounts_common.js\n  config(options) {\n    // Call the overridden implementation of the method.\n    const superResult = AccountsCommon.prototype.config.apply(this, arguments);\n\n    // If the user set loginExpirationInDays to null, then we need to clear the\n    // timer that periodically expires tokens.\n    if (hasOwn.call(this._options, 'loginExpirationInDays') &&\n      this._options.loginExpirationInDays === null &&\n      this.expireTokenInterval) {\n      Meteor.clearInterval(this.expireTokenInterval);\n      this.expireTokenInterval = null;\n    }\n\n    return superResult;\n  };\n\n  // Called by accounts-password\n  insertUserDoc(options, user) {\n    // - clone user document, to protect from modification\n    // - add createdAt timestamp\n    // - prepare an _id, so that you can modify other collections (eg\n    // create a first task for every new user)\n    //\n    // XXX If the onCreateUser or validateNewUser hooks fail, we might\n    // end up having modified some other collection\n    // inappropriately. The solution is probably to have onCreateUser\n    // accept two callbacks - one that gets called before inserting\n    // the user document (in which you can modify its contents), and\n    // one that gets called after (in which you should change other\n    // collections)\n    user = {\n      createdAt: new Date(),\n      _id: Random.id(),\n      ...user,\n    };\n\n    if (user.services) {\n      Object.keys(user.services).forEach(service =>\n        pinEncryptedFieldsToUser(user.services[service], user._id)\n      );\n    }\n\n    let fullUser;\n    if (this._onCreateUserHook) {\n      fullUser = this._onCreateUserHook(options, user);\n\n      // This is *not* part of the API. We need this because we can't isolate\n      // the global server environment between tests, meaning we can't test\n      // both having a create user hook set and not having one set.\n      if (fullUser === 'TEST DEFAULT HOOK')\n        fullUser = defaultCreateUserHook(options, user);\n    } else {\n      fullUser = defaultCreateUserHook(options, user);\n    }\n\n    this._validateNewUserHooks.forEach(hook => {\n      if (! hook(fullUser))\n        throw new Meteor.Error(403, \"User validation failed\");\n    });\n\n    let userId;\n    try {\n      userId = this.users.insert(fullUser);\n    } catch (e) {\n      // XXX string parsing sucks, maybe\n      // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\n      // https://jira.mongodb.org/browse/SERVER-4637\n      if (!e.errmsg) throw e;\n      if (e.errmsg.includes('emails.address'))\n        throw new Meteor.Error(403, \"Email already exists.\");\n      if (e.errmsg.includes('username'))\n        throw new Meteor.Error(403, \"Username already exists.\");\n      throw e;\n    }\n    return userId;\n  };\n\n  // Helper function: returns false if email does not match company domain from\n  // the configuration.\n  _testEmailDomain(email) {\n    const domain = this._options.restrictCreationByEmailDomain;\n\n    return !domain ||\n      (typeof domain === 'function' && domain(email)) ||\n      (typeof domain === 'string' &&\n        (new RegExp(`@${Meteor._escapeRegExp(domain)}$`, 'i')).test(email));\n  };\n\n  ///\n  /// CLEAN UP FOR `logoutOtherClients`\n  ///\n\n  _deleteSavedTokensForUser(userId, tokensToDelete) {\n    if (tokensToDelete) {\n      this.users.update(userId, {\n        $unset: {\n          \"services.resume.haveLoginTokensToDelete\": 1,\n          \"services.resume.loginTokensToDelete\": 1\n        },\n        $pullAll: {\n          \"services.resume.loginTokens\": tokensToDelete\n        }\n      });\n    }\n  };\n\n  _deleteSavedTokensForAllUsersOnStartup() {\n    // If we find users who have saved tokens to delete on startup, delete\n    // them now. It's possible that the server could have crashed and come\n    // back up before new tokens are found in localStorage, but this\n    // shouldn't happen very often. We shouldn't put a delay here because\n    // that would give a lot of power to an attacker with a stolen login\n    // token and the ability to crash the server.\n    Meteor.startup(() => {\n      this.users.find({\n        \"services.resume.haveLoginTokensToDelete\": true\n      }, {fields: {\n          \"services.resume.loginTokensToDelete\": 1\n        }}).forEach(user => {\n        this._deleteSavedTokensForUser(\n          user._id,\n          user.services.resume.loginTokensToDelete\n        );\n      });\n    });\n  };\n\n  ///\n  /// MANAGING USER OBJECTS\n  ///\n\n  // Updates or creates a user after we authenticate with a 3rd party.\n  //\n  // @param serviceName {String} Service name (eg, twitter).\n  // @param serviceData {Object} Data to store in the user's record\n  //        under services[serviceName]. Must include an \"id\" field\n  //        which is a unique identifier for the user in the service.\n  // @param options {Object, optional} Other options to pass to insertUserDoc\n  //        (eg, profile)\n  // @returns {Object} Object with token and id keys, like the result\n  //        of the \"login\" method.\n  //\n  updateOrCreateUserFromExternalService(\n    serviceName,\n    serviceData,\n    options\n  ) {\n    options = { ...options };\n\n    if (serviceName === \"password\" || serviceName === \"resume\") {\n      throw new Error(\n        \"Can't use updateOrCreateUserFromExternalService with internal service \"\n        + serviceName);\n    }\n    if (!hasOwn.call(serviceData, 'id')) {\n      throw new Error(\n        `Service data for service ${serviceName} must include id`);\n    }\n\n    // Look for a user with the appropriate service user id.\n    const selector = {};\n    const serviceIdKey = `services.${serviceName}.id`;\n\n    // XXX Temporary special case for Twitter. (Issue #629)\n    //   The serviceData.id will be a string representation of an integer.\n    //   We want it to match either a stored string or int representation.\n    //   This is to cater to earlier versions of Meteor storing twitter\n    //   user IDs in number form, and recent versions storing them as strings.\n    //   This can be removed once migration technology is in place, and twitter\n    //   users stored with integer IDs have been migrated to string IDs.\n    if (serviceName === \"twitter\" && !isNaN(serviceData.id)) {\n      selector[\"$or\"] = [{},{}];\n      selector[\"$or\"][0][serviceIdKey] = serviceData.id;\n      selector[\"$or\"][1][serviceIdKey] = parseInt(serviceData.id, 10);\n    } else {\n      selector[serviceIdKey] = serviceData.id;\n    }\n\n    let user = this.users.findOne(selector, {fields: this._options.defaultFieldSelector});\n\n    // Check to see if the developer has a custom way to find the user outside\n    // of the general selectors above.\n    if (!user && this._additionalFindUserOnExternalLogin) {\n      user = this._additionalFindUserOnExternalLogin({serviceName, serviceData, options})\n    }\n\n    // Before continuing, run user hook to see if we should continue\n    if (this._beforeExternalLoginHook && !this._beforeExternalLoginHook(serviceName, serviceData, user)) {\n      throw new Meteor.Error(403, \"Login forbidden\");\n    }\n\n    // When creating a new user we pass through all options. When updating an\n    // existing user, by default we only process/pass through the serviceData\n    // (eg, so that we keep an unexpired access token and don't cache old email\n    // addresses in serviceData.email). The onExternalLogin hook can be used when\n    // creating or updating a user, to modify or pass through more options as\n    // needed.\n    let opts = user ? {} : options;\n    if (this._onExternalLoginHook) {\n      opts = this._onExternalLoginHook(options, user);\n    }\n\n    if (user) {\n      pinEncryptedFieldsToUser(serviceData, user._id);\n\n      let setAttrs = {};\n      Object.keys(serviceData).forEach(key =>\n        setAttrs[`services.${serviceName}.${key}`] = serviceData[key]\n      );\n\n      // XXX Maybe we should re-use the selector above and notice if the update\n      //     touches nothing?\n      setAttrs = { ...setAttrs, ...opts };\n      this.users.update(user._id, {\n        $set: setAttrs\n      });\n\n      return {\n        type: serviceName,\n        userId: user._id\n      };\n    } else {\n      // Create a new user with the service data.\n      user = {services: {}};\n      user.services[serviceName] = serviceData;\n      return {\n        type: serviceName,\n        userId: this.insertUserDoc(opts, user)\n      };\n    }\n  };\n\n  // Removes default rate limiting rule\n  removeDefaultRateLimit() {\n    const resp = DDPRateLimiter.removeRule(this.defaultRateLimiterRuleId);\n    this.defaultRateLimiterRuleId = null;\n    return resp;\n  };\n\n  // Add a default rule of limiting logins, creating new users and password reset\n  // to 5 times every 10 seconds per connection.\n  addDefaultRateLimit() {\n    if (!this.defaultRateLimiterRuleId) {\n      this.defaultRateLimiterRuleId = DDPRateLimiter.addRule({\n        userId: null,\n        clientAddress: null,\n        type: 'method',\n        name: name => ['login', 'createUser', 'resetPassword', 'forgotPassword']\n          .includes(name),\n        connectionId: (connectionId) => true,\n      }, 5, 10000);\n    }\n  };\n\n  /**\n   * @summary Creates options for email sending for reset password and enroll account emails.\n   * You can use this function when customizing a reset password or enroll account email sending.\n   * @locus Server\n   * @param {Object} email Which address of the user's to send the email to.\n   * @param {Object} user The user object to generate options for.\n   * @param {String} url URL to which user is directed to confirm the email.\n   * @param {String} reason `resetPassword` or `enrollAccount`.\n   * @returns {Object} Options which can be passed to `Email.send`.\n   * @importFromPackage accounts-base\n   */\n  generateOptionsForEmail(email, user, url, reason, extra = {}){\n    const options = {\n      to: email,\n      from: this.emailTemplates[reason].from\n        ? this.emailTemplates[reason].from(user)\n        : this.emailTemplates.from,\n      subject: this.emailTemplates[reason].subject(user, url, extra),\n    };\n\n    if (typeof this.emailTemplates[reason].text === 'function') {\n      options.text = this.emailTemplates[reason].text(user, url, extra);\n    }\n\n    if (typeof this.emailTemplates[reason].html === 'function') {\n      options.html = this.emailTemplates[reason].html(user, url, extra);\n    }\n\n    if (typeof this.emailTemplates.headers === 'object') {\n      options.headers = this.emailTemplates.headers;\n    }\n\n    return options;\n  };\n\n  _checkForCaseInsensitiveDuplicates(\n    fieldName,\n    displayName,\n    fieldValue,\n    ownUserId\n  ) {\n    // Some tests need the ability to add users with the same case insensitive\n    // value, hence the _skipCaseInsensitiveChecksForTest check\n    const skipCheck = Object.prototype.hasOwnProperty.call(\n      this._skipCaseInsensitiveChecksForTest,\n      fieldValue\n    );\n\n    if (fieldValue && !skipCheck) {\n      const matchedUsers = Meteor.users\n        .find(\n          this._selectorForFastCaseInsensitiveLookup(fieldName, fieldValue),\n          {\n            fields: { _id: 1 },\n            // we only need a maximum of 2 users for the logic below to work\n            limit: 2,\n          }\n        )\n        .fetch();\n\n      if (\n        matchedUsers.length > 0 &&\n        // If we don't have a userId yet, any match we find is a duplicate\n        (!ownUserId ||\n          // Otherwise, check to see if there are multiple matches or a match\n          // that is not us\n          matchedUsers.length > 1 || matchedUsers[0]._id !== ownUserId)\n      ) {\n        this._handleError(`${displayName} already exists.`);\n      }\n    }\n  };\n\n  _createUserCheckingDuplicates({ user, email, username, options }) {\n    const newUser = {\n      ...user,\n      ...(username ? { username } : {}),\n      ...(email ? { emails: [{ address: email, verified: false }] } : {}),\n    };\n\n    // Perform a case insensitive check before insert\n    this._checkForCaseInsensitiveDuplicates('username', 'Username', username);\n    this._checkForCaseInsensitiveDuplicates('emails.address', 'Email', email);\n\n    const userId = this.insertUserDoc(options, newUser);\n    // Perform another check after insert, in case a matching user has been\n    // inserted in the meantime\n    try {\n      this._checkForCaseInsensitiveDuplicates('username', 'Username', username, userId);\n      this._checkForCaseInsensitiveDuplicates('emails.address', 'Email', email, userId);\n    } catch (ex) {\n      // Remove inserted user if the check fails\n      Meteor.users.remove(userId);\n      throw ex;\n    }\n    return userId;\n  }\n\n  _handleError = (msg, throwError = true) => {\n    const error = new Meteor.Error(\n      403,\n      this._options.ambiguousErrorMessages\n        ? \"Something went wrong. Please check your credentials.\"\n        : msg\n    );\n    if (throwError) {\n      throw error;\n    }\n    return error;\n  }\n\n  _userQueryValidator = Match.Where(user => {\n    check(user, {\n      id: Match.Optional(NonEmptyString),\n      username: Match.Optional(NonEmptyString),\n      email: Match.Optional(NonEmptyString)\n    });\n    if (Object.keys(user).length !== 1)\n      throw new Match.Error(\"User property must have exactly one field\");\n    return true;\n  });\n\n}\n\n// Give each login hook callback a fresh cloned copy of the attempt\n// object, but don't clone the connection.\n//\nconst cloneAttemptWithConnection = (connection, attempt) => {\n  const clonedAttempt = EJSON.clone(attempt);\n  clonedAttempt.connection = connection;\n  return clonedAttempt;\n};\n\nconst tryLoginMethod = (type, fn) => {\n  let result;\n  try {\n    result = fn();\n  }\n  catch (e) {\n    result = {error: e};\n  }\n\n  if (result && !result.type && type)\n    result.type = type;\n\n  return result;\n};\n\nconst setupDefaultLoginHandlers = accounts => {\n  accounts.registerLoginHandler(\"resume\", function (options) {\n    return defaultResumeLoginHandler.call(this, accounts, options);\n  });\n};\n\n// Login handler for resume tokens.\nconst defaultResumeLoginHandler = (accounts, options) => {\n  if (!options.resume)\n    return undefined;\n\n  check(options.resume, String);\n\n  const hashedToken = accounts._hashLoginToken(options.resume);\n\n  // First look for just the new-style hashed login token, to avoid\n  // sending the unhashed token to the database in a query if we don't\n  // need to.\n  let user = accounts.users.findOne(\n    {\"services.resume.loginTokens.hashedToken\": hashedToken},\n    {fields: {\"services.resume.loginTokens.$\": 1}});\n\n  if (! user) {\n    // If we didn't find the hashed login token, try also looking for\n    // the old-style unhashed token.  But we need to look for either\n    // the old-style token OR the new-style token, because another\n    // client connection logging in simultaneously might have already\n    // converted the token.\n    user = accounts.users.findOne({\n        $or: [\n          {\"services.resume.loginTokens.hashedToken\": hashedToken},\n          {\"services.resume.loginTokens.token\": options.resume}\n        ]\n      },\n      // Note: Cannot use ...loginTokens.$ positional operator with $or query.\n      {fields: {\"services.resume.loginTokens\": 1}});\n  }\n\n  if (! user)\n    return {\n      error: new Meteor.Error(403, \"You've been logged out by the server. Please log in again.\")\n    };\n\n  // Find the token, which will either be an object with fields\n  // {hashedToken, when} for a hashed token or {token, when} for an\n  // unhashed token.\n  let oldUnhashedStyleToken;\n  let token = user.services.resume.loginTokens.find(token =>\n    token.hashedToken === hashedToken\n  );\n  if (token) {\n    oldUnhashedStyleToken = false;\n  } else {\n    token = user.services.resume.loginTokens.find(token =>\n      token.token === options.resume\n    );\n    oldUnhashedStyleToken = true;\n  }\n\n  const tokenExpires = accounts._tokenExpiration(token.when);\n  if (new Date() >= tokenExpires)\n    return {\n      userId: user._id,\n      error: new Meteor.Error(403, \"Your session has expired. Please log in again.\")\n    };\n\n  // Update to a hashed token when an unhashed token is encountered.\n  if (oldUnhashedStyleToken) {\n    // Only add the new hashed token if the old unhashed token still\n    // exists (this avoids resurrecting the token if it was deleted\n    // after we read it).  Using $addToSet avoids getting an index\n    // error if another client logging in simultaneously has already\n    // inserted the new hashed token.\n    accounts.users.update(\n      {\n        _id: user._id,\n        \"services.resume.loginTokens.token\": options.resume\n      },\n      {$addToSet: {\n          \"services.resume.loginTokens\": {\n            \"hashedToken\": hashedToken,\n            \"when\": token.when\n          }\n        }}\n    );\n\n    // Remove the old token *after* adding the new, since otherwise\n    // another client trying to login between our removing the old and\n    // adding the new wouldn't find a token to login with.\n    accounts.users.update(user._id, {\n      $pull: {\n        \"services.resume.loginTokens\": { \"token\": options.resume }\n      }\n    });\n  }\n\n  return {\n    userId: user._id,\n    stampedLoginToken: {\n      token: options.resume,\n      when: token.when\n    }\n  };\n};\n\nconst expirePasswordToken = (\n  accounts,\n  oldestValidDate,\n  tokenFilter,\n  userId\n) => {\n  // boolean value used to determine if this method was called from enroll account workflow\n  let isEnroll = false;\n  const userFilter = userId ? {_id: userId} : {};\n  // check if this method was called from enroll account workflow\n  if(tokenFilter['services.password.enroll.reason']) {\n    isEnroll = true;\n  }\n  let resetRangeOr = {\n    $or: [\n      { \"services.password.reset.when\": { $lt: oldestValidDate } },\n      { \"services.password.reset.when\": { $lt: +oldestValidDate } }\n    ]\n  };\n  if(isEnroll) {\n    resetRangeOr = {\n      $or: [\n        { \"services.password.enroll.when\": { $lt: oldestValidDate } },\n        { \"services.password.enroll.when\": { $lt: +oldestValidDate } }\n      ]\n    };\n  }\n  const expireFilter = { $and: [tokenFilter, resetRangeOr] };\n  if(isEnroll) {\n    accounts.users.update({...userFilter, ...expireFilter}, {\n      $unset: {\n        \"services.password.enroll\": \"\"\n      }\n    }, { multi: true });\n  } else {\n    accounts.users.update({...userFilter, ...expireFilter}, {\n      $unset: {\n        \"services.password.reset\": \"\"\n      }\n    }, { multi: true });\n  }\n\n};\n\nconst setExpireTokensInterval = accounts => {\n  accounts.expireTokenInterval = Meteor.setInterval(() => {\n    accounts._expireTokens();\n    accounts._expirePasswordResetTokens();\n    accounts._expirePasswordEnrollTokens();\n  }, EXPIRE_TOKENS_INTERVAL_MS);\n};\n\n///\n/// OAuth Encryption Support\n///\n\nconst OAuthEncryption =\n  Package[\"oauth-encryption\"] &&\n  Package[\"oauth-encryption\"].OAuthEncryption;\n\nconst usingOAuthEncryption = () => {\n  return OAuthEncryption && OAuthEncryption.keyIsLoaded();\n};\n\n// OAuth service data is temporarily stored in the pending credentials\n// collection during the oauth authentication process.  Sensitive data\n// such as access tokens are encrypted without the user id because\n// we don't know the user id yet.  We re-encrypt these fields with the\n// user id included when storing the service data permanently in\n// the users collection.\n//\nconst pinEncryptedFieldsToUser = (serviceData, userId) => {\n  Object.keys(serviceData).forEach(key => {\n    let value = serviceData[key];\n    if (OAuthEncryption && OAuthEncryption.isSealed(value))\n      value = OAuthEncryption.seal(OAuthEncryption.open(value), userId);\n    serviceData[key] = value;\n  });\n};\n\n\n// Encrypt unencrypted login service secrets when oauth-encryption is\n// added.\n//\n// XXX For the oauthSecretKey to be available here at startup, the\n// developer must call Accounts.config({oauthSecretKey: ...}) at load\n// time, instead of in a Meteor.startup block, because the startup\n// block in the app code will run after this accounts-base startup\n// block.  Perhaps we need a post-startup callback?\n\nMeteor.startup(() => {\n  if (! usingOAuthEncryption()) {\n    return;\n  }\n\n  const { ServiceConfiguration } = Package['service-configuration'];\n\n  ServiceConfiguration.configurations.find({\n    $and: [{\n      secret: { $exists: true }\n    }, {\n      \"secret.algorithm\": { $exists: false }\n    }]\n  }).forEach(config => {\n    ServiceConfiguration.configurations.update(config._id, {\n      $set: {\n        secret: OAuthEncryption.seal(config.secret)\n      }\n    });\n  });\n});\n\n// XXX see comment on Accounts.createUser in passwords_server about adding a\n// second \"server options\" argument.\nconst defaultCreateUserHook = (options, user) => {\n  if (options.profile)\n    user.profile = options.profile;\n  return user;\n};\n\n// Validate new user's email or Google/Facebook/GitHub account's email\nfunction defaultValidateNewUserHook(user) {\n  const domain = this._options.restrictCreationByEmailDomain;\n  if (!domain) {\n    return true;\n  }\n\n  let emailIsGood = false;\n  if (user.emails && user.emails.length > 0) {\n    emailIsGood = user.emails.reduce(\n      (prev, email) => prev || this._testEmailDomain(email.address), false\n    );\n  } else if (user.services && Object.values(user.services).length > 0) {\n    // Find any email of any service and check it\n    emailIsGood = Object.values(user.services).reduce(\n      (prev, service) => service.email && this._testEmailDomain(service.email),\n      false,\n    );\n  }\n\n  if (emailIsGood) {\n    return true;\n  }\n\n  if (typeof domain === 'string') {\n    throw new Meteor.Error(403, `@${domain} email required`);\n  } else {\n    throw new Meteor.Error(403, \"Email doesn't match the criteria.\");\n  }\n}\n\nconst setupUsersCollection = users => {\n  ///\n  /// RESTRICTING WRITES TO USER OBJECTS\n  ///\n  users.allow({\n    // clients can modify the profile field of their own document, and\n    // nothing else.\n    update: (userId, user, fields, modifier) => {\n      // make sure it is our record\n      if (user._id !== userId) {\n        return false;\n      }\n\n      // user can only modify the 'profile' field. sets to multiple\n      // sub-keys (eg profile.foo and profile.bar) are merged into entry\n      // in the fields list.\n      if (fields.length !== 1 || fields[0] !== 'profile') {\n        return false;\n      }\n\n      return true;\n    },\n    fetch: ['_id'] // we only look at _id.\n  });\n\n  /// DEFAULT INDEXES ON USERS\n  users.createIndex('username', { unique: true, sparse: true });\n  users.createIndex('emails.address', { unique: true, sparse: true });\n  users.createIndex('services.resume.loginTokens.hashedToken',\n    { unique: true, sparse: true });\n  users.createIndex('services.resume.loginTokens.token',\n    { unique: true, sparse: true });\n  // For taking care of logoutOtherClients calls that crashed before the\n  // tokens were deleted.\n  users.createIndex('services.resume.haveLoginTokensToDelete',\n    { sparse: true });\n  // For expiring login tokens\n  users.createIndex(\"services.resume.loginTokens.when\", { sparse: true });\n  // For expiring password tokens\n  users.createIndex('services.password.reset.when', { sparse: true });\n  users.createIndex('services.password.enroll.when', { sparse: true });\n};\n\n\n// Generates permutations of all case variations of a given string.\nconst generateCasePermutationsForString = string => {\n  let permutations = [''];\n  for (let i = 0; i < string.length; i++) {\n    const ch = string.charAt(i);\n    permutations = [].concat(...(permutations.map(prefix => {\n      const lowerCaseChar = ch.toLowerCase();\n      const upperCaseChar = ch.toUpperCase();\n      // Don't add unnecessary permutations when ch is not a letter\n      if (lowerCaseChar === upperCaseChar) {\n        return [prefix + ch];\n      } else {\n        return [prefix + lowerCaseChar, prefix + upperCaseChar];\n      }\n    })));\n  }\n  return permutations;\n}\n\n"]},"sourceType":"module","hash":"0954c01b7df4a950fc19a6615795562cf93476d3"}
