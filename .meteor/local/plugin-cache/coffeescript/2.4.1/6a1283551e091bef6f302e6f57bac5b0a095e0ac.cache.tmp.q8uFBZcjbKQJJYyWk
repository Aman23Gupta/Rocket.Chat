{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nshare.Route = function () {\n  class Route {\n    constructor(api, path, options, endpoints1) {\n      this.api = api;\n      this.path = path;\n      this.options = options;\n      this.endpoints = endpoints1; // Check if options were provided\n\n      if (!this.endpoints) {\n        this.endpoints = this.options;\n        this.options = {};\n      }\n    }\n    /*\n      Convert all endpoints on the given route into our expected endpoint object if it is a bare\n      function\n       @param {Route} route The route the endpoints belong to\n    */\n\n\n    _resolveEndpoints() {\n      _.each(this.endpoints, function (endpoint, method, endpoints) {\n        if (_.isFunction(endpoint)) {\n          return endpoints[method] = {\n            action: endpoint\n          };\n        }\n      });\n    }\n    /*\n    Configure the authentication and role requirement on all endpoints (except OPTIONS, which must\n    be configured directly on the endpoint)\n     Authentication can be required on an entire route or individual endpoints. If required on an\n    entire route, that serves as the default. If required in any individual endpoints, that will\n    override the default.\n     After the endpoint is configured, all authentication and role requirements of an endpoint can be\n    accessed at <code>endpoint.authRequired</code> and <code>endpoint.roleRequired</code>,\n    respectively.\n     @param {Route} route The route the endpoints belong to\n    @param {Endpoint} endpoint The endpoint to configure\n    */\n\n\n    _configureEndpoints() {\n      _.each(this.endpoints, function (endpoint, method) {\n        var ref, ref1;\n\n        if (method !== 'options') {\n          // Configure acceptable roles\n          if (!((ref = this.options) != null ? ref.roleRequired : void 0)) {\n            this.options.roleRequired = [];\n          }\n\n          if (!endpoint.roleRequired) {\n            endpoint.roleRequired = [];\n          }\n\n          endpoint.roleRequired = _.union(endpoint.roleRequired, this.options.roleRequired); // Make it easier to check if no roles are required\n\n          if (_.isEmpty(endpoint.roleRequired)) {\n            endpoint.roleRequired = false;\n          } // Configure auth requirement\n\n\n          if (endpoint.authRequired === void 0) {\n            if (((ref1 = this.options) != null ? ref1.authRequired : void 0) || endpoint.roleRequired) {\n              endpoint.authRequired = true;\n            } else {\n              endpoint.authRequired = false;\n            }\n          }\n        }\n      }, this);\n    }\n    /*\n    Authenticate an endpoint if required, and return the result of calling it\n     @returns The endpoint response or a 401 if authentication fails\n    */\n\n\n    _callEndpoint(endpointContext, endpoint) {\n      var auth; // Call the endpoint if authentication doesn't fail\n\n      auth = this._authAccepted(endpointContext, endpoint);\n\n      if (auth.success) {\n        if (this._roleAccepted(endpointContext, endpoint)) {\n          return endpoint.action.call(endpointContext);\n        } else {\n          return {\n            statusCode: 403,\n            body: {\n              status: 'error',\n              message: 'You do not have permission to do this.' // Auth failed\n\n            }\n          };\n        }\n      } else {\n        if (auth.data) {\n          return auth.data;\n        } else {\n          return {\n            statusCode: 401,\n            body: {\n              status: 'error',\n              message: 'You must be logged in to do this.'\n            }\n          };\n        }\n      }\n    }\n    /*\n      Authenticate the given endpoint if required\n       Once it's globally configured in the API, authentication can be required on an entire route or\n      individual endpoints. If required on an entire endpoint, that serves as the default. If required\n      in any individual endpoints, that will override the default.\n       @returns An object of the following format:\n     {\n      success: Boolean\n      data: String or Object\n    }\n     where `success` is `true` if all required authentication checks pass and the optional `data`\n    will contain the auth data when successful and an optional error response when auth fails.\n    */\n\n\n    _authAccepted(endpointContext, endpoint) {\n      if (endpoint.authRequired) {\n        return this._authenticate(endpointContext);\n      } else {\n        return {\n          success: true\n        };\n      }\n    }\n    /*\n    Verify the request is being made by an actively logged in user\n     If verified, attach the authenticated user to the context.\n     @returns An object of the following format:\n       {\n        success: Boolean\n        data: String or Object\n      }\n     where `success` is `true` if all required authentication checks pass and the optional `data`\n    will contain the auth data when successful and an optional error response when auth fails.\n    */\n\n\n    _authenticate(endpointContext) {\n      var auth, userSelector; // Get auth info\n\n      auth = this.api._config.auth.user.call(endpointContext);\n\n      if (!auth) {\n        return {\n          success: false\n        };\n      } // Get the user from the database\n\n\n      if (auth.userId && auth.token && !auth.user) {\n        userSelector = {};\n        userSelector._id = auth.userId;\n        userSelector[this.api._config.auth.token] = auth.token;\n        auth.user = Meteor.users.findOne(userSelector);\n      }\n\n      if (auth.error) {\n        return {\n          success: false,\n          data: auth.error\n        };\n      } // Attach the user and their ID to the context if the authentication was successful\n\n\n      if (auth.user) {\n        endpointContext.user = auth.user;\n        endpointContext.userId = auth.user._id;\n        return {\n          success: true,\n          data: auth\n        };\n      } else {\n        return {\n          success: false\n        };\n      }\n    }\n    /*\n    Authenticate the user role if required\n     Must be called after _authAccepted().\n     @returns True if the authenticated user belongs to <i>any</i> of the acceptable roles on the\n           endpoint\n    */\n\n\n    _roleAccepted(endpointContext, endpoint) {\n      if (endpoint.roleRequired) {\n        if (_.isEmpty(_.intersection(endpoint.roleRequired, endpointContext.user.roles))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /*\n    Respond to an HTTP request\n    */\n\n\n    _respond(response, body, statusCode = 200, headers = {}) {\n      var defaultHeaders, delayInMilliseconds, minimumDelayInMilliseconds, randomMultiplierBetweenOneAndTwo, sendResponse; // Override any default headers that have been provided (keys are normalized to be case insensitive)\n      // TODO: Consider only lowercasing the header keys we need normalized, like Content-Type\n\n      defaultHeaders = this._lowerCaseKeys(this.api._config.defaultHeaders);\n      headers = this._lowerCaseKeys(headers);\n      headers = _.extend(defaultHeaders, headers); // Prepare JSON body for response when Content-Type indicates JSON type\n\n      if (headers['content-type'].match(/json|javascript/) !== null) {\n        if (this.api._config.prettyJson) {\n          body = JSON.stringify(body, void 0, 2);\n        } else {\n          body = JSON.stringify(body);\n        }\n      } // Send response\n\n\n      sendResponse = function () {\n        response.writeHead(statusCode, headers);\n        response.write(body);\n        return response.end();\n      };\n\n      if (statusCode === 401 || statusCode === 403) {\n        // Hackers can measure the response time to determine things like whether the 401 response was \n        // caused by bad user id vs bad password.\n        // In doing so, they can first scan for valid user ids regardless of valid passwords.\n        // Delay by a random amount to reduce the ability for a hacker to determine the response time.\n        // See https://www.owasp.org/index.php/Blocking_Brute_Force_Attacks#Finding_Other_Countermeasures\n        // See https://en.wikipedia.org/wiki/Timing_attack\n        minimumDelayInMilliseconds = 500;\n        randomMultiplierBetweenOneAndTwo = 1 + Math.random();\n        delayInMilliseconds = minimumDelayInMilliseconds * randomMultiplierBetweenOneAndTwo;\n        return Meteor.setTimeout(sendResponse, delayInMilliseconds);\n      } else {\n        return sendResponse();\n      }\n    }\n    /*\n      Return the object with all of the keys converted to lowercase\n    */\n\n\n    _lowerCaseKeys(object) {\n      return _.chain(object).pairs().map(function (attr) {\n        return [attr[0].toLowerCase(), attr[1]];\n      }).object().value();\n    }\n\n  }\n\n  ;\n\n  Route.prototype.addToApi = function () {\n    var availableMethods;\n    availableMethods = ['get', 'post', 'put', 'patch', 'delete', 'options'];\n    return function () {\n      var allowedMethods, fullPath, rejectedMethods, self;\n      self = this; // Throw an error if a route has already been added at this path\n      // TODO: Check for collisions with paths that follow same pattern with different parameter names\n\n      if (_.contains(this.api._config.paths, this.path)) {\n        throw new Error(`Cannot add a route at an existing path: ${this.path}`);\n      } // Override the default OPTIONS endpoint with our own\n\n\n      this.endpoints = _.extend({\n        options: this.api._config.defaultOptionsEndpoint\n      }, this.endpoints); // Configure each endpoint on this route\n\n      this._resolveEndpoints();\n\n      this._configureEndpoints(); // Add to our list of existing paths\n\n\n      this.api._config.paths.push(this.path);\n\n      allowedMethods = _.filter(availableMethods, function (method) {\n        return _.contains(_.keys(self.endpoints), method);\n      });\n      rejectedMethods = _.reject(availableMethods, function (method) {\n        return _.contains(_.keys(self.endpoints), method);\n      }); // Setup endpoints on route\n\n      fullPath = this.api._config.apiPath + this.path;\n\n      _.each(allowedMethods, function (method) {\n        var endpoint;\n        endpoint = self.endpoints[method];\n        return JsonRoutes.add(method, fullPath, function (req, res) {\n          var doneFunc, endpointContext, error, responseData, responseInitiated; // Add function to endpoint context for indicating a response has been initiated manually\n\n          responseInitiated = false;\n\n          doneFunc = function () {\n            return responseInitiated = true;\n          };\n\n          endpointContext = {\n            urlParams: req.params,\n            queryParams: req.query,\n            bodyParams: req.body,\n            request: req,\n            response: res,\n            done: doneFunc\n          }; // Add endpoint config options to context\n\n          _.extend(endpointContext, endpoint); // Run the requested endpoint\n\n\n          responseData = null;\n\n          try {\n            responseData = self._callEndpoint(endpointContext, endpoint);\n          } catch (error1) {\n            error = error1; // Do exactly what Iron Router would have done, to avoid changing the API\n\n            ironRouterSendErrorToResponse(error, req, res);\n            return;\n          }\n\n          if (responseInitiated) {\n            // Ensure the response is properly completed\n            res.end();\n            return;\n          } else {\n            if (res.headersSent) {\n              throw new Error(`Must call this.done() after handling endpoint response manually: ${method} ${fullPath}`);\n            } else if (responseData === null || responseData === void 0) {\n              throw new Error(`Cannot return null or undefined from an endpoint: ${method} ${fullPath}`);\n            }\n          } // Generate and return the http response, handling the different endpoint response types\n\n\n          if (responseData.body && (responseData.statusCode || responseData.headers)) {\n            return self._respond(res, responseData.body, responseData.statusCode, responseData.headers);\n          } else {\n            return self._respond(res, responseData);\n          }\n        });\n      });\n\n      return _.each(rejectedMethods, function (method) {\n        return JsonRoutes.add(method, fullPath, function (req, res) {\n          var headers, responseData;\n          responseData = {\n            status: 'error',\n            message: 'API endpoint does not exist'\n          };\n          headers = {\n            'Allow': allowedMethods.join(', ').toUpperCase()\n          };\n          return self._respond(res, responseData, 405, headers);\n        });\n      });\n    };\n  }();\n\n  return Route;\n}.call(this);","sourceMap":{"version":3,"sources":["/packages/rocketchat_restivus/lib/route.coffee","/lib/route.coffee"],"names":["share","Route","constructor","api","path","options","endpoints1","endpoints","_resolveEndpoints","_","each","endpoint","method","isFunction","action","_configureEndpoints","ref","ref1","roleRequired","union","isEmpty","authRequired","_callEndpoint","endpointContext","auth","_authAccepted","success","_roleAccepted","call","statusCode","body","status","message","data","_authenticate","userSelector","_config","user","userId","token","_id","Meteor","users","findOne","error","intersection","roles","_respond","response","headers","defaultHeaders","delayInMilliseconds","minimumDelayInMilliseconds","randomMultiplierBetweenOneAndTwo","sendResponse","_lowerCaseKeys","extend","match","prettyJson","JSON","stringify","writeHead","write","end","Math","random","setTimeout","object","chain","pairs","map","attr","toLowerCase","value","prototype","addToApi","availableMethods","allowedMethods","fullPath","rejectedMethods","self","contains","paths","Error","defaultOptionsEndpoint","push","filter","keys","reject","apiPath","JsonRoutes","add","req","res","doneFunc","responseData","responseInitiated","urlParams","params","queryParams","query","bodyParams","request","done","error1","ironRouterSendErrorToResponse","headersSent","join","toUpperCase"],"mappings":"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","file":"packages/rocketchat:restivus/lib/route.coffee.map","sourcesContent":["class share.Route\n\n  constructor: (@api, @path, @options, @endpoints) ->\n    # Check if options were provided\n    if not @endpoints\n      @endpoints = @options\n      @options = {}\n\n\n  addToApi: do ->\n    availableMethods = ['get', 'post', 'put', 'patch', 'delete', 'options']\n\n    return ->\n      self = this\n\n      # Throw an error if a route has already been added at this path\n      # TODO: Check for collisions with paths that follow same pattern with different parameter names\n      if _.contains @api._config.paths, @path\n        throw new Error \"Cannot add a route at an existing path: #{@path}\"\n\n      # Override the default OPTIONS endpoint with our own\n      @endpoints = _.extend options: @api._config.defaultOptionsEndpoint, @endpoints\n\n      # Configure each endpoint on this route\n      @_resolveEndpoints()\n      @_configureEndpoints()\n\n      # Add to our list of existing paths\n      @api._config.paths.push @path\n\n      allowedMethods = _.filter availableMethods, (method) ->\n        _.contains(_.keys(self.endpoints), method)\n      rejectedMethods = _.reject availableMethods, (method) ->\n        _.contains(_.keys(self.endpoints), method)\n\n      # Setup endpoints on route\n      fullPath = @api._config.apiPath + @path\n      _.each allowedMethods, (method) ->\n        endpoint = self.endpoints[method]\n        JsonRoutes.add method, fullPath, (req, res) ->\n          # Add function to endpoint context for indicating a response has been initiated manually\n          responseInitiated = false\n          doneFunc = ->\n            responseInitiated = true\n\n          endpointContext =\n            urlParams: req.params\n            queryParams: req.query\n            bodyParams: req.body\n            request: req\n            response: res\n            done: doneFunc\n          # Add endpoint config options to context\n          _.extend endpointContext, endpoint\n\n          # Run the requested endpoint\n          responseData = null\n          try\n            responseData = self._callEndpoint endpointContext, endpoint\n          catch error\n            # Do exactly what Iron Router would have done, to avoid changing the API\n            ironRouterSendErrorToResponse(error, req, res);\n            return\n\n          if responseInitiated\n            # Ensure the response is properly completed\n            res.end()\n            return\n          else\n            if res.headersSent\n              throw new Error \"Must call this.done() after handling endpoint response manually: #{method} #{fullPath}\"\n            else if responseData is null or responseData is undefined\n              throw new Error \"Cannot return null or undefined from an endpoint: #{method} #{fullPath}\"\n\n          # Generate and return the http response, handling the different endpoint response types\n          if responseData.body and (responseData.statusCode or responseData.headers)\n            self._respond res, responseData.body, responseData.statusCode, responseData.headers\n          else\n            self._respond res, responseData\n\n      _.each rejectedMethods, (method) ->\n        JsonRoutes.add method, fullPath, (req, res) ->\n          responseData = status: 'error', message: 'API endpoint does not exist'\n          headers = 'Allow': allowedMethods.join(', ').toUpperCase()\n          self._respond res, responseData, 405, headers\n\n\n  ###\n    Convert all endpoints on the given route into our expected endpoint object if it is a bare\n    function\n\n    @param {Route} route The route the endpoints belong to\n  ###\n  _resolveEndpoints: ->\n    _.each @endpoints, (endpoint, method, endpoints) ->\n      if _.isFunction(endpoint)\n        endpoints[method] = {action: endpoint}\n    return\n\n\n  ###\n    Configure the authentication and role requirement on all endpoints (except OPTIONS, which must\n    be configured directly on the endpoint)\n\n    Authentication can be required on an entire route or individual endpoints. If required on an\n    entire route, that serves as the default. If required in any individual endpoints, that will\n    override the default.\n\n    After the endpoint is configured, all authentication and role requirements of an endpoint can be\n    accessed at <code>endpoint.authRequired</code> and <code>endpoint.roleRequired</code>,\n    respectively.\n\n    @param {Route} route The route the endpoints belong to\n    @param {Endpoint} endpoint The endpoint to configure\n  ###\n  _configureEndpoints: ->\n    _.each @endpoints, (endpoint, method) ->\n      if method isnt 'options'\n        # Configure acceptable roles\n        if not @options?.roleRequired\n          @options.roleRequired = []\n        if not endpoint.roleRequired\n          endpoint.roleRequired = []\n        endpoint.roleRequired = _.union endpoint.roleRequired, @options.roleRequired\n        # Make it easier to check if no roles are required\n        if _.isEmpty endpoint.roleRequired\n          endpoint.roleRequired = false\n\n        # Configure auth requirement\n        if endpoint.authRequired is undefined\n          if @options?.authRequired or endpoint.roleRequired\n            endpoint.authRequired = true\n          else\n            endpoint.authRequired = false\n        return\n    , this\n    return\n\n\n  ###\n    Authenticate an endpoint if required, and return the result of calling it\n\n    @returns The endpoint response or a 401 if authentication fails\n  ###\n  _callEndpoint: (endpointContext, endpoint) ->\n    # Call the endpoint if authentication doesn't fail\n    auth = @_authAccepted endpointContext, endpoint\n    if auth.success\n      if @_roleAccepted endpointContext, endpoint\n        return endpoint.action.call endpointContext\n      else return {\n        statusCode: 403\n        body: {status: 'error', message: 'You do not have permission to do this.'}\n      }\n    else # Auth failed\n      if auth.data then return auth.data\n      else return {\n        statusCode: 401\n        body: {status: 'error', message: 'You must be logged in to do this.'}\n      }\n\n\n  ###\n    Authenticate the given endpoint if required\n\n    Once it's globally configured in the API, authentication can be required on an entire route or\n    individual endpoints. If required on an entire endpoint, that serves as the default. If required\n    in any individual endpoints, that will override the default.\n\n    @returns An object of the following format:\n\n        {\n          success: Boolean\n          data: String or Object\n        }\n\n      where `success` is `true` if all required authentication checks pass and the optional `data`\n      will contain the auth data when successful and an optional error response when auth fails.\n  ###\n  _authAccepted: (endpointContext, endpoint) ->\n    if endpoint.authRequired\n      return @_authenticate endpointContext\n    else return { success: true }\n\n\n  ###\n    Verify the request is being made by an actively logged in user\n\n    If verified, attach the authenticated user to the context.\n\n    @returns An object of the following format:\n\n        {\n          success: Boolean\n          data: String or Object\n        }\n\n      where `success` is `true` if all required authentication checks pass and the optional `data`\n      will contain the auth data when successful and an optional error response when auth fails.\n  ###\n  _authenticate: (endpointContext) ->\n    # Get auth info\n    auth = @api._config.auth.user.call(endpointContext)\n\n    if not auth then return { success: false }\n\n    # Get the user from the database\n    if auth.userId and auth.token and not auth.user\n      userSelector = {}\n      userSelector._id = auth.userId\n      userSelector[@api._config.auth.token] = auth.token\n      auth.user = Meteor.users.findOne userSelector\n\n    if auth.error then return { success: false, data: auth.error }\n\n    # Attach the user and their ID to the context if the authentication was successful\n    if auth.user\n      endpointContext.user = auth.user\n      endpointContext.userId = auth.user._id\n      return { success: true , data: auth }\n    else return { success: false }\n\n\n  ###\n    Authenticate the user role if required\n\n    Must be called after _authAccepted().\n\n    @returns True if the authenticated user belongs to <i>any</i> of the acceptable roles on the\n             endpoint\n  ###\n  _roleAccepted: (endpointContext, endpoint) ->\n    if endpoint.roleRequired\n      if _.isEmpty _.intersection(endpoint.roleRequired, endpointContext.user.roles)\n        return false\n    true\n\n\n  ###\n    Respond to an HTTP request\n  ###\n  _respond: (response, body, statusCode=200, headers={}) ->\n    # Override any default headers that have been provided (keys are normalized to be case insensitive)\n    # TODO: Consider only lowercasing the header keys we need normalized, like Content-Type\n    defaultHeaders = @_lowerCaseKeys @api._config.defaultHeaders\n    headers = @_lowerCaseKeys headers\n    headers = _.extend defaultHeaders, headers\n\n    # Prepare JSON body for response when Content-Type indicates JSON type\n    if headers['content-type'].match(/json|javascript/) isnt null\n      if @api._config.prettyJson\n        body = JSON.stringify body, undefined, 2\n      else\n        body = JSON.stringify body\n\n    # Send response\n    sendResponse = ->\n      response.writeHead statusCode, headers\n      response.write body\n      response.end()\n    if statusCode in [401, 403]\n      # Hackers can measure the response time to determine things like whether the 401 response was \n      # caused by bad user id vs bad password.\n      # In doing so, they can first scan for valid user ids regardless of valid passwords.\n      # Delay by a random amount to reduce the ability for a hacker to determine the response time.\n      # See https://www.owasp.org/index.php/Blocking_Brute_Force_Attacks#Finding_Other_Countermeasures\n      # See https://en.wikipedia.org/wiki/Timing_attack\n      minimumDelayInMilliseconds = 500\n      randomMultiplierBetweenOneAndTwo = 1 + Math.random()\n      delayInMilliseconds = minimumDelayInMilliseconds * randomMultiplierBetweenOneAndTwo\n      Meteor.setTimeout sendResponse, delayInMilliseconds\n    else\n      sendResponse()\n\n  ###\n    Return the object with all of the keys converted to lowercase\n  ###\n  _lowerCaseKeys: (object) ->\n    _.chain object\n    .pairs()\n    .map (attr) ->\n      [attr[0].toLowerCase(), attr[1]]\n    .object()\n    .value()\n","share.Route = (function() {\n  class Route {\n    constructor(api, path, options, endpoints1) {\n      this.api = api;\n      this.path = path;\n      this.options = options;\n      this.endpoints = endpoints1;\n      // Check if options were provided\n      if (!this.endpoints) {\n        this.endpoints = this.options;\n        this.options = {};\n      }\n    }\n\n    /*\n      Convert all endpoints on the given route into our expected endpoint object if it is a bare\n      function\n\n      @param {Route} route The route the endpoints belong to\n    */\n    _resolveEndpoints() {\n      _.each(this.endpoints, function(endpoint, method, endpoints) {\n        if (_.isFunction(endpoint)) {\n          return endpoints[method] = {\n            action: endpoint\n          };\n        }\n      });\n    }\n\n    /*\n    Configure the authentication and role requirement on all endpoints (except OPTIONS, which must\n    be configured directly on the endpoint)\n\n    Authentication can be required on an entire route or individual endpoints. If required on an\n    entire route, that serves as the default. If required in any individual endpoints, that will\n    override the default.\n\n    After the endpoint is configured, all authentication and role requirements of an endpoint can be\n    accessed at <code>endpoint.authRequired</code> and <code>endpoint.roleRequired</code>,\n    respectively.\n\n    @param {Route} route The route the endpoints belong to\n    @param {Endpoint} endpoint The endpoint to configure\n    */\n    _configureEndpoints() {\n      _.each(this.endpoints, function(endpoint, method) {\n        var ref, ref1;\n        if (method !== 'options') {\n          // Configure acceptable roles\n          if (!((ref = this.options) != null ? ref.roleRequired : void 0)) {\n            this.options.roleRequired = [];\n          }\n          if (!endpoint.roleRequired) {\n            endpoint.roleRequired = [];\n          }\n          endpoint.roleRequired = _.union(endpoint.roleRequired, this.options.roleRequired);\n          // Make it easier to check if no roles are required\n          if (_.isEmpty(endpoint.roleRequired)) {\n            endpoint.roleRequired = false;\n          }\n          // Configure auth requirement\n          if (endpoint.authRequired === void 0) {\n            if (((ref1 = this.options) != null ? ref1.authRequired : void 0) || endpoint.roleRequired) {\n              endpoint.authRequired = true;\n            } else {\n              endpoint.authRequired = false;\n            }\n          }\n        }\n      }, this);\n    }\n\n    /*\n    Authenticate an endpoint if required, and return the result of calling it\n\n    @returns The endpoint response or a 401 if authentication fails\n    */\n    _callEndpoint(endpointContext, endpoint) {\n      var auth;\n      // Call the endpoint if authentication doesn't fail\n      auth = this._authAccepted(endpointContext, endpoint);\n      if (auth.success) {\n        if (this._roleAccepted(endpointContext, endpoint)) {\n          return endpoint.action.call(endpointContext);\n        } else {\n          return {\n            statusCode: 403,\n            body: {\n              status: 'error',\n              message: 'You do not have permission to do this.' // Auth failed\n            }\n          };\n        }\n      } else {\n        if (auth.data) {\n          return auth.data;\n        } else {\n          return {\n            statusCode: 401,\n            body: {\n              status: 'error',\n              message: 'You must be logged in to do this.'\n            }\n          };\n        }\n      }\n    }\n\n    /*\n      Authenticate the given endpoint if required\n\n      Once it's globally configured in the API, authentication can be required on an entire route or\n      individual endpoints. If required on an entire endpoint, that serves as the default. If required\n      in any individual endpoints, that will override the default.\n\n      @returns An object of the following format:\n\n    {\n      success: Boolean\n      data: String or Object\n    }\n\n    where `success` is `true` if all required authentication checks pass and the optional `data`\n    will contain the auth data when successful and an optional error response when auth fails.\n    */\n    _authAccepted(endpointContext, endpoint) {\n      if (endpoint.authRequired) {\n        return this._authenticate(endpointContext);\n      } else {\n        return {\n          success: true\n        };\n      }\n    }\n\n    /*\n    Verify the request is being made by an actively logged in user\n\n    If verified, attach the authenticated user to the context.\n\n    @returns An object of the following format:\n\n      {\n        success: Boolean\n        data: String or Object\n      }\n\n    where `success` is `true` if all required authentication checks pass and the optional `data`\n    will contain the auth data when successful and an optional error response when auth fails.\n    */\n    _authenticate(endpointContext) {\n      var auth, userSelector;\n      // Get auth info\n      auth = this.api._config.auth.user.call(endpointContext);\n      if (!auth) {\n        return {\n          success: false\n        };\n      }\n      // Get the user from the database\n      if (auth.userId && auth.token && !auth.user) {\n        userSelector = {};\n        userSelector._id = auth.userId;\n        userSelector[this.api._config.auth.token] = auth.token;\n        auth.user = Meteor.users.findOne(userSelector);\n      }\n      if (auth.error) {\n        return {\n          success: false,\n          data: auth.error\n        };\n      }\n      // Attach the user and their ID to the context if the authentication was successful\n      if (auth.user) {\n        endpointContext.user = auth.user;\n        endpointContext.userId = auth.user._id;\n        return {\n          success: true,\n          data: auth\n        };\n      } else {\n        return {\n          success: false\n        };\n      }\n    }\n\n    /*\n    Authenticate the user role if required\n\n    Must be called after _authAccepted().\n\n    @returns True if the authenticated user belongs to <i>any</i> of the acceptable roles on the\n           endpoint\n    */\n    _roleAccepted(endpointContext, endpoint) {\n      if (endpoint.roleRequired) {\n        if (_.isEmpty(_.intersection(endpoint.roleRequired, endpointContext.user.roles))) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /*\n    Respond to an HTTP request\n    */\n    _respond(response, body, statusCode = 200, headers = {}) {\n      var defaultHeaders, delayInMilliseconds, minimumDelayInMilliseconds, randomMultiplierBetweenOneAndTwo, sendResponse;\n      // Override any default headers that have been provided (keys are normalized to be case insensitive)\n      // TODO: Consider only lowercasing the header keys we need normalized, like Content-Type\n      defaultHeaders = this._lowerCaseKeys(this.api._config.defaultHeaders);\n      headers = this._lowerCaseKeys(headers);\n      headers = _.extend(defaultHeaders, headers);\n      // Prepare JSON body for response when Content-Type indicates JSON type\n      if (headers['content-type'].match(/json|javascript/) !== null) {\n        if (this.api._config.prettyJson) {\n          body = JSON.stringify(body, void 0, 2);\n        } else {\n          body = JSON.stringify(body);\n        }\n      }\n      // Send response\n      sendResponse = function() {\n        response.writeHead(statusCode, headers);\n        response.write(body);\n        return response.end();\n      };\n      if (statusCode === 401 || statusCode === 403) {\n        // Hackers can measure the response time to determine things like whether the 401 response was \n        // caused by bad user id vs bad password.\n        // In doing so, they can first scan for valid user ids regardless of valid passwords.\n        // Delay by a random amount to reduce the ability for a hacker to determine the response time.\n        // See https://www.owasp.org/index.php/Blocking_Brute_Force_Attacks#Finding_Other_Countermeasures\n        // See https://en.wikipedia.org/wiki/Timing_attack\n        minimumDelayInMilliseconds = 500;\n        randomMultiplierBetweenOneAndTwo = 1 + Math.random();\n        delayInMilliseconds = minimumDelayInMilliseconds * randomMultiplierBetweenOneAndTwo;\n        return Meteor.setTimeout(sendResponse, delayInMilliseconds);\n      } else {\n        return sendResponse();\n      }\n    }\n\n    /*\n      Return the object with all of the keys converted to lowercase\n    */\n    _lowerCaseKeys(object) {\n      return _.chain(object).pairs().map(function(attr) {\n        return [attr[0].toLowerCase(), attr[1]];\n      }).object().value();\n    }\n\n  };\n\n  Route.prototype.addToApi = (function() {\n    var availableMethods;\n    availableMethods = ['get', 'post', 'put', 'patch', 'delete', 'options'];\n    return function() {\n      var allowedMethods, fullPath, rejectedMethods, self;\n      self = this;\n      // Throw an error if a route has already been added at this path\n      // TODO: Check for collisions with paths that follow same pattern with different parameter names\n      if (_.contains(this.api._config.paths, this.path)) {\n        throw new Error(`Cannot add a route at an existing path: ${this.path}`);\n      }\n      // Override the default OPTIONS endpoint with our own\n      this.endpoints = _.extend({\n        options: this.api._config.defaultOptionsEndpoint\n      }, this.endpoints);\n      // Configure each endpoint on this route\n      this._resolveEndpoints();\n      this._configureEndpoints();\n      // Add to our list of existing paths\n      this.api._config.paths.push(this.path);\n      allowedMethods = _.filter(availableMethods, function(method) {\n        return _.contains(_.keys(self.endpoints), method);\n      });\n      rejectedMethods = _.reject(availableMethods, function(method) {\n        return _.contains(_.keys(self.endpoints), method);\n      });\n      // Setup endpoints on route\n      fullPath = this.api._config.apiPath + this.path;\n      _.each(allowedMethods, function(method) {\n        var endpoint;\n        endpoint = self.endpoints[method];\n        return JsonRoutes.add(method, fullPath, function(req, res) {\n          var doneFunc, endpointContext, error, responseData, responseInitiated;\n          // Add function to endpoint context for indicating a response has been initiated manually\n          responseInitiated = false;\n          doneFunc = function() {\n            return responseInitiated = true;\n          };\n          endpointContext = {\n            urlParams: req.params,\n            queryParams: req.query,\n            bodyParams: req.body,\n            request: req,\n            response: res,\n            done: doneFunc\n          };\n          // Add endpoint config options to context\n          _.extend(endpointContext, endpoint);\n          // Run the requested endpoint\n          responseData = null;\n          try {\n            responseData = self._callEndpoint(endpointContext, endpoint);\n          } catch (error1) {\n            error = error1;\n            // Do exactly what Iron Router would have done, to avoid changing the API\n            ironRouterSendErrorToResponse(error, req, res);\n            return;\n          }\n          if (responseInitiated) {\n            // Ensure the response is properly completed\n            res.end();\n            return;\n          } else {\n            if (res.headersSent) {\n              throw new Error(`Must call this.done() after handling endpoint response manually: ${method} ${fullPath}`);\n            } else if (responseData === null || responseData === void 0) {\n              throw new Error(`Cannot return null or undefined from an endpoint: ${method} ${fullPath}`);\n            }\n          }\n          // Generate and return the http response, handling the different endpoint response types\n          if (responseData.body && (responseData.statusCode || responseData.headers)) {\n            return self._respond(res, responseData.body, responseData.statusCode, responseData.headers);\n          } else {\n            return self._respond(res, responseData);\n          }\n        });\n      });\n      return _.each(rejectedMethods, function(method) {\n        return JsonRoutes.add(method, fullPath, function(req, res) {\n          var headers, responseData;\n          responseData = {\n            status: 'error',\n            message: 'API endpoint does not exist'\n          };\n          headers = {\n            'Allow': allowedMethods.join(', ').toUpperCase()\n          };\n          return self._respond(res, responseData, 405, headers);\n        });\n      });\n    };\n  })();\n\n  return Route;\n\n}).call(this);\n"]}}