{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\nvar indexOf = [].indexOf;\n\nthis.Restivus = function () {\n  class Restivus {\n    constructor(options) {\n      var corsHeaders;\n      this._routes = [];\n      this._config = {\n        paths: [],\n        useDefaultAuth: false,\n        apiPath: 'api/',\n        version: null,\n        prettyJson: false,\n        auth: {\n          token: 'services.resume.loginTokens.hashedToken',\n          user: function () {\n            var token;\n\n            if (this.request.headers['x-auth-token']) {\n              token = Accounts._hashLoginToken(this.request.headers['x-auth-token']);\n            }\n\n            return {\n              userId: this.request.headers['x-user-id'],\n              token: token\n            };\n          }\n        },\n        defaultHeaders: {\n          'Content-Type': 'application/json'\n        },\n        enableCors: true\n      }; // Configure API with the given options\n\n      _.extend(this._config, options);\n\n      if (this._config.enableCors) {\n        corsHeaders = {\n          'Access-Control-Allow-Origin': '*',\n          'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept'\n        };\n\n        if (this._config.useDefaultAuth) {\n          corsHeaders['Access-Control-Allow-Headers'] += ', X-User-Id, X-Auth-Token';\n        } // Set default header to enable CORS if configured\n\n\n        _.extend(this._config.defaultHeaders, corsHeaders);\n\n        if (!this._config.defaultOptionsEndpoint) {\n          this._config.defaultOptionsEndpoint = function () {\n            this.response.writeHead(200, corsHeaders);\n            return this.done();\n          };\n        }\n      } // Normalize the API path\n\n\n      if (this._config.apiPath[0] === '/') {\n        this._config.apiPath = this._config.apiPath.slice(1);\n      }\n\n      if (_.last(this._config.apiPath) !== '/') {\n        this._config.apiPath = this._config.apiPath + '/';\n      } // URL path versioning is the only type of API versioning currently available, so if a version is\n      // provided, append it to the base path of the API\n\n\n      if (this._config.version) {\n        this._config.apiPath += this._config.version + '/';\n      } // Add default login and logout endpoints if auth is configured\n\n\n      if (this._config.useDefaultAuth) {\n        this._initAuth();\n      } else if (this._config.useAuth) {\n        this._initAuth();\n\n        console.warn('Warning: useAuth API config option will be removed in Restivus v1.0 ' + '\\n    Use the useDefaultAuth option instead');\n      }\n\n      return this;\n    }\n    /**\n    Add endpoints for the given HTTP methods at the given path\n     @param path {String} The extended URL path (will be appended to base path of the API)\n    @param options {Object} Route configuration options\n    @param options.authRequired {Boolean} The default auth requirement for each endpoint on the route\n    @param options.roleRequired {String or String[]} The default role required for each endpoint on the route\n    @param endpoints {Object} A set of endpoints available on the new route (get, post, put, patch, delete, options)\n    @param endpoints.<method> {Function or Object} If a function is provided, all default route\n      configuration options will be applied to the endpoint. Otherwise an object with an `action`\n      and all other route config options available. An `action` must be provided with the object.\n    */\n\n\n    addRoute(path, options, endpoints) {\n      var route; // Create a new route and add it to our list of existing routes\n\n      route = new share.Route(this, path, options, endpoints);\n\n      this._routes.push(route);\n\n      route.addToApi();\n      return this;\n    }\n    /**\n    Generate routes for the Meteor Collection with the given name\n    */\n\n\n    addCollection(collection, options = {}) {\n      var collectionEndpoints, collectionRouteEndpoints, endpointsAwaitingConfiguration, entityRouteEndpoints, excludedEndpoints, methods, methodsOnCollection, path, routeOptions;\n      methods = ['get', 'post', 'put', 'patch', 'delete', 'getAll'];\n      methodsOnCollection = ['post', 'getAll']; // Grab the set of endpoints\n\n      if (collection === Meteor.users) {\n        collectionEndpoints = this._userCollectionEndpoints;\n      } else {\n        collectionEndpoints = this._collectionEndpoints;\n      } // Flatten the options and set defaults if necessary\n\n\n      endpointsAwaitingConfiguration = options.endpoints || {};\n      routeOptions = options.routeOptions || {};\n      excludedEndpoints = options.excludedEndpoints || []; // Use collection name as default path\n\n      path = options.path || collection._name; // Separate the requested endpoints by the route they belong to (one for operating on the entire\n      // collection and one for operating on a single entity within the collection)\n\n      collectionRouteEndpoints = {};\n      entityRouteEndpoints = {};\n\n      if (_.isEmpty(endpointsAwaitingConfiguration) && _.isEmpty(excludedEndpoints)) {\n        // Generate all endpoints on this collection\n        _.each(methods, function (method) {\n          // Partition the endpoints into their respective routes\n          if (indexOf.call(methodsOnCollection, method) >= 0) {\n            _.extend(collectionRouteEndpoints, collectionEndpoints[method].call(this, collection));\n          } else {\n            _.extend(entityRouteEndpoints, collectionEndpoints[method].call(this, collection));\n          }\n        }, this);\n      } else {\n        // Generate any endpoints that haven't been explicitly excluded\n        _.each(methods, function (method) {\n          var configuredEndpoint, endpointOptions;\n\n          if (indexOf.call(excludedEndpoints, method) < 0 && endpointsAwaitingConfiguration[method] !== false) {\n            // Configure endpoint and map to it's http method\n            // TODO: Consider predefining a map of methods to their http method type (e.g., getAll: get)\n            endpointOptions = endpointsAwaitingConfiguration[method];\n            configuredEndpoint = {};\n\n            _.each(collectionEndpoints[method].call(this, collection), function (action, methodType) {\n              return configuredEndpoint[methodType] = _.chain(action).clone().extend(endpointOptions).value();\n            }); // Partition the endpoints into their respective routes\n\n\n            if (indexOf.call(methodsOnCollection, method) >= 0) {\n              _.extend(collectionRouteEndpoints, configuredEndpoint);\n            } else {\n              _.extend(entityRouteEndpoints, configuredEndpoint);\n            }\n          }\n        }, this);\n      } // Add the routes to the API\n\n\n      this.addRoute(path, routeOptions, collectionRouteEndpoints);\n      this.addRoute(`${path}/:id`, routeOptions, entityRouteEndpoints);\n      return this;\n    }\n    /*\n      Add /login and /logout endpoints to the API\n    */\n\n\n    _initAuth() {\n      var logout, self;\n      self = this;\n      /*\n        Add a login endpoint to the API\n         After the user is logged in, the onLoggedIn hook is called (see Restfully.configure() for\n        adding hook).\n      */\n\n      this.addRoute('login', {\n        authRequired: false\n      }, {\n        post: function () {\n          var auth, e, extraData, password, ref, ref1, response, searchQuery, user; // Grab the username or email that the user is logging in with\n\n          user = {};\n\n          if (this.bodyParams.user) {\n            if (this.bodyParams.user.indexOf('@') === -1) {\n              user.username = this.bodyParams.user;\n            } else {\n              user.email = this.bodyParams.user;\n            }\n          } else if (this.bodyParams.username) {\n            user.username = this.bodyParams.username;\n          } else if (this.bodyParams.email) {\n            user.email = this.bodyParams.email;\n          }\n\n          password = this.bodyParams.password;\n\n          if (this.bodyParams.hashed) {\n            password = {\n              digest: password,\n              algorithm: 'sha-256'\n            };\n          }\n\n          try {\n            // Try to log the user into the user's account (if successful we'll get an auth token back)\n            auth = Auth.loginWithPassword(user, password);\n          } catch (error) {\n            e = error;\n            return ({} = {\n              statusCode: e.error,\n              body: {\n                status: 'error',\n                message: e.reason\n              }\n            });\n          } // Get the authenticated user\n          // TODO: Consider returning the user in Auth.loginWithPassword(), instead of fetching it again here\n\n\n          if (auth.userId && auth.authToken) {\n            searchQuery = {};\n            searchQuery[self._config.auth.token] = Accounts._hashLoginToken(auth.authToken);\n            this.user = Meteor.users.findOne({\n              '_id': auth.userId\n            }, searchQuery);\n            this.userId = (ref = this.user) != null ? ref._id : void 0;\n          }\n\n          response = {\n            status: 'success',\n            data: auth\n          }; // Call the login hook with the authenticated user attached\n\n          extraData = (ref1 = self._config.onLoggedIn) != null ? ref1.call(this) : void 0;\n\n          if (extraData != null) {\n            _.extend(response.data, {\n              extra: extraData\n            });\n          }\n\n          return response;\n        }\n      });\n\n      logout = function () {\n        var authToken, extraData, hashedToken, index, ref, response, tokenFieldName, tokenLocation, tokenPath, tokenRemovalQuery, tokenToRemove; // Remove the given auth token from the user's account\n\n        authToken = this.request.headers['x-auth-token'];\n        hashedToken = Accounts._hashLoginToken(authToken);\n        tokenLocation = self._config.auth.token;\n        index = tokenLocation.lastIndexOf('.');\n        tokenPath = tokenLocation.substring(0, index);\n        tokenFieldName = tokenLocation.substring(index + 1);\n        tokenToRemove = {};\n        tokenToRemove[tokenFieldName] = hashedToken;\n        tokenRemovalQuery = {};\n        tokenRemovalQuery[tokenPath] = tokenToRemove;\n        Meteor.users.update(this.user._id, {\n          $pull: tokenRemovalQuery\n        });\n        response = {\n          status: 'success',\n          data: {\n            message: 'You\\'ve been logged out!'\n          }\n        }; // Call the logout hook with the authenticated user attached\n\n        extraData = (ref = self._config.onLoggedOut) != null ? ref.call(this) : void 0;\n\n        if (extraData != null) {\n          _.extend(response.data, {\n            extra: extraData\n          });\n        }\n\n        return response;\n      };\n      /*\n      Add a logout endpoint to the API\n       After the user is logged out, the onLoggedOut hook is called (see Restfully.configure() for\n      adding hook).\n      */\n\n\n      return this.addRoute('logout', {\n        authRequired: true\n      }, {\n        get: function () {\n          console.warn(\"Warning: Default logout via GET will be removed in Restivus v1.0. Use POST instead.\");\n          console.warn(\"    See https://github.com/kahmali/meteor-restivus/issues/100\");\n          return logout.call(this);\n        },\n        post: logout\n      });\n    }\n\n  }\n\n  ;\n  /**\n  A set of endpoints that can be applied to a Collection Route\n  */\n\n  Restivus.prototype._collectionEndpoints = {\n    get: function (collection) {\n      return {\n        get: {\n          action: function () {\n            var entity;\n            entity = collection.findOne(this.urlParams.id);\n\n            if (entity) {\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    put: function (collection) {\n      return {\n        put: {\n          action: function () {\n            var entity, entityIsUpdated;\n            entityIsUpdated = collection.update(this.urlParams.id, this.bodyParams);\n\n            if (entityIsUpdated) {\n              entity = collection.findOne(this.urlParams.id);\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    patch: function (collection) {\n      return {\n        patch: {\n          action: function () {\n            var entity, entityIsUpdated;\n            entityIsUpdated = collection.update(this.urlParams.id, {\n              $set: this.bodyParams\n            });\n\n            if (entityIsUpdated) {\n              entity = collection.findOne(this.urlParams.id);\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    delete: function (collection) {\n      return {\n        delete: {\n          action: function () {\n            if (collection.remove(this.urlParams.id)) {\n              return {\n                status: 'success',\n                data: {\n                  message: 'Item removed'\n                }\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    post: function (collection) {\n      return {\n        post: {\n          action: function () {\n            var entity, entityId;\n            entityId = collection.insert(this.bodyParams);\n            entity = collection.findOne(entityId);\n\n            if (entity) {\n              return {\n                statusCode: 201,\n                body: {\n                  status: 'success',\n                  data: entity\n                }\n              };\n            } else {\n              return {\n                statusCode: 400,\n                body: {\n                  status: 'fail',\n                  message: 'No item added'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    getAll: function (collection) {\n      return {\n        get: {\n          action: function () {\n            var entities;\n            entities = collection.find().fetch();\n\n            if (entities) {\n              return {\n                status: 'success',\n                data: entities\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Unable to retrieve items from collection'\n                }\n              };\n            }\n          }\n        }\n      };\n    }\n  };\n  /**\n    A set of endpoints that can be applied to a Meteor.users Collection Route\n  */\n\n  Restivus.prototype._userCollectionEndpoints = {\n    get: function (collection) {\n      return {\n        get: {\n          action: function () {\n            var entity;\n            entity = collection.findOne(this.urlParams.id, {\n              fields: {\n                profile: 1\n              }\n            });\n\n            if (entity) {\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    put: function (collection) {\n      return {\n        put: {\n          action: function () {\n            var entity, entityIsUpdated;\n            entityIsUpdated = collection.update(this.urlParams.id, {\n              $set: {\n                profile: this.bodyParams\n              }\n            });\n\n            if (entityIsUpdated) {\n              entity = collection.findOne(this.urlParams.id, {\n                fields: {\n                  profile: 1\n                }\n              });\n              return {\n                status: \"success\",\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    delete: function (collection) {\n      return {\n        delete: {\n          action: function () {\n            if (collection.remove(this.urlParams.id)) {\n              return {\n                status: 'success',\n                data: {\n                  message: 'User removed'\n                }\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    post: function (collection) {\n      return {\n        post: {\n          action: function () {\n            var entity, entityId; // Create a new user account\n\n            entityId = Accounts.createUser(this.bodyParams);\n            entity = collection.findOne(entityId, {\n              fields: {\n                profile: 1\n              }\n            });\n\n            if (entity) {\n              return {\n                statusCode: 201,\n                body: {\n                  status: 'success',\n                  data: entity\n                }\n              };\n            } else {\n              ({\n                statusCode: 400\n              });\n              return {\n                status: 'fail',\n                message: 'No user added'\n              };\n            }\n          }\n        }\n      };\n    },\n    getAll: function (collection) {\n      return {\n        get: {\n          action: function () {\n            var entities;\n            entities = collection.find({}, {\n              fields: {\n                profile: 1\n              }\n            }).fetch();\n\n            if (entities) {\n              return {\n                status: 'success',\n                data: entities\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Unable to retrieve users'\n                }\n              };\n            }\n          }\n        }\n      };\n    }\n  };\n  return Restivus;\n}.call(this);\n\nRestivus = this.Restivus;","sourceMap":{"version":3,"sources":["/packages/rocketchat_restivus/lib/restivus.coffee","/lib/restivus.coffee"],"names":["indexOf","Restivus","constructor","options","corsHeaders","_routes","_config","paths","useDefaultAuth","apiPath","version","prettyJson","auth","token","user","request","headers","Accounts","_hashLoginToken","userId","defaultHeaders","enableCors","_","extend","defaultOptionsEndpoint","response","writeHead","done","slice","last","_initAuth","useAuth","console","warn","addRoute","path","endpoints","route","share","Route","push","addToApi","addCollection","collection","collectionEndpoints","collectionRouteEndpoints","endpointsAwaitingConfiguration","entityRouteEndpoints","excludedEndpoints","methods","methodsOnCollection","routeOptions","Meteor","users","_userCollectionEndpoints","_collectionEndpoints","_name","isEmpty","each","method","call","configuredEndpoint","endpointOptions","action","methodType","chain","clone","value","logout","self","authRequired","post","e","extraData","password","ref","ref1","searchQuery","bodyParams","username","email","hashed","digest","algorithm","Auth","loginWithPassword","error","statusCode","body","status","message","reason","authToken","findOne","_id","data","onLoggedIn","extra","hashedToken","index","tokenFieldName","tokenLocation","tokenPath","tokenRemovalQuery","tokenToRemove","lastIndexOf","substring","update","$pull","onLoggedOut","get","prototype","entity","urlParams","id","put","entityIsUpdated","patch","$set","delete","remove","entityId","insert","getAll","entities","find","fetch","fields","profile","createUser"],"mappings":"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","file":"packages/rocketchat:restivus/lib/restivus.coffee.map","sourcesContent":["class @Restivus\n\n  constructor: (options) ->\n    @_routes = []\n    @_config =\n      paths: []\n      useDefaultAuth: false\n      apiPath: 'api/'\n      version: null\n      prettyJson: false\n      auth:\n        token: 'services.resume.loginTokens.hashedToken'\n        user: ->\n          if @request.headers['x-auth-token']\n            token = Accounts._hashLoginToken @request.headers['x-auth-token']\n          userId: @request.headers['x-user-id']\n          token: token\n      defaultHeaders:\n        'Content-Type': 'application/json'\n      enableCors: true\n\n    # Configure API with the given options\n    _.extend @_config, options\n\n    if @_config.enableCors\n      corsHeaders =\n        'Access-Control-Allow-Origin': '*'\n        'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept'\n\n      if @_config.useDefaultAuth\n        corsHeaders['Access-Control-Allow-Headers'] += ', X-User-Id, X-Auth-Token'\n\n      # Set default header to enable CORS if configured\n      _.extend @_config.defaultHeaders, corsHeaders\n\n      if not @_config.defaultOptionsEndpoint\n        @_config.defaultOptionsEndpoint = ->\n          @response.writeHead 200, corsHeaders\n          @done()\n\n    # Normalize the API path\n    if @_config.apiPath[0] is '/'\n      @_config.apiPath = @_config.apiPath.slice 1\n    if _.last(@_config.apiPath) isnt '/'\n      @_config.apiPath = @_config.apiPath + '/'\n\n    # URL path versioning is the only type of API versioning currently available, so if a version is\n    # provided, append it to the base path of the API\n    if @_config.version\n      @_config.apiPath += @_config.version + '/'\n\n    # Add default login and logout endpoints if auth is configured\n    if @_config.useDefaultAuth\n      @_initAuth()\n    else if @_config.useAuth\n      @_initAuth()\n      console.warn 'Warning: useAuth API config option will be removed in Restivus v1.0 ' +\n          '\\n    Use the useDefaultAuth option instead'\n\n    return this\n\n\n  ###*\n    Add endpoints for the given HTTP methods at the given path\n\n    @param path {String} The extended URL path (will be appended to base path of the API)\n    @param options {Object} Route configuration options\n    @param options.authRequired {Boolean} The default auth requirement for each endpoint on the route\n    @param options.roleRequired {String or String[]} The default role required for each endpoint on the route\n    @param endpoints {Object} A set of endpoints available on the new route (get, post, put, patch, delete, options)\n    @param endpoints.<method> {Function or Object} If a function is provided, all default route\n        configuration options will be applied to the endpoint. Otherwise an object with an `action`\n        and all other route config options available. An `action` must be provided with the object.\n  ###\n  addRoute: (path, options, endpoints) ->\n    # Create a new route and add it to our list of existing routes\n    route = new share.Route(this, path, options, endpoints)\n    @_routes.push(route)\n\n    route.addToApi()\n\n    return this\n\n\n  ###*\n    Generate routes for the Meteor Collection with the given name\n  ###\n  addCollection: (collection, options={}) ->\n    methods = ['get', 'post', 'put', 'patch', 'delete', 'getAll']\n    methodsOnCollection = ['post', 'getAll']\n\n    # Grab the set of endpoints\n    if collection is Meteor.users\n      collectionEndpoints = @_userCollectionEndpoints\n    else\n      collectionEndpoints = @_collectionEndpoints\n\n    # Flatten the options and set defaults if necessary\n    endpointsAwaitingConfiguration = options.endpoints or {}\n    routeOptions = options.routeOptions or {}\n    excludedEndpoints = options.excludedEndpoints or []\n    # Use collection name as default path\n    path = options.path or collection._name\n\n    # Separate the requested endpoints by the route they belong to (one for operating on the entire\n    # collection and one for operating on a single entity within the collection)\n    collectionRouteEndpoints = {}\n    entityRouteEndpoints = {}\n    if _.isEmpty(endpointsAwaitingConfiguration) and _.isEmpty(excludedEndpoints)\n      # Generate all endpoints on this collection\n      _.each methods, (method) ->\n        # Partition the endpoints into their respective routes\n        if method in methodsOnCollection\n          _.extend collectionRouteEndpoints, collectionEndpoints[method].call(this, collection)\n        else _.extend entityRouteEndpoints, collectionEndpoints[method].call(this, collection)\n        return\n      , this\n    else\n      # Generate any endpoints that haven't been explicitly excluded\n      _.each methods, (method) ->\n        if method not in excludedEndpoints and endpointsAwaitingConfiguration[method] isnt false\n          # Configure endpoint and map to it's http method\n          # TODO: Consider predefining a map of methods to their http method type (e.g., getAll: get)\n          endpointOptions = endpointsAwaitingConfiguration[method]\n          configuredEndpoint = {}\n          _.each collectionEndpoints[method].call(this, collection), (action, methodType) ->\n            configuredEndpoint[methodType] =\n              _.chain action\n              .clone()\n              .extend endpointOptions\n              .value()\n          # Partition the endpoints into their respective routes\n          if method in methodsOnCollection\n            _.extend collectionRouteEndpoints, configuredEndpoint\n          else _.extend entityRouteEndpoints, configuredEndpoint\n          return\n      , this\n\n    # Add the routes to the API\n    @addRoute path, routeOptions, collectionRouteEndpoints\n    @addRoute \"#{path}/:id\", routeOptions, entityRouteEndpoints\n\n    return this\n\n\n  ###*\n    A set of endpoints that can be applied to a Collection Route\n  ###\n  _collectionEndpoints:\n    get: (collection) ->\n      get:\n        action: ->\n          entity = collection.findOne @urlParams.id\n          if entity\n            {status: 'success', data: entity}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'Item not found'}\n    put: (collection) ->\n      put:\n        action: ->\n          entityIsUpdated = collection.update @urlParams.id, @bodyParams\n          if entityIsUpdated\n            entity = collection.findOne @urlParams.id\n            {status: 'success', data: entity}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'Item not found'}\n    patch: (collection) ->\n      patch:\n        action: ->\n          entityIsUpdated = collection.update @urlParams.id, $set: @bodyParams\n          if entityIsUpdated\n            entity = collection.findOne @urlParams.id\n            {status: 'success', data: entity}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'Item not found'}\n    delete: (collection) ->\n      delete:\n        action: ->\n          if collection.remove @urlParams.id\n            {status: 'success', data: message: 'Item removed'}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'Item not found'}\n    post: (collection) ->\n      post:\n        action: ->\n          entityId = collection.insert @bodyParams\n          entity = collection.findOne entityId\n          if entity\n            statusCode: 201\n            body: {status: 'success', data: entity}\n          else\n            statusCode: 400\n            body: {status: 'fail', message: 'No item added'}\n    getAll: (collection) ->\n      get:\n        action: ->\n          entities = collection.find().fetch()\n          if entities\n            {status: 'success', data: entities}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'Unable to retrieve items from collection'}\n\n\n  ###*\n    A set of endpoints that can be applied to a Meteor.users Collection Route\n  ###\n  _userCollectionEndpoints:\n    get: (collection) ->\n      get:\n        action: ->\n          entity = collection.findOne @urlParams.id, fields: profile: 1\n          if entity\n            {status: 'success', data: entity}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'User not found'}\n    put: (collection) ->\n      put:\n        action: ->\n          entityIsUpdated = collection.update @urlParams.id, $set: profile: @bodyParams\n          if entityIsUpdated\n            entity = collection.findOne @urlParams.id, fields: profile: 1\n            {status: \"success\", data: entity}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'User not found'}\n    delete: (collection) ->\n      delete:\n        action: ->\n          if collection.remove @urlParams.id\n            {status: 'success', data: message: 'User removed'}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'User not found'}\n    post: (collection) ->\n      post:\n        action: ->\n          # Create a new user account\n          entityId = Accounts.createUser @bodyParams\n          entity = collection.findOne entityId, fields: profile: 1\n          if entity\n            statusCode: 201\n            body: {status: 'success', data: entity}\n          else\n            statusCode: 400\n            {status: 'fail', message: 'No user added'}\n    getAll: (collection) ->\n      get:\n        action: ->\n          entities = collection.find({}, fields: profile: 1).fetch()\n          if entities\n            {status: 'success', data: entities}\n          else\n            statusCode: 404\n            body: {status: 'fail', message: 'Unable to retrieve users'}\n\n\n  ###\n    Add /login and /logout endpoints to the API\n  ###\n  _initAuth: ->\n    self = this\n    ###\n      Add a login endpoint to the API\n\n      After the user is logged in, the onLoggedIn hook is called (see Restfully.configure() for\n      adding hook).\n    ###\n    @addRoute 'login', {authRequired: false},\n      post: ->\n        # Grab the username or email that the user is logging in with\n        user = {}\n        if @bodyParams.user\n          if @bodyParams.user.indexOf('@') is -1\n            user.username = @bodyParams.user\n          else\n            user.email = @bodyParams.user\n        else if @bodyParams.username\n          user.username = @bodyParams.username\n        else if @bodyParams.email\n          user.email = @bodyParams.email\n\n        password = @bodyParams.password\n        if @bodyParams.hashed\n          password =\n            digest: password\n            algorithm: 'sha-256'\n\n        # Try to log the user into the user's account (if successful we'll get an auth token back)\n        try\n          auth = Auth.loginWithPassword user, password\n        catch e\n          return {} =\n            statusCode: e.error\n            body: status: 'error', message: e.reason\n\n        # Get the authenticated user\n        # TODO: Consider returning the user in Auth.loginWithPassword(), instead of fetching it again here\n        if auth.userId and auth.authToken\n          searchQuery = {}\n          searchQuery[self._config.auth.token] = Accounts._hashLoginToken auth.authToken\n          @user = Meteor.users.findOne\n            '_id': auth.userId\n            searchQuery\n          @userId = @user?._id\n\n        response = {status: 'success', data: auth}\n\n        # Call the login hook with the authenticated user attached\n        extraData = self._config.onLoggedIn?.call(this)\n        if extraData?\n          _.extend(response.data, {extra: extraData})\n\n        response\n\n    logout = ->\n      # Remove the given auth token from the user's account\n      authToken = @request.headers['x-auth-token']\n      hashedToken = Accounts._hashLoginToken authToken\n      tokenLocation = self._config.auth.token\n      index = tokenLocation.lastIndexOf '.'\n      tokenPath = tokenLocation.substring 0, index\n      tokenFieldName = tokenLocation.substring index + 1\n      tokenToRemove = {}\n      tokenToRemove[tokenFieldName] = hashedToken\n      tokenRemovalQuery = {}\n      tokenRemovalQuery[tokenPath] = tokenToRemove\n      Meteor.users.update @user._id, {$pull: tokenRemovalQuery}\n\n      response = {status: 'success', data: {message: 'You\\'ve been logged out!'}}\n\n      # Call the logout hook with the authenticated user attached\n      extraData = self._config.onLoggedOut?.call(this)\n      if extraData?\n        _.extend(response.data, {extra: extraData})\n\n      response\n\n    ###\n      Add a logout endpoint to the API\n\n      After the user is logged out, the onLoggedOut hook is called (see Restfully.configure() for\n      adding hook).\n    ###\n    @addRoute 'logout', {authRequired: true},\n      get: ->\n        console.warn \"Warning: Default logout via GET will be removed in Restivus v1.0. Use POST instead.\"\n        console.warn \"    See https://github.com/kahmali/meteor-restivus/issues/100\"\n        return logout.call(this)\n      post: logout\n\nRestivus = @Restivus\n","var          \n  indexOf = [].indexOf;\n\nthis.Restivus = (function() {\n  class Restivus {\n    constructor(options) {\n      var corsHeaders;\n      this._routes = [];\n      this._config = {\n        paths: [],\n        useDefaultAuth: false,\n        apiPath: 'api/',\n        version: null,\n        prettyJson: false,\n        auth: {\n          token: 'services.resume.loginTokens.hashedToken',\n          user: function() {\n            var token;\n            if (this.request.headers['x-auth-token']) {\n              token = Accounts._hashLoginToken(this.request.headers['x-auth-token']);\n            }\n            return {\n              userId: this.request.headers['x-user-id'],\n              token: token\n            };\n          }\n        },\n        defaultHeaders: {\n          'Content-Type': 'application/json'\n        },\n        enableCors: true\n      };\n      // Configure API with the given options\n      _.extend(this._config, options);\n      if (this._config.enableCors) {\n        corsHeaders = {\n          'Access-Control-Allow-Origin': '*',\n          'Access-Control-Allow-Headers': 'Origin, X-Requested-With, Content-Type, Accept'\n        };\n        if (this._config.useDefaultAuth) {\n          corsHeaders['Access-Control-Allow-Headers'] += ', X-User-Id, X-Auth-Token';\n        }\n        // Set default header to enable CORS if configured\n        _.extend(this._config.defaultHeaders, corsHeaders);\n        if (!this._config.defaultOptionsEndpoint) {\n          this._config.defaultOptionsEndpoint = function() {\n            this.response.writeHead(200, corsHeaders);\n            return this.done();\n          };\n        }\n      }\n      // Normalize the API path\n      if (this._config.apiPath[0] === '/') {\n        this._config.apiPath = this._config.apiPath.slice(1);\n      }\n      if (_.last(this._config.apiPath) !== '/') {\n        this._config.apiPath = this._config.apiPath + '/';\n      }\n      // URL path versioning is the only type of API versioning currently available, so if a version is\n      // provided, append it to the base path of the API\n      if (this._config.version) {\n        this._config.apiPath += this._config.version + '/';\n      }\n      // Add default login and logout endpoints if auth is configured\n      if (this._config.useDefaultAuth) {\n        this._initAuth();\n      } else if (this._config.useAuth) {\n        this._initAuth();\n        console.warn('Warning: useAuth API config option will be removed in Restivus v1.0 ' + '\\n    Use the useDefaultAuth option instead');\n      }\n      return this;\n    }\n\n    /**\n    Add endpoints for the given HTTP methods at the given path\n\n    @param path {String} The extended URL path (will be appended to base path of the API)\n    @param options {Object} Route configuration options\n    @param options.authRequired {Boolean} The default auth requirement for each endpoint on the route\n    @param options.roleRequired {String or String[]} The default role required for each endpoint on the route\n    @param endpoints {Object} A set of endpoints available on the new route (get, post, put, patch, delete, options)\n    @param endpoints.<method> {Function or Object} If a function is provided, all default route\n      configuration options will be applied to the endpoint. Otherwise an object with an `action`\n      and all other route config options available. An `action` must be provided with the object.\n    */\n    addRoute(path, options, endpoints) {\n      var route;\n      // Create a new route and add it to our list of existing routes\n      route = new share.Route(this, path, options, endpoints);\n      this._routes.push(route);\n      route.addToApi();\n      return this;\n    }\n\n    /**\n    Generate routes for the Meteor Collection with the given name\n    */\n    addCollection(collection, options = {}) {\n      var collectionEndpoints, collectionRouteEndpoints, endpointsAwaitingConfiguration, entityRouteEndpoints, excludedEndpoints, methods, methodsOnCollection, path, routeOptions;\n      methods = ['get', 'post', 'put', 'patch', 'delete', 'getAll'];\n      methodsOnCollection = ['post', 'getAll'];\n      // Grab the set of endpoints\n      if (collection === Meteor.users) {\n        collectionEndpoints = this._userCollectionEndpoints;\n      } else {\n        collectionEndpoints = this._collectionEndpoints;\n      }\n      // Flatten the options and set defaults if necessary\n      endpointsAwaitingConfiguration = options.endpoints || {};\n      routeOptions = options.routeOptions || {};\n      excludedEndpoints = options.excludedEndpoints || [];\n      // Use collection name as default path\n      path = options.path || collection._name;\n      // Separate the requested endpoints by the route they belong to (one for operating on the entire\n      // collection and one for operating on a single entity within the collection)\n      collectionRouteEndpoints = {};\n      entityRouteEndpoints = {};\n      if (_.isEmpty(endpointsAwaitingConfiguration) && _.isEmpty(excludedEndpoints)) {\n        // Generate all endpoints on this collection\n        _.each(methods, function(method) {\n          // Partition the endpoints into their respective routes\n          if (indexOf.call(methodsOnCollection, method) >= 0) {\n            _.extend(collectionRouteEndpoints, collectionEndpoints[method].call(this, collection));\n          } else {\n            _.extend(entityRouteEndpoints, collectionEndpoints[method].call(this, collection));\n          }\n        }, this);\n      } else {\n        // Generate any endpoints that haven't been explicitly excluded\n        _.each(methods, function(method) {\n          var configuredEndpoint, endpointOptions;\n          if (indexOf.call(excludedEndpoints, method) < 0 && endpointsAwaitingConfiguration[method] !== false) {\n            // Configure endpoint and map to it's http method\n            // TODO: Consider predefining a map of methods to their http method type (e.g., getAll: get)\n            endpointOptions = endpointsAwaitingConfiguration[method];\n            configuredEndpoint = {};\n            _.each(collectionEndpoints[method].call(this, collection), function(action, methodType) {\n              return configuredEndpoint[methodType] = _.chain(action).clone().extend(endpointOptions).value();\n            });\n            // Partition the endpoints into their respective routes\n            if (indexOf.call(methodsOnCollection, method) >= 0) {\n              _.extend(collectionRouteEndpoints, configuredEndpoint);\n            } else {\n              _.extend(entityRouteEndpoints, configuredEndpoint);\n            }\n          }\n        }, this);\n      }\n      // Add the routes to the API\n      this.addRoute(path, routeOptions, collectionRouteEndpoints);\n      this.addRoute(`${path}/:id`, routeOptions, entityRouteEndpoints);\n      return this;\n    }\n\n    /*\n      Add /login and /logout endpoints to the API\n    */\n    _initAuth() {\n      var logout, self;\n      self = this;\n      /*\n        Add a login endpoint to the API\n\n        After the user is logged in, the onLoggedIn hook is called (see Restfully.configure() for\n        adding hook).\n      */\n      this.addRoute('login', {\n        authRequired: false\n      }, {\n        post: function() {\n          var auth, e, extraData, password, ref, ref1, response, searchQuery, user;\n          // Grab the username or email that the user is logging in with\n          user = {};\n          if (this.bodyParams.user) {\n            if (this.bodyParams.user.indexOf('@') === -1) {\n              user.username = this.bodyParams.user;\n            } else {\n              user.email = this.bodyParams.user;\n            }\n          } else if (this.bodyParams.username) {\n            user.username = this.bodyParams.username;\n          } else if (this.bodyParams.email) {\n            user.email = this.bodyParams.email;\n          }\n          password = this.bodyParams.password;\n          if (this.bodyParams.hashed) {\n            password = {\n              digest: password,\n              algorithm: 'sha-256'\n            };\n          }\n          try {\n            // Try to log the user into the user's account (if successful we'll get an auth token back)\n            auth = Auth.loginWithPassword(user, password);\n          } catch (error) {\n            e = error;\n            return ({} = {\n              statusCode: e.error,\n              body: {\n                status: 'error',\n                message: e.reason\n              }\n            });\n          }\n          // Get the authenticated user\n          // TODO: Consider returning the user in Auth.loginWithPassword(), instead of fetching it again here\n          if (auth.userId && auth.authToken) {\n            searchQuery = {};\n            searchQuery[self._config.auth.token] = Accounts._hashLoginToken(auth.authToken);\n            this.user = Meteor.users.findOne({\n              '_id': auth.userId\n            }, searchQuery);\n            this.userId = (ref = this.user) != null ? ref._id : void 0;\n          }\n          response = {\n            status: 'success',\n            data: auth\n          };\n          // Call the login hook with the authenticated user attached\n          extraData = (ref1 = self._config.onLoggedIn) != null ? ref1.call(this) : void 0;\n          if (extraData != null) {\n            _.extend(response.data, {\n              extra: extraData\n            });\n          }\n          return response;\n        }\n      });\n      logout = function() {\n        var authToken, extraData, hashedToken, index, ref, response, tokenFieldName, tokenLocation, tokenPath, tokenRemovalQuery, tokenToRemove;\n        // Remove the given auth token from the user's account\n        authToken = this.request.headers['x-auth-token'];\n        hashedToken = Accounts._hashLoginToken(authToken);\n        tokenLocation = self._config.auth.token;\n        index = tokenLocation.lastIndexOf('.');\n        tokenPath = tokenLocation.substring(0, index);\n        tokenFieldName = tokenLocation.substring(index + 1);\n        tokenToRemove = {};\n        tokenToRemove[tokenFieldName] = hashedToken;\n        tokenRemovalQuery = {};\n        tokenRemovalQuery[tokenPath] = tokenToRemove;\n        Meteor.users.update(this.user._id, {\n          $pull: tokenRemovalQuery\n        });\n        response = {\n          status: 'success',\n          data: {\n            message: 'You\\'ve been logged out!'\n          }\n        };\n        // Call the logout hook with the authenticated user attached\n        extraData = (ref = self._config.onLoggedOut) != null ? ref.call(this) : void 0;\n        if (extraData != null) {\n          _.extend(response.data, {\n            extra: extraData\n          });\n        }\n        return response;\n      };\n      /*\n      Add a logout endpoint to the API\n\n      After the user is logged out, the onLoggedOut hook is called (see Restfully.configure() for\n      adding hook).\n      */\n      return this.addRoute('logout', {\n        authRequired: true\n      }, {\n        get: function() {\n          console.warn(\"Warning: Default logout via GET will be removed in Restivus v1.0. Use POST instead.\");\n          console.warn(\"    See https://github.com/kahmali/meteor-restivus/issues/100\");\n          return logout.call(this);\n        },\n        post: logout\n      });\n    }\n\n  };\n\n  /**\n  A set of endpoints that can be applied to a Collection Route\n  */\n  Restivus.prototype._collectionEndpoints = {\n    get: function(collection) {\n      return {\n        get: {\n          action: function() {\n            var entity;\n            entity = collection.findOne(this.urlParams.id);\n            if (entity) {\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    put: function(collection) {\n      return {\n        put: {\n          action: function() {\n            var entity, entityIsUpdated;\n            entityIsUpdated = collection.update(this.urlParams.id, this.bodyParams);\n            if (entityIsUpdated) {\n              entity = collection.findOne(this.urlParams.id);\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    patch: function(collection) {\n      return {\n        patch: {\n          action: function() {\n            var entity, entityIsUpdated;\n            entityIsUpdated = collection.update(this.urlParams.id, {\n              $set: this.bodyParams\n            });\n            if (entityIsUpdated) {\n              entity = collection.findOne(this.urlParams.id);\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    delete: function(collection) {\n      return {\n        delete: {\n          action: function() {\n            if (collection.remove(this.urlParams.id)) {\n              return {\n                status: 'success',\n                data: {\n                  message: 'Item removed'\n                }\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Item not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    post: function(collection) {\n      return {\n        post: {\n          action: function() {\n            var entity, entityId;\n            entityId = collection.insert(this.bodyParams);\n            entity = collection.findOne(entityId);\n            if (entity) {\n              return {\n                statusCode: 201,\n                body: {\n                  status: 'success',\n                  data: entity\n                }\n              };\n            } else {\n              return {\n                statusCode: 400,\n                body: {\n                  status: 'fail',\n                  message: 'No item added'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    getAll: function(collection) {\n      return {\n        get: {\n          action: function() {\n            var entities;\n            entities = collection.find().fetch();\n            if (entities) {\n              return {\n                status: 'success',\n                data: entities\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Unable to retrieve items from collection'\n                }\n              };\n            }\n          }\n        }\n      };\n    }\n  };\n\n  /**\n    A set of endpoints that can be applied to a Meteor.users Collection Route\n  */\n  Restivus.prototype._userCollectionEndpoints = {\n    get: function(collection) {\n      return {\n        get: {\n          action: function() {\n            var entity;\n            entity = collection.findOne(this.urlParams.id, {\n              fields: {\n                profile: 1\n              }\n            });\n            if (entity) {\n              return {\n                status: 'success',\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    put: function(collection) {\n      return {\n        put: {\n          action: function() {\n            var entity, entityIsUpdated;\n            entityIsUpdated = collection.update(this.urlParams.id, {\n              $set: {\n                profile: this.bodyParams\n              }\n            });\n            if (entityIsUpdated) {\n              entity = collection.findOne(this.urlParams.id, {\n                fields: {\n                  profile: 1\n                }\n              });\n              return {\n                status: \"success\",\n                data: entity\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    delete: function(collection) {\n      return {\n        delete: {\n          action: function() {\n            if (collection.remove(this.urlParams.id)) {\n              return {\n                status: 'success',\n                data: {\n                  message: 'User removed'\n                }\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'User not found'\n                }\n              };\n            }\n          }\n        }\n      };\n    },\n    post: function(collection) {\n      return {\n        post: {\n          action: function() {\n            var entity, entityId;\n            // Create a new user account\n            entityId = Accounts.createUser(this.bodyParams);\n            entity = collection.findOne(entityId, {\n              fields: {\n                profile: 1\n              }\n            });\n            if (entity) {\n              return {\n                statusCode: 201,\n                body: {\n                  status: 'success',\n                  data: entity\n                }\n              };\n            } else {\n              ({\n                statusCode: 400\n              });\n              return {\n                status: 'fail',\n                message: 'No user added'\n              };\n            }\n          }\n        }\n      };\n    },\n    getAll: function(collection) {\n      return {\n        get: {\n          action: function() {\n            var entities;\n            entities = collection.find({}, {\n              fields: {\n                profile: 1\n              }\n            }).fetch();\n            if (entities) {\n              return {\n                status: 'success',\n                data: entities\n              };\n            } else {\n              return {\n                statusCode: 404,\n                body: {\n                  status: 'fail',\n                  message: 'Unable to retrieve users'\n                }\n              };\n            }\n          }\n        }\n      };\n    }\n  };\n\n  return Restivus;\n\n}).call(this);\n\nRestivus = this.Restivus;\n"]}}