{"source":"__coffeescriptShare = typeof __coffeescriptShare === 'object' ? __coffeescriptShare : {}; var share = __coffeescriptShare;\n/*\n  Return a MongoDB query selector for finding the given user\n*/\n\n/*\nA password can be either in plain text or hashed\n*/\n\n/*\n  A valid user will have exactly one of the following identification fields: id, username, or email\n*/\nvar getUserQuerySelector, passwordValidator, userValidator;\nthis.Auth || (this.Auth = {});\nuserValidator = Match.Where(function (user) {\n  check(user, {\n    id: Match.Optional(String),\n    username: Match.Optional(String),\n    email: Match.Optional(String)\n  });\n\n  if (_.keys(user).length === !1) {\n    throw new Match.Error('User must have exactly one identifier field');\n  }\n\n  return true;\n});\npasswordValidator = Match.OneOf(String, {\n  digest: String,\n  algorithm: String\n});\n\ngetUserQuerySelector = function (user) {\n  if (user.id) {\n    return {\n      '_id': user.id\n    };\n  } else if (user.username) {\n    return {\n      'username': user.username\n    };\n  } else if (user.email) {\n    return {\n      'emails.address': user.email\n    };\n  } // We shouldn't be here if the user object was properly validated\n\n\n  throw new Error('Cannot create selector from invalid user');\n};\n/*\nLog a user in with their password\n*/\n\n\nthis.Auth.loginWithPassword = function (user, password) {\n  var authToken, authenticatingUser, authenticatingUserSelector, hashedToken, passwordVerification, ref;\n\n  if (!user || !password) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  } // Validate the login input types\n\n\n  check(user, userValidator);\n  check(password, passwordValidator); // Retrieve the user from the database\n\n  authenticatingUserSelector = getUserQuerySelector(user);\n  authenticatingUser = Meteor.users.findOne(authenticatingUserSelector);\n\n  if (!authenticatingUser) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n\n  if (!((ref = authenticatingUser.services) != null ? ref.password : void 0)) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  } // Authenticate the user's password\n\n\n  passwordVerification = Accounts._checkPassword(authenticatingUser, password);\n\n  if (passwordVerification.error) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  } // Add a new auth token to the user's account\n\n\n  authToken = Accounts._generateStampedLoginToken();\n  hashedToken = Accounts._hashLoginToken(authToken.token);\n\n  Accounts._insertHashedLoginToken(authenticatingUser._id, {\n    hashedToken\n  });\n\n  return {\n    authToken: authToken.token,\n    userId: authenticatingUser._id\n  };\n};","sourceMap":{"version":3,"sources":["/lib/auth.coffee","/packages/rocketchat_restivus/lib/auth.coffee"],"names":["getUserQuerySelector","passwordValidator","userValidator","Auth","Match","Where","user","check","id","Optional","String","username","email","_","keys","length","Error","OneOf","digest","algorithm","loginWithPassword","password","authToken","authenticatingUser","authenticatingUserSelector","hashedToken","passwordVerification","ref","Meteor","users","findOne","services","Accounts","_checkPassword","error","_generateStampedLoginToken","_hashLoginToken","token","_insertHashedLoginToken","_id","userId"],"mappings":";AACA;;;;AAGE;;;;AAGA;;;AAGF,ICVAA,oBDUA,ECVAC,iBDUA,ECVAC,aDUA;ACVA,KAACC,IAAD,KAAA,KAACA,IAAD,GAAU,EAAV;AAKAD,aAAA,GAAgBE,KAAK,CAACC,KAAN,CAAY,UAACC,IAAD,EAAA;AAC1BC,EAAAA,KAAA,CAAMD,IAAN,EACE;AAAAE,IAAAA,EAAA,EAAIJ,KAAK,CAACK,QAAN,CAAeC,MAAf,CAAJ;AACAC,IAAAA,QAAA,EAAUP,KAAK,CAACK,QAAN,CAAeC,MAAf,CADV;AAEAE,IAAAA,KAAA,EAAOR,KAAK,CAACK,QAAN,CAAeC,MAAf;AAFP,GADF,CAAA;;AAKA,MAAGG,CAAC,CAACC,IAAF,CAAOR,IAAP,EAAaS,MAAb,KAAuB,CAAI,CAA9B,EAAA;AACE,UAAM,IAAIX,KAAK,CAACY,KAAV,CAAgB,6CAAhB,CAAN;ADUD;;ACRD,SAAO,IAAP;AATc,CAAA,CAAhB;AAcAf,iBAAA,GAAoBG,KAAK,CAACa,KAAN,CAAYP,MAAZ,EAClB;AAAAQ,EAAAA,MAAA,EAAQR,MAAR;AACAS,EAAAA,SAAA,EAAWT;AADX,CADkB,CAApB;;AAOAV,oBAAA,GAAuB,UAACM,IAAD,EAAA;AACrB,MAAGA,IAAI,CAACE,EAAR,EAAA;AACE,WAAO;AAAC,aAAOF,IAAI,CAACE;AAAb,KAAP;AADF,GAAA,MAEK,IAAGF,IAAI,CAACK,QAAR,EAAA;AACH,WAAO;AAAC,kBAAYL,IAAI,CAACK;AAAlB,KAAP;AADG,GAAA,MAEA,IAAGL,IAAI,CAACM,KAAR,EAAA;AACH,WAAO;AAAC,wBAAkBN,IAAI,CAACM;AAAxB,KAAP;AALF,GADqB,CDmBrB;;;ACVA,QAAM,IAAII,KAAJ,CAAU,0CAAV,CAAN;AATqB,CAAvB;ADuBA;;;;;ACTA,KAACb,IAAD,CAAMiB,iBAAN,GAA0B,UAACd,IAAD,EAAOe,QAAP,EAAA;AACxB,MAAAC,SAAA,EAAAC,kBAAA,EAAAC,0BAAA,EAAAC,WAAA,EAAAC,oBAAA,EAAAC,GAAA;;AAAA,MAAG,CAAIrB,IAAJ,IAAY,CAAIe,QAAnB,EAAA;AACE,UAAM,IAAIO,MAAM,CAACZ,KAAX,CAAiB,GAAjB,EAAsB,cAAtB,CAAN;AADF,GADwB,CDiBxB;;;ACZAT,EAAAA,KAAA,CAAMD,IAAN,EAAYJ,aAAZ,CAAA;AACAK,EAAAA,KAAA,CAAMc,QAAN,EAAgBpB,iBAAhB,CAAA,CANwB,CDoBxB;;ACXAuB,EAAAA,0BAAA,GAA6BxB,oBAAA,CAAqBM,IAArB,CAA7B;AACAiB,EAAAA,kBAAA,GAAqBK,MAAM,CAACC,KAAP,CAAaC,OAAb,CAAqBN,0BAArB,CAArB;;AAEA,MAAG,CAAID,kBAAP,EAAA;AACE,UAAM,IAAIK,MAAM,CAACZ,KAAX,CAAiB,GAAjB,EAAsB,cAAtB,CAAN;ADYD;;ACXD,MAAG,EAAA,CAAAW,GAAA,GAAAJ,kBAAA,CAAAQ,QAAA,KAAA,IAAA,GAAAJ,GAA+B,CAAEN,QAAjC,GAAiC,KAAA,CAAjC,CAAH,EAAA;AACE,UAAM,IAAIO,MAAM,CAACZ,KAAX,CAAiB,GAAjB,EAAsB,cAAtB,CAAN;AAdF,GADwB,CD6BxB;;;ACXAU,EAAAA,oBAAA,GAAuBM,QAAQ,CAACC,cAAT,CAAwBV,kBAAxB,EAA4CF,QAA5C,CAAvB;;AACA,MAAGK,oBAAoB,CAACQ,KAAxB,EAAA;AACE,UAAM,IAAIN,MAAM,CAACZ,KAAX,CAAiB,GAAjB,EAAsB,cAAtB,CAAN;AAnBF,GADwB,CDkCxB;;;ACXAM,EAAAA,SAAA,GAAYU,QAAQ,CAACG,0BAAT,EAAZ;AACAV,EAAAA,WAAA,GAAcO,QAAQ,CAACI,eAAT,CAAyBd,SAAS,CAACe,KAAnC,CAAd;;AACAL,EAAAA,QAAQ,CAACM,uBAAT,CAAiCf,kBAAkB,CAACgB,GAApD,EAAyD;AAACd,IAAAA;AAAD,GAAzD;;AAEA,SAAO;AAACH,IAAAA,SAAA,EAAWA,SAAS,CAACe,KAAtB;AAA6BG,IAAAA,MAAA,EAAQjB,kBAAkB,CAACgB;AAAxD,GAAP;AA3BwB,CAA1B","file":"packages/rocketchat:restivus/lib/auth.coffee.map","sourcesContent":["\n/*\n  Return a MongoDB query selector for finding the given user\n*/\n  /*\n  A password can be either in plain text or hashed\n  */\n  /*\n    A valid user will have exactly one of the following identification fields: id, username, or email\n  */\nvar getUserQuerySelector, passwordValidator, userValidator;\n\nthis.Auth || (this.Auth = {});\n\nuserValidator = Match.Where(function(user) {\n  check(user, {\n    id: Match.Optional(String),\n    username: Match.Optional(String),\n    email: Match.Optional(String)\n  });\n  if (_.keys(user).length === !1) {\n    throw new Match.Error('User must have exactly one identifier field');\n  }\n  return true;\n});\n\npasswordValidator = Match.OneOf(String, {\n  digest: String,\n  algorithm: String\n});\n\ngetUserQuerySelector = function(user) {\n  if (user.id) {\n    return {\n      '_id': user.id\n    };\n  } else if (user.username) {\n    return {\n      'username': user.username\n    };\n  } else if (user.email) {\n    return {\n      'emails.address': user.email\n    };\n  }\n  // We shouldn't be here if the user object was properly validated\n  throw new Error('Cannot create selector from invalid user');\n};\n\n/*\nLog a user in with their password\n*/\nthis.Auth.loginWithPassword = function(user, password) {\n  var authToken, authenticatingUser, authenticatingUserSelector, hashedToken, passwordVerification, ref;\n  if (!user || !password) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n  // Validate the login input types\n  check(user, userValidator);\n  check(password, passwordValidator);\n  // Retrieve the user from the database\n  authenticatingUserSelector = getUserQuerySelector(user);\n  authenticatingUser = Meteor.users.findOne(authenticatingUserSelector);\n  if (!authenticatingUser) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n  if (!((ref = authenticatingUser.services) != null ? ref.password : void 0)) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n  // Authenticate the user's password\n  passwordVerification = Accounts._checkPassword(authenticatingUser, password);\n  if (passwordVerification.error) {\n    throw new Meteor.Error(401, 'Unauthorized');\n  }\n  // Add a new auth token to the user's account\n  authToken = Accounts._generateStampedLoginToken();\n  hashedToken = Accounts._hashLoginToken(authToken.token);\n  Accounts._insertHashedLoginToken(authenticatingUser._id, {hashedToken});\n  return {\n    authToken: authToken.token,\n    userId: authenticatingUser._id\n  };\n};\n","@Auth or= {}\n\n###\n  A valid user will have exactly one of the following identification fields: id, username, or email\n###\nuserValidator = Match.Where (user) ->\n  check user,\n    id: Match.Optional String\n    username: Match.Optional String\n    email: Match.Optional String\n\n  if _.keys(user).length is not 1\n    throw new Match.Error 'User must have exactly one identifier field'\n\n  return true\n\n###\n  A password can be either in plain text or hashed\n###\npasswordValidator = Match.OneOf(String,\n  digest: String\n  algorithm: String)\n\n###\n  Return a MongoDB query selector for finding the given user\n###\ngetUserQuerySelector = (user) ->\n  if user.id\n    return {'_id': user.id}\n  else if user.username\n    return {'username': user.username}\n  else if user.email\n    return {'emails.address': user.email}\n\n  # We shouldn't be here if the user object was properly validated\n  throw new Error 'Cannot create selector from invalid user'\n\n###\n  Log a user in with their password\n###\n@Auth.loginWithPassword = (user, password) ->\n  if not user or not password\n    throw new Meteor.Error 401, 'Unauthorized'\n\n  # Validate the login input types\n  check user, userValidator\n  check password, passwordValidator\n\n  # Retrieve the user from the database\n  authenticatingUserSelector = getUserQuerySelector(user)\n  authenticatingUser = Meteor.users.findOne(authenticatingUserSelector)\n\n  if not authenticatingUser\n    throw new Meteor.Error 401, 'Unauthorized'\n  if not authenticatingUser.services?.password\n    throw new Meteor.Error 401, 'Unauthorized'\n\n  # Authenticate the user's password\n  passwordVerification = Accounts._checkPassword authenticatingUser, password\n  if passwordVerification.error\n    throw new Meteor.Error 401, 'Unauthorized'\n\n  # Add a new auth token to the user's account\n  authToken = Accounts._generateStampedLoginToken()\n  hashedToken = Accounts._hashLoginToken authToken.token\n  Accounts._insertHashedLoginToken authenticatingUser._id, {hashedToken}\n\n  return {authToken: authToken.token, userId: authenticatingUser._id}\n"]}}