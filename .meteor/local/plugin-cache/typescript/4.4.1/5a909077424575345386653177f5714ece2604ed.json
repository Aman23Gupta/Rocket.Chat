{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/authentication/server/lib/restrictLoginAttempts.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/authentication/server/lib/restrictLoginAttempts.ts","filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/authentication/server/lib/restrictLoginAttempts.ts","inputSourceMap":{"version":3,"file":"app/authentication/server/lib/restrictLoginAttempts.ts","sourceRoot":"","sources":["app/authentication/server/lib/restrictLoginAttempts.ts"],"names":[],"mappings":"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","sourcesContent":["import moment from 'moment';\n\nimport { ILoginAttempt } from '../ILoginAttempt';\nimport { ServerEvents, Users, Rooms, Sessions } from '../../../models/server/raw';\nimport { IServerEventType, IServerEvent } from '../../../../definition/IServerEvent';\nimport { settings } from '../../../settings/server';\nimport { addMinutesToADate } from '../../../../lib/utils/addMinutesToADate';\nimport { getClientAddress } from '../../../../server/lib/getClientAddress';\nimport { sendMessage } from '../../../lib/server/functions';\nimport { Logger } from '../../../logger/server';\n\nconst logger = new Logger('LoginProtection');\n\nexport const notifyFailedLogin = async (ipOrUsername: string, blockedUntil: Date, failedAttempts: number): Promise<void> => {\n\tconst channelToNotify = settings.get('Block_Multiple_Failed_Logins_Notify_Failed_Channel');\n\tif (!channelToNotify) {\n\t\tlogger.error('Cannot notify failed logins: channel provided is invalid');\n\t\treturn;\n\t}\n\t// verify channel exists\n\t// to avoid issues when \"fname\" is presented in the UI, check if the name matches it as well\n\tconst room = await Rooms.findOneByNameOrFname(channelToNotify);\n\tif (!room) {\n\t\tlogger.error(\"Cannot notify failed logins: channel provided doesn't exists\");\n\t\treturn;\n\t}\n\n\tconst rocketCat = await Users.findOneById('rocket.cat');\n\t// send message\n\tconst message = {\n\t\tattachments: [\n\t\t\t{\n\t\t\t\tfields: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttitle: 'Failed login attempt threshold exceeded',\n\t\t\t\t\t\tvalue: `User or IP: ${ipOrUsername}\\nBlocked until: ${blockedUntil}\\nFailed Attempts: ${failedAttempts}`,\n\t\t\t\t\t\tshort: true,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tcolor: 'red',\n\t\t\t},\n\t\t],\n\t};\n\n\tawait sendMessage(rocketCat, message, room, false);\n};\n\nexport const isValidLoginAttemptByIp = async (ip: string): Promise<boolean> => {\n\tconst whitelist = String(settings.get('Block_Multiple_Failed_Logins_Ip_Whitelist')).split(',');\n\n\tif (\n\t\t!settings.get('Block_Multiple_Failed_Logins_Enabled') ||\n\t\t!settings.get('Block_Multiple_Failed_Logins_By_Ip') ||\n\t\twhitelist.includes(ip)\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastLogin = await Sessions.findLastLoginByIp(ip);\n\tlet failedAttemptsSinceLastLogin;\n\n\tif (!lastLogin || !lastLogin.loginAt) {\n\t\tfailedAttemptsSinceLastLogin = await ServerEvents.countFailedAttemptsByIp(ip);\n\t} else {\n\t\tfailedAttemptsSinceLastLogin = await ServerEvents.countFailedAttemptsByIpSince(ip, new Date(lastLogin.loginAt));\n\t}\n\n\tconst attemptsUntilBlock = settings.get('Block_Multiple_Failed_Logins_Attempts_Until_Block_By_Ip');\n\n\tif (attemptsUntilBlock && failedAttemptsSinceLastLogin < attemptsUntilBlock) {\n\t\treturn true;\n\t}\n\n\tconst lastAttemptAt = (await ServerEvents.findLastFailedAttemptByIp(ip))?.ts;\n\n\tif (!lastAttemptAt) {\n\t\treturn true;\n\t}\n\n\tconst minutesUntilUnblock = settings.get('Block_Multiple_Failed_Logins_Time_To_Unblock_By_Ip_In_Minutes') as number;\n\tconst willBeBlockedUntil = addMinutesToADate(new Date(lastAttemptAt), minutesUntilUnblock);\n\tconst isValid = moment(new Date()).isSameOrAfter(willBeBlockedUntil);\n\n\tif (settings.get('Block_Multiple_Failed_Logins_Notify_Failed') && !isValid) {\n\t\tnotifyFailedLogin(ip, willBeBlockedUntil, failedAttemptsSinceLastLogin);\n\t}\n\n\treturn isValid;\n};\n\nexport const isValidAttemptByUser = async (login: ILoginAttempt): Promise<boolean> => {\n\tif (!settings.get('Block_Multiple_Failed_Logins_Enabled') || !settings.get('Block_Multiple_Failed_Logins_By_User')) {\n\t\treturn true;\n\t}\n\n\tconst user = login.user || (await Users.findOneByUsername(login.methodArguments[0].user?.username));\n\n\tif (!user?.username) {\n\t\treturn true;\n\t}\n\n\tlet failedAttemptsSinceLastLogin;\n\n\tif (!user?.lastLogin) {\n\t\tfailedAttemptsSinceLastLogin = await ServerEvents.countFailedAttemptsByUsername(user.username);\n\t} else {\n\t\tfailedAttemptsSinceLastLogin = await ServerEvents.countFailedAttemptsByUsernameSince(user.username, new Date(user.lastLogin));\n\t}\n\n\tconst attemptsUntilBlock = settings.get('Block_Multiple_Failed_Logins_Attempts_Until_Block_by_User');\n\n\tif (attemptsUntilBlock && failedAttemptsSinceLastLogin < attemptsUntilBlock) {\n\t\treturn true;\n\t}\n\n\tconst lastAttemptAt = (await ServerEvents.findLastFailedAttemptByUsername(user.username as string))?.ts;\n\n\tif (!lastAttemptAt) {\n\t\treturn true;\n\t}\n\n\tconst minutesUntilUnblock = settings.get('Block_Multiple_Failed_Logins_Time_To_Unblock_By_User_In_Minutes') as number;\n\tconst willBeBlockedUntil = addMinutesToADate(new Date(lastAttemptAt), minutesUntilUnblock);\n\tconst isValid = moment(new Date()).isSameOrAfter(willBeBlockedUntil);\n\n\tif (settings.get('Block_Multiple_Failed_Logins_Notify_Failed') && !isValid) {\n\t\tnotifyFailedLogin(user.username, willBeBlockedUntil, failedAttemptsSinceLastLogin);\n\t}\n\n\treturn isValid;\n};\n\nexport const saveFailedLoginAttempts = async (login: ILoginAttempt): Promise<void> => {\n\tconst user: IServerEvent['u'] = {\n\t\t_id: login.user?._id,\n\t\tusername: login.user?.username || login.methodArguments[0].user?.username,\n\t};\n\n\tawait ServerEvents.insertOne({\n\t\tip: getClientAddress(login.connection),\n\t\tt: IServerEventType.FAILED_LOGIN_ATTEMPT,\n\t\tts: new Date(),\n\t\tu: user,\n\t});\n};\n\nexport const saveSuccessfulLogin = async (login: ILoginAttempt): Promise<void> => {\n\tconst user: IServerEvent['u'] = {\n\t\t_id: login.user?._id,\n\t\tusername: login.user?.username || login.methodArguments[0].user?.username,\n\t};\n\n\tawait ServerEvents.insertOne({\n\t\tip: getClientAddress(login.connection),\n\t\tt: IServerEventType.LOGIN,\n\t\tts: new Date(),\n\t\tu: user,\n\t});\n};\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","root":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/authentication/server/lib/restrictLoginAttempts.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/authentication/server/lib/restrictLoginAttempts.ts"}},"code":"module.export({\n  notifyFailedLogin: () => notifyFailedLogin,\n  isValidLoginAttemptByIp: () => isValidLoginAttemptByIp,\n  isValidAttemptByUser: () => isValidAttemptByUser,\n  saveFailedLoginAttempts: () => saveFailedLoginAttempts,\n  saveSuccessfulLogin: () => saveSuccessfulLogin\n});\nlet moment;\nmodule.link(\"moment\", {\n  default(v) {\n    moment = v;\n  }\n\n}, 0);\nlet ServerEvents, Users, Rooms, Sessions;\nmodule.link(\"../../../models/server/raw\", {\n  ServerEvents(v) {\n    ServerEvents = v;\n  },\n\n  Users(v) {\n    Users = v;\n  },\n\n  Rooms(v) {\n    Rooms = v;\n  },\n\n  Sessions(v) {\n    Sessions = v;\n  }\n\n}, 1);\nlet IServerEventType;\nmodule.link(\"../../../../definition/IServerEvent\", {\n  IServerEventType(v) {\n    IServerEventType = v;\n  }\n\n}, 2);\nlet settings;\nmodule.link(\"../../../settings/server\", {\n  settings(v) {\n    settings = v;\n  }\n\n}, 3);\nlet addMinutesToADate;\nmodule.link(\"../../../../lib/utils/addMinutesToADate\", {\n  addMinutesToADate(v) {\n    addMinutesToADate = v;\n  }\n\n}, 4);\nlet getClientAddress;\nmodule.link(\"../../../../server/lib/getClientAddress\", {\n  getClientAddress(v) {\n    getClientAddress = v;\n  }\n\n}, 5);\nlet sendMessage;\nmodule.link(\"../../../lib/server/functions\", {\n  sendMessage(v) {\n    sendMessage = v;\n  }\n\n}, 6);\nlet Logger;\nmodule.link(\"../../../logger/server\", {\n  Logger(v) {\n    Logger = v;\n  }\n\n}, 7);\nconst logger = new Logger('LoginProtection');\n\nconst notifyFailedLogin = (ipOrUsername, blockedUntil, failedAttempts) => Promise.asyncApply(() => {\n  const channelToNotify = settings.get('Block_Multiple_Failed_Logins_Notify_Failed_Channel');\n\n  if (!channelToNotify) {\n    logger.error('Cannot notify failed logins: channel provided is invalid');\n    return;\n  } // verify channel exists\n  // to avoid issues when \"fname\" is presented in the UI, check if the name matches it as well\n\n\n  const room = Promise.await(Rooms.findOneByNameOrFname(channelToNotify));\n\n  if (!room) {\n    logger.error(\"Cannot notify failed logins: channel provided doesn't exists\");\n    return;\n  }\n\n  const rocketCat = Promise.await(Users.findOneById('rocket.cat')); // send message\n\n  const message = {\n    attachments: [{\n      fields: [{\n        title: 'Failed login attempt threshold exceeded',\n        value: \"User or IP: \".concat(ipOrUsername, \"\\nBlocked until: \").concat(blockedUntil, \"\\nFailed Attempts: \").concat(failedAttempts),\n        short: true\n      }],\n      color: 'red'\n    }]\n  };\n  Promise.await(sendMessage(rocketCat, message, room, false));\n});\n\nconst isValidLoginAttemptByIp = ip => Promise.asyncApply(() => {\n  var _await$ServerEvents$f;\n\n  const whitelist = String(settings.get('Block_Multiple_Failed_Logins_Ip_Whitelist')).split(',');\n\n  if (!settings.get('Block_Multiple_Failed_Logins_Enabled') || !settings.get('Block_Multiple_Failed_Logins_By_Ip') || whitelist.includes(ip)) {\n    return true;\n  }\n\n  const lastLogin = Promise.await(Sessions.findLastLoginByIp(ip));\n  let failedAttemptsSinceLastLogin;\n\n  if (!lastLogin || !lastLogin.loginAt) {\n    failedAttemptsSinceLastLogin = Promise.await(ServerEvents.countFailedAttemptsByIp(ip));\n  } else {\n    failedAttemptsSinceLastLogin = Promise.await(ServerEvents.countFailedAttemptsByIpSince(ip, new Date(lastLogin.loginAt)));\n  }\n\n  const attemptsUntilBlock = settings.get('Block_Multiple_Failed_Logins_Attempts_Until_Block_By_Ip');\n\n  if (attemptsUntilBlock && failedAttemptsSinceLastLogin < attemptsUntilBlock) {\n    return true;\n  }\n\n  const lastAttemptAt = (_await$ServerEvents$f = Promise.await(ServerEvents.findLastFailedAttemptByIp(ip))) === null || _await$ServerEvents$f === void 0 ? void 0 : _await$ServerEvents$f.ts;\n\n  if (!lastAttemptAt) {\n    return true;\n  }\n\n  const minutesUntilUnblock = settings.get('Block_Multiple_Failed_Logins_Time_To_Unblock_By_Ip_In_Minutes');\n  const willBeBlockedUntil = addMinutesToADate(new Date(lastAttemptAt), minutesUntilUnblock);\n  const isValid = moment(new Date()).isSameOrAfter(willBeBlockedUntil);\n\n  if (settings.get('Block_Multiple_Failed_Logins_Notify_Failed') && !isValid) {\n    notifyFailedLogin(ip, willBeBlockedUntil, failedAttemptsSinceLastLogin);\n  }\n\n  return isValid;\n});\n\nconst isValidAttemptByUser = login => Promise.asyncApply(() => {\n  var _login$methodArgument, _await$ServerEvents$f2;\n\n  if (!settings.get('Block_Multiple_Failed_Logins_Enabled') || !settings.get('Block_Multiple_Failed_Logins_By_User')) {\n    return true;\n  }\n\n  const user = login.user || Promise.await(Users.findOneByUsername((_login$methodArgument = login.methodArguments[0].user) === null || _login$methodArgument === void 0 ? void 0 : _login$methodArgument.username));\n\n  if (!(user !== null && user !== void 0 && user.username)) {\n    return true;\n  }\n\n  let failedAttemptsSinceLastLogin;\n\n  if (!(user !== null && user !== void 0 && user.lastLogin)) {\n    failedAttemptsSinceLastLogin = Promise.await(ServerEvents.countFailedAttemptsByUsername(user.username));\n  } else {\n    failedAttemptsSinceLastLogin = Promise.await(ServerEvents.countFailedAttemptsByUsernameSince(user.username, new Date(user.lastLogin)));\n  }\n\n  const attemptsUntilBlock = settings.get('Block_Multiple_Failed_Logins_Attempts_Until_Block_by_User');\n\n  if (attemptsUntilBlock && failedAttemptsSinceLastLogin < attemptsUntilBlock) {\n    return true;\n  }\n\n  const lastAttemptAt = (_await$ServerEvents$f2 = Promise.await(ServerEvents.findLastFailedAttemptByUsername(user.username))) === null || _await$ServerEvents$f2 === void 0 ? void 0 : _await$ServerEvents$f2.ts;\n\n  if (!lastAttemptAt) {\n    return true;\n  }\n\n  const minutesUntilUnblock = settings.get('Block_Multiple_Failed_Logins_Time_To_Unblock_By_User_In_Minutes');\n  const willBeBlockedUntil = addMinutesToADate(new Date(lastAttemptAt), minutesUntilUnblock);\n  const isValid = moment(new Date()).isSameOrAfter(willBeBlockedUntil);\n\n  if (settings.get('Block_Multiple_Failed_Logins_Notify_Failed') && !isValid) {\n    notifyFailedLogin(user.username, willBeBlockedUntil, failedAttemptsSinceLastLogin);\n  }\n\n  return isValid;\n});\n\nconst saveFailedLoginAttempts = login => Promise.asyncApply(() => {\n  var _login$user, _login$user2, _login$methodArgument2;\n\n  const user = {\n    _id: (_login$user = login.user) === null || _login$user === void 0 ? void 0 : _login$user._id,\n    username: ((_login$user2 = login.user) === null || _login$user2 === void 0 ? void 0 : _login$user2.username) || ((_login$methodArgument2 = login.methodArguments[0].user) === null || _login$methodArgument2 === void 0 ? void 0 : _login$methodArgument2.username)\n  };\n  Promise.await(ServerEvents.insertOne({\n    ip: getClientAddress(login.connection),\n    t: IServerEventType.FAILED_LOGIN_ATTEMPT,\n    ts: new Date(),\n    u: user\n  }));\n});\n\nconst saveSuccessfulLogin = login => Promise.asyncApply(() => {\n  var _login$user3, _login$user4, _login$methodArgument3;\n\n  const user = {\n    _id: (_login$user3 = login.user) === null || _login$user3 === void 0 ? void 0 : _login$user3._id,\n    username: ((_login$user4 = login.user) === null || _login$user4 === void 0 ? void 0 : _login$user4.username) || ((_login$methodArgument3 = login.methodArguments[0].user) === null || _login$methodArgument3 === void 0 ? void 0 : _login$methodArgument3.username)\n  };\n  Promise.await(ServerEvents.insertOne({\n    ip: getClientAddress(login.connection),\n    t: IServerEventType.LOGIN,\n    ts: new Date(),\n    u: user\n  }));\n});","map":{"version":3,"sources":["app/authentication/server/lib/restrictLoginAttempts.ts"],"names":[],"mappings":"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","sourcesContent":["import moment from 'moment';\n\nimport { ILoginAttempt } from '../ILoginAttempt';\nimport { ServerEvents, Users, Rooms, Sessions } from '../../../models/server/raw';\nimport { IServerEventType, IServerEvent } from '../../../../definition/IServerEvent';\nimport { settings } from '../../../settings/server';\nimport { addMinutesToADate } from '../../../../lib/utils/addMinutesToADate';\nimport { getClientAddress } from '../../../../server/lib/getClientAddress';\nimport { sendMessage } from '../../../lib/server/functions';\nimport { Logger } from '../../../logger/server';\n\nconst logger = new Logger('LoginProtection');\n\nexport const notifyFailedLogin = async (ipOrUsername: string, blockedUntil: Date, failedAttempts: number): Promise<void> => {\n\tconst channelToNotify = settings.get('Block_Multiple_Failed_Logins_Notify_Failed_Channel');\n\tif (!channelToNotify) {\n\t\tlogger.error('Cannot notify failed logins: channel provided is invalid');\n\t\treturn;\n\t}\n\t// verify channel exists\n\t// to avoid issues when \"fname\" is presented in the UI, check if the name matches it as well\n\tconst room = await Rooms.findOneByNameOrFname(channelToNotify);\n\tif (!room) {\n\t\tlogger.error(\"Cannot notify failed logins: channel provided doesn't exists\");\n\t\treturn;\n\t}\n\n\tconst rocketCat = await Users.findOneById('rocket.cat');\n\t// send message\n\tconst message = {\n\t\tattachments: [\n\t\t\t{\n\t\t\t\tfields: [\n\t\t\t\t\t{\n\t\t\t\t\t\ttitle: 'Failed login attempt threshold exceeded',\n\t\t\t\t\t\tvalue: `User or IP: ${ipOrUsername}\\nBlocked until: ${blockedUntil}\\nFailed Attempts: ${failedAttempts}`,\n\t\t\t\t\t\tshort: true,\n\t\t\t\t\t},\n\t\t\t\t],\n\t\t\t\tcolor: 'red',\n\t\t\t},\n\t\t],\n\t};\n\n\tawait sendMessage(rocketCat, message, room, false);\n};\n\nexport const isValidLoginAttemptByIp = async (ip: string): Promise<boolean> => {\n\tconst whitelist = String(settings.get('Block_Multiple_Failed_Logins_Ip_Whitelist')).split(',');\n\n\tif (\n\t\t!settings.get('Block_Multiple_Failed_Logins_Enabled') ||\n\t\t!settings.get('Block_Multiple_Failed_Logins_By_Ip') ||\n\t\twhitelist.includes(ip)\n\t) {\n\t\treturn true;\n\t}\n\n\tconst lastLogin = await Sessions.findLastLoginByIp(ip);\n\tlet failedAttemptsSinceLastLogin;\n\n\tif (!lastLogin || !lastLogin.loginAt) {\n\t\tfailedAttemptsSinceLastLogin = await ServerEvents.countFailedAttemptsByIp(ip);\n\t} else {\n\t\tfailedAttemptsSinceLastLogin = await ServerEvents.countFailedAttemptsByIpSince(ip, new Date(lastLogin.loginAt));\n\t}\n\n\tconst attemptsUntilBlock = settings.get('Block_Multiple_Failed_Logins_Attempts_Until_Block_By_Ip');\n\n\tif (attemptsUntilBlock && failedAttemptsSinceLastLogin < attemptsUntilBlock) {\n\t\treturn true;\n\t}\n\n\tconst lastAttemptAt = (await ServerEvents.findLastFailedAttemptByIp(ip))?.ts;\n\n\tif (!lastAttemptAt) {\n\t\treturn true;\n\t}\n\n\tconst minutesUntilUnblock = settings.get('Block_Multiple_Failed_Logins_Time_To_Unblock_By_Ip_In_Minutes') as number;\n\tconst willBeBlockedUntil = addMinutesToADate(new Date(lastAttemptAt), minutesUntilUnblock);\n\tconst isValid = moment(new Date()).isSameOrAfter(willBeBlockedUntil);\n\n\tif (settings.get('Block_Multiple_Failed_Logins_Notify_Failed') && !isValid) {\n\t\tnotifyFailedLogin(ip, willBeBlockedUntil, failedAttemptsSinceLastLogin);\n\t}\n\n\treturn isValid;\n};\n\nexport const isValidAttemptByUser = async (login: ILoginAttempt): Promise<boolean> => {\n\tif (!settings.get('Block_Multiple_Failed_Logins_Enabled') || !settings.get('Block_Multiple_Failed_Logins_By_User')) {\n\t\treturn true;\n\t}\n\n\tconst user = login.user || (await Users.findOneByUsername(login.methodArguments[0].user?.username));\n\n\tif (!user?.username) {\n\t\treturn true;\n\t}\n\n\tlet failedAttemptsSinceLastLogin;\n\n\tif (!user?.lastLogin) {\n\t\tfailedAttemptsSinceLastLogin = await ServerEvents.countFailedAttemptsByUsername(user.username);\n\t} else {\n\t\tfailedAttemptsSinceLastLogin = await ServerEvents.countFailedAttemptsByUsernameSince(user.username, new Date(user.lastLogin));\n\t}\n\n\tconst attemptsUntilBlock = settings.get('Block_Multiple_Failed_Logins_Attempts_Until_Block_by_User');\n\n\tif (attemptsUntilBlock && failedAttemptsSinceLastLogin < attemptsUntilBlock) {\n\t\treturn true;\n\t}\n\n\tconst lastAttemptAt = (await ServerEvents.findLastFailedAttemptByUsername(user.username as string))?.ts;\n\n\tif (!lastAttemptAt) {\n\t\treturn true;\n\t}\n\n\tconst minutesUntilUnblock = settings.get('Block_Multiple_Failed_Logins_Time_To_Unblock_By_User_In_Minutes') as number;\n\tconst willBeBlockedUntil = addMinutesToADate(new Date(lastAttemptAt), minutesUntilUnblock);\n\tconst isValid = moment(new Date()).isSameOrAfter(willBeBlockedUntil);\n\n\tif (settings.get('Block_Multiple_Failed_Logins_Notify_Failed') && !isValid) {\n\t\tnotifyFailedLogin(user.username, willBeBlockedUntil, failedAttemptsSinceLastLogin);\n\t}\n\n\treturn isValid;\n};\n\nexport const saveFailedLoginAttempts = async (login: ILoginAttempt): Promise<void> => {\n\tconst user: IServerEvent['u'] = {\n\t\t_id: login.user?._id,\n\t\tusername: login.user?.username || login.methodArguments[0].user?.username,\n\t};\n\n\tawait ServerEvents.insertOne({\n\t\tip: getClientAddress(login.connection),\n\t\tt: IServerEventType.FAILED_LOGIN_ATTEMPT,\n\t\tts: new Date(),\n\t\tu: user,\n\t});\n};\n\nexport const saveSuccessfulLogin = async (login: ILoginAttempt): Promise<void> => {\n\tconst user: IServerEvent['u'] = {\n\t\t_id: login.user?._id,\n\t\tusername: login.user?.username || login.methodArguments[0].user?.username,\n\t};\n\n\tawait ServerEvents.insertOne({\n\t\tip: getClientAddress(login.connection),\n\t\tt: IServerEventType.LOGIN,\n\t\tts: new Date(),\n\t\tu: user,\n\t});\n};\n"],"sourceRoot":""},"sourceType":"module","hash":"5a909077424575345386653177f5714ece2604ed"}
