{"metadata":{},"options":{"assumptions":{},"compact":false,"sourceMaps":true,"ast":true,"babelrc":false,"configFile":false,"parserOpts":{"sourceType":"module","sourceFileName":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/models/server/raw/Roles.ts","plugins":["*","flow","jsx","asyncGenerators","bigInt","classPrivateMethods","classPrivateProperties","classProperties","doExpressions","dynamicImport","exportDefaultFrom","exportExtensions","exportNamespaceFrom","functionBind","functionSent","importMeta","nullishCoalescingOperator","numericSeparator","objectRestSpread","optionalCatchBinding","optionalChaining",["pipelineOperator",{"proposal":"minimal"}],"throwExpressions","objectRestSpread","asyncGenerators","classProperties","classPrivateProperties","jsx","nullishCoalescingOperator","nullishCoalescingOperator","optionalChaining","optionalCatchBinding","optionalCatchBinding","classProperties","classPrivateProperties","classPrivateMethods","classProperties","classPrivateProperties","asyncGenerators","asyncGenerators","objectRestSpread","logicalAssignment"],"allowImportExportEverywhere":true,"allowReturnOutsideFunction":true,"allowUndeclaredExports":true,"strictMode":false},"caller":{"name":"meteor","arch":"os.osx.arm64"},"sourceFileName":"app/models/server/raw/Roles.ts","filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/models/server/raw/Roles.ts","inputSourceMap":{"version":3,"file":"app/models/server/raw/Roles.ts","sourceRoot":"","sources":["app/models/server/raw/Roles.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n\tCollection,\n\tCursor,\n\tFilterQuery,\n\tFindOneOptions,\n\tInsertOneWriteOpResult,\n\tUpdateWriteOpResult,\n\tWithId,\n\tWithoutProjection,\n} from 'mongodb';\n\nimport { IRole, IUser } from '../../../../definition/IUser';\nimport { BaseRaw } from './BaseRaw';\nimport { SubscriptionsRaw } from './Subscriptions';\nimport { UsersRaw } from './Users';\n\ntype ScopedModelRoles = {\n\tSubscriptions: SubscriptionsRaw;\n\tUsers: UsersRaw;\n};\n\nexport class RolesRaw extends BaseRaw<IRole> {\n\tconstructor(public readonly col: Collection<IRole>, private readonly models: ScopedModelRoles, trash?: Collection<IRole>) {\n\t\tsuper(col, trash);\n\t}\n\n\tfindByUpdatedDate(updatedAfterDate: Date, options?: FindOneOptions<IRole>): Cursor<IRole> {\n\t\tconst query = {\n\t\t\t_updatedAt: { $gte: new Date(updatedAfterDate) },\n\t\t};\n\n\t\treturn options ? this.find(query, options) : this.find(query);\n\t}\n\n\tcreateOrUpdate(\n\t\tname: IRole['name'],\n\t\tscope: 'Users' | 'Subscriptions' = 'Users',\n\t\tdescription = '',\n\t\tprotectedRole = true,\n\t\tmandatory2fa = false,\n\t): Promise<UpdateWriteOpResult> {\n\t\tconst queryData = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tprotected: protectedRole,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.updateOne({ _id: name }, { $set: queryData }, { upsert: true });\n\t}\n\n\tasync addUserRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: string): Promise<boolean> {\n\t\tif (!Array.isArray(roles)) {\n\t\t\troles = [roles];\n\t\t\tprocess.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.addUserRoles: roles should be an array');\n\t\t}\n\n\t\tfor await (const name of roles) {\n\t\t\tconst role = await this.findOne({ name }, { scope: 1 } as FindOneOptions<IRole>);\n\n\t\t\tif (!role) {\n\t\t\t\tprocess.env.NODE_ENV === 'development' && console.warn(`[WARN] RolesRaw.addUserRoles: role: ${name} not found`);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tawait this.models.Subscriptions.addRolesByUserId(userId, [name], scope);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tawait this.models.Users.addRolesByUserId(userId, [name]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync isUserInRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: string): Promise<boolean> {\n\t\tif (!Array.isArray(roles)) {\n\t\t\t// TODO: remove this check\n\t\t\troles = [roles];\n\t\t\tprocess.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.isUserInRoles: roles should be an array');\n\t\t}\n\n\t\tfor await (const roleName of roles) {\n\t\t\tconst role = await this.findOne({ name: roleName }, { scope: 1 } as FindOneOptions<IRole>);\n\n\t\t\tif (!role) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tif (await this.models.Subscriptions.isUserInRole(userId, roleName, scope)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tif (await this.models.Users.isUserInRole(userId, roleName)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync removeUserRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: string): Promise<boolean> {\n\t\tif (!Array.isArray(roles)) {\n\t\t\t// TODO: remove this check\n\t\t\troles = [roles];\n\t\t\tprocess.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.removeUserRoles: roles should be an array');\n\t\t}\n\t\tfor await (const roleName of roles) {\n\t\t\tconst role = await this.findOne({ name: roleName }, { scope: 1 } as FindOneOptions<IRole>);\n\n\t\t\tif (!role) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tscope && (await this.models.Subscriptions.removeRolesByUserId(userId, [roleName], scope));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tawait this.models.Users.removeRolesByUserId(userId, [roleName]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync findOneByIdOrName(_idOrName: IRole['_id'] | IRole['name'], options?: undefined): Promise<IRole | null>;\n\n\tasync findOneByIdOrName(\n\t\t_idOrName: IRole['_id'] | IRole['name'],\n\t\toptions: WithoutProjection<FindOneOptions<IRole>>,\n\t): Promise<IRole | null>;\n\n\tasync findOneByIdOrName<P>(\n\t\t_idOrName: IRole['_id'] | IRole['name'],\n\t\toptions: FindOneOptions<P extends IRole ? IRole : P>,\n\t): Promise<P | null>;\n\n\tfindOneByIdOrName<P>(_idOrName: IRole['_id'] | IRole['name'], options?: any): Promise<IRole | P | null> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\t$or: [\n\t\t\t\t{\n\t\t\t\t\t_id: _idOrName,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: _idOrName,\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\treturn this.findOne(query, options);\n\t}\n\n\tupdateById(\n\t\t_id: IRole['_id'],\n\t\tname: IRole['name'],\n\t\tscope: IRole['scope'],\n\t\tdescription: IRole['description'] = '',\n\t\tmandatory2fa: IRole['mandatory2fa'] = false,\n\t): Promise<UpdateWriteOpResult> {\n\t\tconst queryData = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.updateOne({ _id }, { $set: queryData }, { upsert: true });\n\t}\n\n\tfindUsersInRole(name: IRole['name'], scope?: string): Promise<Cursor<IUser>>;\n\n\tfindUsersInRole(\n\t\tname: IRole['name'],\n\t\tscope: string | undefined,\n\t\toptions: WithoutProjection<FindOneOptions<IUser>>,\n\t): Promise<Cursor<IUser>>;\n\n\tfindUsersInRole<P>(\n\t\tname: IRole['name'],\n\t\tscope: string | undefined,\n\t\toptions: FindOneOptions<P extends IUser ? IUser : P>,\n\t): Promise<Cursor<P extends IUser ? IUser : P>>;\n\n\tasync findUsersInRole<P>(name: IRole['name'], scope: string | undefined, options?: any | undefined): Promise<Cursor<IUser> | Cursor<P>> {\n\t\tconst role = await this.findOne({ name }, { scope: 1 } as FindOneOptions<IRole>);\n\n\t\tif (!role) {\n\t\t\tthrow new Error('RolesRaw.findUsersInRole: role not found');\n\t\t}\n\n\t\tswitch (role.scope) {\n\t\t\tcase 'Subscriptions':\n\t\t\t\treturn this.models.Subscriptions.findUsersInRoles([name], scope, options);\n\t\t\tcase 'Users':\n\t\t\tdefault:\n\t\t\t\treturn this.models.Users.findUsersInRoles([name], options);\n\t\t}\n\t}\n\n\tcreateWithRandomId(\n\t\tname: IRole['name'],\n\t\tscope: 'Users' | 'Subscriptions' = 'Users',\n\t\tdescription = '',\n\t\tprotectedRole = true,\n\t\tmandatory2fa = false,\n\t): Promise<InsertOneWriteOpResult<WithId<IRole>>> {\n\t\tconst role = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tprotected: protectedRole,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.insertOne(role);\n\t}\n\n\tasync canAddUserToRole(uid: IUser['_id'], name: IRole['name'], scope?: string): Promise<boolean> {\n\t\tconst role = await this.findOne({ name }, { fields: { scope: 1 } } as FindOneOptions<IRole>);\n\t\tif (!role) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (role.scope) {\n\t\t\tcase 'Subscriptions':\n\t\t\t\treturn this.models.Subscriptions.isUserInRoleScope(uid, scope);\n\t\t\tcase 'Users':\n\t\t\tdefault:\n\t\t\t\treturn this.models.Users.isUserInRoleScope(uid);\n\t\t}\n\t}\n}\n"]},"targets":{"android":"95.0.0","chrome":"95.0.0","edge":"95.0.0","firefox":"78.0.0","ie":"10.0.0","ios":"15.0.0","opera":"81.0.0","safari":"15.1.0","samsung":"14.0.0"},"cloneInputAst":true,"browserslistConfigFile":false,"passPerPreset":false,"envName":"development","cwd":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","root":"/Users/amangupta/Documents/Open-Source/Rocket.Chat","rootMode":"root","plugins":[{"key":"base$0","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"base$0$0","visitor":{"Program":{"enter":[null],"exit":[null]},"_exploded":true,"_verified":true},"options":{"avoidModernSyntax":false,"enforceStrictMode":false,"dynamicImport":true,"generateLetDeclarations":true}},{"key":"transform-runtime","visitor":{"MemberExpression":{"enter":[null]},"ObjectPattern":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":{},"_verified":{},"Identifier":{"enter":[null]},"JSXIdentifier":{"enter":[null]}},"options":{"version":"7.16.5","helpers":true,"useESModules":false,"corejs":false}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"transform-meteor-async-await","visitor":{"AwaitExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"exit":[null]},"FunctionExpression":{"exit":[null]},"ObjectMethod":{"exit":[null]},"ArrowFunctionExpression":{"exit":[null]},"ClassMethod":{"exit":[null]},"ClassPrivateMethod":{"exit":[null]}},"options":{"useNativeAsyncAwait":false}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{"loose":true}},{"key":"transform-react-jsx","visitor":{"_exploded":{},"_verified":{},"JSXNamespacedName":{"enter":[null]},"JSXSpreadChild":{"enter":[null]},"Program":{"enter":[null]},"JSXElement":{"exit":[null]},"JSXFragment":{"exit":[null]},"JSXAttribute":{"enter":[null]}},"options":{"pragma":"React.createElement","pragmaFrag":"React.Fragment","runtime":"classic","throwIfNamespace":true,"useBuiltIns":false}},{"key":"transform-react-display-name","visitor":{"ExportDefaultDeclaration":{"enter":[null]},"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-react-pure-annotations","visitor":{"CallExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"syntax-nullish-coalescing-operator","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-nullish-coalescing-operator","visitor":{"_exploded":{},"_verified":{},"LogicalExpression":{"enter":[null]}},"options":{}},{"key":"syntax-optional-chaining","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-chaining","visitor":{"_exploded":true,"OptionalCallExpression":{"enter":[null]},"OptionalMemberExpression":{"enter":[null]},"_verified":true},"options":{}},{"key":"syntax-optional-catch-binding","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-optional-catch-binding","visitor":{"_exploded":{},"_verified":{},"CatchClause":{"enter":[null]}},"options":{}},{"key":"syntax-class-properties","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-class-properties","visitor":{"PrivateName":{"enter":[null]},"ExportDefaultDeclaration":{"enter":[null]},"_exploded":true,"_verified":true,"ClassExpression":{"enter":[null]},"ClassDeclaration":{"enter":[null]}},"options":{}},{"key":"syntax-async-generators","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-async-generator-functions","visitor":{"_exploded":{},"_verified":{},"Program":{"enter":[null]}},"options":{}},{"key":"syntax-object-rest-spread","visitor":{"_exploded":true,"_verified":true},"options":{}},{"key":"proposal-object-rest-spread","visitor":{"VariableDeclarator":{"enter":[null]},"ExportNamedDeclaration":{"enter":[null]},"CatchClause":{"enter":[null]},"AssignmentExpression":{"enter":[null]},"ArrayPattern":{"enter":[null]},"ObjectExpression":{"enter":[null]},"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]},"ForInStatement":{"enter":[null]},"ForOfStatement":{"enter":[null]}},"options":{}},{"key":"proposal-logical-assignment-operators","visitor":{"_exploded":{},"_verified":{},"AssignmentExpression":{"enter":[null]}},"options":{}},{"key":"transform-literals","visitor":{"NumericLiteral":{"enter":[null]},"StringLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-template-literals","visitor":{"TaggedTemplateExpression":{"enter":[null]},"TemplateLiteral":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}},{"key":"transform-parameters","visitor":{"_exploded":true,"_verified":true,"FunctionDeclaration":{"enter":[null]},"FunctionExpression":{"enter":[null]},"ObjectMethod":{"enter":[null]},"ArrowFunctionExpression":{"enter":[null]},"ClassMethod":{"enter":[null]},"ClassPrivateMethod":{"enter":[null]}},"options":{}},{"key":"transform-exponentiation-operator","visitor":{"AssignmentExpression":{"enter":[null]},"BinaryExpression":{"enter":[null]},"_exploded":true,"_verified":true},"options":{}}],"presets":[],"generatorOpts":{"filename":"/Users/amangupta/Documents/Open-Source/Rocket.Chat/app/models/server/raw/Roles.ts","comments":true,"compact":false,"sourceMaps":true,"sourceFileName":"app/models/server/raw/Roles.ts"}},"code":"let _asyncIterator;\n\nmodule.link(\"@babel/runtime/helpers/asyncIterator\", {\n  default(v) {\n    _asyncIterator = v;\n  }\n\n}, 0);\nmodule.export({\n  RolesRaw: () => RolesRaw\n});\nlet BaseRaw;\nmodule.link(\"./BaseRaw\", {\n  BaseRaw(v) {\n    BaseRaw = v;\n  }\n\n}, 0);\n\nclass RolesRaw extends BaseRaw {\n  constructor(col, models, trash) {\n    super(col, trash);\n    this.col = void 0;\n    this.models = void 0;\n    this.col = col;\n    this.models = models;\n  }\n\n  findByUpdatedDate(updatedAfterDate, options) {\n    const query = {\n      _updatedAt: {\n        $gte: new Date(updatedAfterDate)\n      }\n    };\n    return options ? this.find(query, options) : this.find(query);\n  }\n\n  createOrUpdate(name) {\n    let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Users';\n    let description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let protectedRole = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let mandatory2fa = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const queryData = {\n      name,\n      scope,\n      description,\n      protected: protectedRole,\n      mandatory2fa\n    };\n    return this.updateOne({\n      _id: name\n    }, {\n      $set: queryData\n    }, {\n      upsert: true\n    });\n  }\n\n  addUserRoles(userId, roles, scope) {\n    return Promise.asyncApply(() => {\n      if (!Array.isArray(roles)) {\n        roles = [roles];\n        process.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.addUserRoles: roles should be an array');\n      }\n\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(roles), _step; _iteratorAbruptCompletion = !(_step = Promise.await(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n          const name = _step.value;\n          const role = Promise.await(this.findOne({\n            name\n          }, {\n            scope: 1\n          }));\n\n          if (!role) {\n            process.env.NODE_ENV === 'development' && console.warn(\"[WARN] RolesRaw.addUserRoles: role: \".concat(name, \" not found\"));\n            continue;\n          }\n\n          switch (role.scope) {\n            case 'Subscriptions':\n              Promise.await(this.models.Subscriptions.addRolesByUserId(userId, [name], scope));\n              break;\n\n            case 'Users':\n            default:\n              Promise.await(this.models.Users.addRolesByUserId(userId, [name]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            Promise.await(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return true;\n    });\n  }\n\n  isUserInRoles(userId, roles, scope) {\n    return Promise.asyncApply(() => {\n      if (!Array.isArray(roles)) {\n        // TODO: remove this check\n        roles = [roles];\n        process.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.isUserInRoles: roles should be an array');\n      }\n\n      var _iteratorAbruptCompletion2 = false;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(roles), _step2; _iteratorAbruptCompletion2 = !(_step2 = Promise.await(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {\n          const roleName = _step2.value;\n          const role = Promise.await(this.findOne({\n            name: roleName\n          }, {\n            scope: 1\n          }));\n\n          if (!role) {\n            continue;\n          }\n\n          switch (role.scope) {\n            case 'Subscriptions':\n              if (Promise.await(this.models.Subscriptions.isUserInRole(userId, roleName, scope))) {\n                return true;\n              }\n\n              break;\n\n            case 'Users':\n            default:\n              if (Promise.await(this.models.Users.isUserInRole(userId, roleName))) {\n                return true;\n              }\n\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {\n            Promise.await(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return false;\n    });\n  }\n\n  removeUserRoles(userId, roles, scope) {\n    return Promise.asyncApply(() => {\n      if (!Array.isArray(roles)) {\n        // TODO: remove this check\n        roles = [roles];\n        process.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.removeUserRoles: roles should be an array');\n      }\n\n      var _iteratorAbruptCompletion3 = false;\n      var _didIteratorError3 = false;\n\n      var _iteratorError3;\n\n      try {\n        for (var _iterator3 = _asyncIterator(roles), _step3; _iteratorAbruptCompletion3 = !(_step3 = Promise.await(_iterator3.next())).done; _iteratorAbruptCompletion3 = false) {\n          const roleName = _step3.value;\n          const role = Promise.await(this.findOne({\n            name: roleName\n          }, {\n            scope: 1\n          }));\n\n          if (!role) {\n            continue;\n          }\n\n          switch (role.scope) {\n            case 'Subscriptions':\n              scope && Promise.await(this.models.Subscriptions.removeRolesByUserId(userId, [roleName], scope));\n              break;\n\n            case 'Users':\n            default:\n              Promise.await(this.models.Users.removeRolesByUserId(userId, [roleName]));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion3 && _iterator3.return != null) {\n            Promise.await(_iterator3.return());\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return true;\n    });\n  }\n\n  findOneByIdOrName(_idOrName, options) {\n    const query = {\n      $or: [{\n        _id: _idOrName\n      }, {\n        name: _idOrName\n      }]\n    };\n    return this.findOne(query, options);\n  }\n\n  updateById(_id, name, scope) {\n    let description = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n    let mandatory2fa = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const queryData = {\n      name,\n      scope,\n      description,\n      mandatory2fa\n    };\n    return this.updateOne({\n      _id\n    }, {\n      $set: queryData\n    }, {\n      upsert: true\n    });\n  }\n\n  findUsersInRole(name, scope, options) {\n    return Promise.asyncApply(() => {\n      const role = Promise.await(this.findOne({\n        name\n      }, {\n        scope: 1\n      }));\n\n      if (!role) {\n        throw new Error('RolesRaw.findUsersInRole: role not found');\n      }\n\n      switch (role.scope) {\n        case 'Subscriptions':\n          return this.models.Subscriptions.findUsersInRoles([name], scope, options);\n\n        case 'Users':\n        default:\n          return this.models.Users.findUsersInRoles([name], options);\n      }\n    });\n  }\n\n  createWithRandomId(name) {\n    let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Users';\n    let description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    let protectedRole = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    let mandatory2fa = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    const role = {\n      name,\n      scope,\n      description,\n      protected: protectedRole,\n      mandatory2fa\n    };\n    return this.insertOne(role);\n  }\n\n  canAddUserToRole(uid, name, scope) {\n    return Promise.asyncApply(() => {\n      const role = Promise.await(this.findOne({\n        name\n      }, {\n        fields: {\n          scope: 1\n        }\n      }));\n\n      if (!role) {\n        return false;\n      }\n\n      switch (role.scope) {\n        case 'Subscriptions':\n          return this.models.Subscriptions.isUserInRoleScope(uid, scope);\n\n        case 'Users':\n        default:\n          return this.models.Users.isUserInRoleScope(uid);\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["app/models/server/raw/Roles.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n\tCollection,\n\tCursor,\n\tFilterQuery,\n\tFindOneOptions,\n\tInsertOneWriteOpResult,\n\tUpdateWriteOpResult,\n\tWithId,\n\tWithoutProjection,\n} from 'mongodb';\n\nimport { IRole, IUser } from '../../../../definition/IUser';\nimport { BaseRaw } from './BaseRaw';\nimport { SubscriptionsRaw } from './Subscriptions';\nimport { UsersRaw } from './Users';\n\ntype ScopedModelRoles = {\n\tSubscriptions: SubscriptionsRaw;\n\tUsers: UsersRaw;\n};\n\nexport class RolesRaw extends BaseRaw<IRole> {\n\tconstructor(public readonly col: Collection<IRole>, private readonly models: ScopedModelRoles, trash?: Collection<IRole>) {\n\t\tsuper(col, trash);\n\t}\n\n\tfindByUpdatedDate(updatedAfterDate: Date, options?: FindOneOptions<IRole>): Cursor<IRole> {\n\t\tconst query = {\n\t\t\t_updatedAt: { $gte: new Date(updatedAfterDate) },\n\t\t};\n\n\t\treturn options ? this.find(query, options) : this.find(query);\n\t}\n\n\tcreateOrUpdate(\n\t\tname: IRole['name'],\n\t\tscope: 'Users' | 'Subscriptions' = 'Users',\n\t\tdescription = '',\n\t\tprotectedRole = true,\n\t\tmandatory2fa = false,\n\t): Promise<UpdateWriteOpResult> {\n\t\tconst queryData = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tprotected: protectedRole,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.updateOne({ _id: name }, { $set: queryData }, { upsert: true });\n\t}\n\n\tasync addUserRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: string): Promise<boolean> {\n\t\tif (!Array.isArray(roles)) {\n\t\t\troles = [roles];\n\t\t\tprocess.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.addUserRoles: roles should be an array');\n\t\t}\n\n\t\tfor await (const name of roles) {\n\t\t\tconst role = await this.findOne({ name }, { scope: 1 } as FindOneOptions<IRole>);\n\n\t\t\tif (!role) {\n\t\t\t\tprocess.env.NODE_ENV === 'development' && console.warn(`[WARN] RolesRaw.addUserRoles: role: ${name} not found`);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tawait this.models.Subscriptions.addRolesByUserId(userId, [name], scope);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tawait this.models.Users.addRolesByUserId(userId, [name]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync isUserInRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: string): Promise<boolean> {\n\t\tif (!Array.isArray(roles)) {\n\t\t\t// TODO: remove this check\n\t\t\troles = [roles];\n\t\t\tprocess.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.isUserInRoles: roles should be an array');\n\t\t}\n\n\t\tfor await (const roleName of roles) {\n\t\t\tconst role = await this.findOne({ name: roleName }, { scope: 1 } as FindOneOptions<IRole>);\n\n\t\t\tif (!role) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tif (await this.models.Subscriptions.isUserInRole(userId, roleName, scope)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tif (await this.models.Users.isUserInRole(userId, roleName)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tasync removeUserRoles(userId: IUser['_id'], roles: IRole['_id'][], scope?: string): Promise<boolean> {\n\t\tif (!Array.isArray(roles)) {\n\t\t\t// TODO: remove this check\n\t\t\troles = [roles];\n\t\t\tprocess.env.NODE_ENV === 'development' && console.warn('[WARN] RolesRaw.removeUserRoles: roles should be an array');\n\t\t}\n\t\tfor await (const roleName of roles) {\n\t\t\tconst role = await this.findOne({ name: roleName }, { scope: 1 } as FindOneOptions<IRole>);\n\n\t\t\tif (!role) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (role.scope) {\n\t\t\t\tcase 'Subscriptions':\n\t\t\t\t\tscope && (await this.models.Subscriptions.removeRolesByUserId(userId, [roleName], scope));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Users':\n\t\t\t\tdefault:\n\t\t\t\t\tawait this.models.Users.removeRolesByUserId(userId, [roleName]);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tasync findOneByIdOrName(_idOrName: IRole['_id'] | IRole['name'], options?: undefined): Promise<IRole | null>;\n\n\tasync findOneByIdOrName(\n\t\t_idOrName: IRole['_id'] | IRole['name'],\n\t\toptions: WithoutProjection<FindOneOptions<IRole>>,\n\t): Promise<IRole | null>;\n\n\tasync findOneByIdOrName<P>(\n\t\t_idOrName: IRole['_id'] | IRole['name'],\n\t\toptions: FindOneOptions<P extends IRole ? IRole : P>,\n\t): Promise<P | null>;\n\n\tfindOneByIdOrName<P>(_idOrName: IRole['_id'] | IRole['name'], options?: any): Promise<IRole | P | null> {\n\t\tconst query: FilterQuery<IRole> = {\n\t\t\t$or: [\n\t\t\t\t{\n\t\t\t\t\t_id: _idOrName,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tname: _idOrName,\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\n\t\treturn this.findOne(query, options);\n\t}\n\n\tupdateById(\n\t\t_id: IRole['_id'],\n\t\tname: IRole['name'],\n\t\tscope: IRole['scope'],\n\t\tdescription: IRole['description'] = '',\n\t\tmandatory2fa: IRole['mandatory2fa'] = false,\n\t): Promise<UpdateWriteOpResult> {\n\t\tconst queryData = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.updateOne({ _id }, { $set: queryData }, { upsert: true });\n\t}\n\n\tfindUsersInRole(name: IRole['name'], scope?: string): Promise<Cursor<IUser>>;\n\n\tfindUsersInRole(\n\t\tname: IRole['name'],\n\t\tscope: string | undefined,\n\t\toptions: WithoutProjection<FindOneOptions<IUser>>,\n\t): Promise<Cursor<IUser>>;\n\n\tfindUsersInRole<P>(\n\t\tname: IRole['name'],\n\t\tscope: string | undefined,\n\t\toptions: FindOneOptions<P extends IUser ? IUser : P>,\n\t): Promise<Cursor<P extends IUser ? IUser : P>>;\n\n\tasync findUsersInRole<P>(name: IRole['name'], scope: string | undefined, options?: any | undefined): Promise<Cursor<IUser> | Cursor<P>> {\n\t\tconst role = await this.findOne({ name }, { scope: 1 } as FindOneOptions<IRole>);\n\n\t\tif (!role) {\n\t\t\tthrow new Error('RolesRaw.findUsersInRole: role not found');\n\t\t}\n\n\t\tswitch (role.scope) {\n\t\t\tcase 'Subscriptions':\n\t\t\t\treturn this.models.Subscriptions.findUsersInRoles([name], scope, options);\n\t\t\tcase 'Users':\n\t\t\tdefault:\n\t\t\t\treturn this.models.Users.findUsersInRoles([name], options);\n\t\t}\n\t}\n\n\tcreateWithRandomId(\n\t\tname: IRole['name'],\n\t\tscope: 'Users' | 'Subscriptions' = 'Users',\n\t\tdescription = '',\n\t\tprotectedRole = true,\n\t\tmandatory2fa = false,\n\t): Promise<InsertOneWriteOpResult<WithId<IRole>>> {\n\t\tconst role = {\n\t\t\tname,\n\t\t\tscope,\n\t\t\tdescription,\n\t\t\tprotected: protectedRole,\n\t\t\tmandatory2fa,\n\t\t};\n\n\t\treturn this.insertOne(role);\n\t}\n\n\tasync canAddUserToRole(uid: IUser['_id'], name: IRole['name'], scope?: string): Promise<boolean> {\n\t\tconst role = await this.findOne({ name }, { fields: { scope: 1 } } as FindOneOptions<IRole>);\n\t\tif (!role) {\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (role.scope) {\n\t\t\tcase 'Subscriptions':\n\t\t\t\treturn this.models.Subscriptions.isUserInRoleScope(uid, scope);\n\t\t\tcase 'Users':\n\t\t\tdefault:\n\t\t\t\treturn this.models.Users.isUserInRoleScope(uid);\n\t\t}\n\t}\n}\n"],"sourceRoot":""},"sourceType":"module","hash":"e06472a7980666dc42697d24234e898baa1396cb"}
